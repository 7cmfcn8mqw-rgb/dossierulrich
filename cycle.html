<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cycles – semi‑développée / simplifiée + aromatique</title>
<style>
  :root{
    --bg:#f6f7fb; --card:#fff; --ink:#111; --muted:#666; --line:#e3e5ef;
    --shadow:0 10px 30px rgba(0,0,0,.10);
    --ch:#d11;
    --accent:#1a8f3a;
    --r:16px;
  }
  body{margin:0;padding:24px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink);min-height:100vh;}

  .wrap{max-width:1020px;margin:0 auto;display:grid;gap:14px;grid-template-rows:auto 1fr;min-height:calc(100vh - 48px);}  /* 48px = padding vertical du body */
  .panel{background:var(--card);border-radius:var(--r);box-shadow:var(--shadow);padding:14px;display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between;}
  .left{display:flex;gap:12px;flex-wrap:wrap;align-items:center;flex:1;}
  label{display:flex;gap:8px;align-items:center;font-size:.95rem;}
  input[type="number"]{width:92px;padding:7px 10px;border-radius:10px;border:1px solid var(--line);outline:none;}
  input[type="number"].bad{border-color:rgba(209,17,17,.75);box-shadow:0 0 0 3px rgba(209,17,17,.12);}
  .ticks{display:flex;justify-content:space-between;color:var(--muted);font-size:.85rem;margin-top:6px;user-select:none}
  .reps{display:flex;justify-content:flex-start;gap:18px;align-items:flex-start}
  .tickBtn{
    background:transparent;border:0;padding:0;cursor:pointer;
    display:flex;flex-direction:column;align-items:center;gap:6px;
    color:var(--muted);font-size:.85rem;user-select:none;
  }
  .tickBtn .dot{width:10px;height:10px;border-radius:999px;background:#dcdcdc}
  .tickBtn.active{color:#111}
  .tickBtn.active .dot{background:#111}
  .tickBtn:focus-visible{outline:2px solid rgba(17,17,17,.35);outline-offset:6px;border-radius:12px;}

  #svg{transition:opacity .12s ease; opacity:1}
  #svg.switching{opacity:0;}

  .right{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end;flex:1 1 100%;width:100%;}
  /* force badge à droite */
  #aromaticAlert{order:999;}
  .badge{border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:#fbfbfe;font-size:.9rem;white-space:nowrap}
.badge.alert{border-color:rgba(209,17,17,.45);background:rgba(209,17,17,.10);color:#b80000;font-weight:800;}
  .pillRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .pillBtn{border:1px solid var(--line);border-radius:999px;padding:7px 12px;background:#fff;font-size:.92rem;cursor:pointer}
  .pillBtn[aria-pressed="true"]{border-color:rgba(209,17,17,.55);box-shadow:0 0 0 3px rgba(209,17,17,.12);font-weight:700}
  .pillBtn[disabled]{opacity:.45; cursor:not-allowed;}
  .pillBtn.shake{animation:shake .25s linear 1;}
  @keyframes shake{0%{transform:translateX(0)}25%{transform:translateX(-3px)}50%{transform:translateX(3px)}75%{transform:translateX(-2px)}100%{transform:translateX(0)}}

  .stage{background:var(--card);border-radius:var(--r);box-shadow:var(--shadow);padding:10px;position:relative;overflow:hidden;display:flex;flex-direction:column;min-height:560px;}
  svg{width:100%;height:100%;display:block;flex:1;}

  .stage svg{height: min(820px, 74vh);}

  .caption{display:flex;justify-content:space-between;color:var(--muted);font-size:.92rem;padding:8px 4px 2px;}

  /* SVG styles (reprend la charte du programme d'origine) */
  .bondCC{pointer-events:none;stroke:#111;stroke-width:2.4;stroke-linecap:round;}
  .semiBond{stroke:#111;stroke-width:2.4;stroke-linecap:round;}
  .skeletal{stroke:#111;stroke-width:3.2;stroke-linecap:round;stroke-linejoin:round;fill:none;}

  .nameTag{
    position:absolute;
    left:14px;
    bottom:12px;
    font-size:1.05rem;
    font-weight:700;
    color:#111;
    background:rgba(255,255,255,.85);
    padding:6px 10px;
    border-radius:10px;
    border:1px solid var(--line);
  }


  .hotAtom{fill:transparent; stroke:none; cursor:pointer;}
  .hotBond{stroke:transparent; stroke-width:18; cursor:pointer; stroke-linecap:round;}

  /* --- Chips (drag & drop) --- */
  .chips{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    border:1px solid var(--line);border-radius:999px;padding:8px 12px;
    background:#fff;font-weight:850;cursor:grab; user-select:none;
  }
  .chip:active{cursor:grabbing;}
  .chip small{font-weight:700;color:var(--muted)}
  .bondChip{ width:56px; justify-content:center; font-weight:900; }
  .bondChip .bondSym{ font-size:22px; line-height:1; }
  .chip.disabled{ opacity:.35; filter:grayscale(1); pointer-events:none; }
  .hoverRing{ pointer-events:none; }


  /* --- Chips (drag & drop) --- */
  .chips{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .chip{
    display:inline-flex;align-items:center;gap:8px;
    border:1px solid var(--line);border-radius:999px;padding:8px 12px;
    background:#fff;font-weight:850;cursor:grab; user-select:none;
  }
  .chip:active{cursor:grabbing;}
  .chip small{font-weight:700;color:var(--muted)}
  .bondChip{ width:56px; justify-content:center; font-weight:900; }
  .bondChip .bondSym{ font-size:22px; line-height:1; }
  .chip.disabled{ opacity:.35; filter:grayscale(1); pointer-events:none; }
  .hoverRing{ pointer-events:none; }


  /* --- Number badges (style like fonctions_organiques.html) --- */
  .numBadgeRect{
    fill: rgba(255,255,255,0.45);
    stroke: rgba(0,0,0,0.18);
    stroke-width: 1;
  }
  .numBadgeText{
    font-size: 18px;
    font-weight: 800;
    fill: #c41313;
    dominant-baseline: middle;
    text-anchor: middle;
    paint-order: stroke;
    stroke: rgba(255,255,255,0.95);
    stroke-width: 4;
  }

</style>
</head>
<body>

<a href="index.html" class="backBtn">←</a>
<style>
.backBtn{
 position:fixed;
 top:16px;
 left:16px;
 width:44px;
 height:44px;
 display:flex;
 align-items:center;
 justify-content:center;
 background:#f2f2f2;
 border-radius:12px;
 font-size:22px;
 text-decoration:none;
 color:#111;
 box-shadow:0 6px 14px rgba(0,0,0,.25);
}
.backBtn:hover{background:#e6e6e6;}
</style>


  <div class="wrap">
    <div class="panel">
      <div class="left">
        <label>Carbones au départ <input type="number" id="nC" min="3" max="10" value="6"></label>

        <div style="display:grid;gap:6px;min-width:min(420px,92vw);flex:1;">
          <div class="ticks reps" role="radiogroup" aria-label="Choisir la représentation">
            <button class="tickBtn active" type="button" role="radio" aria-checked="true" data-i="2">
              <span class="dot" aria-hidden="true"></span>
              <span>Formule semi‑développée</span>
            </button>
            <button class="tickBtn" type="button" role="radio" aria-checked="false" data-i="3">
              <span class="dot" aria-hidden="true"></span>
              <span>Formule simplifiée</span>
            </button>
            <button class="tickBtn" id="repAroSimp" type="button" role="radio" aria-checked="false" data-i="4" style="display:none">
              <span class="dot" aria-hidden="true"></span>
              <span>Formule simplifiée pour aromatique</span>
            </button>
          </div>
        </div>

        <div class="pillRow">
          <label style="gap:10px">
            <input type="checkbox" id="aro"/>
            Aromatique
          </label>
          <button type="button" class="pillBtn" id="optA" aria-pressed="true" disabled>Option A</button>
          <button type="button" class="pillBtn" id="optB" aria-pressed="false" disabled>Option B</button>
        
        <div class="pillRow" style="gap:8px">
  <button type="button" class="pillBtn" id="toggleNums" aria-pressed="false" title="Afficher / masquer la numérotation du cycle">Numérotation</button>
  <button type="button" class="pillBtn" id="rotPlus" title="Rotation horaire (+α, α = 360/n)">+ Rotation</button>
  <button type="button" class="pillBtn" id="rotMinus" title="Rotation anti‑horaire (−α, α = 360/n)">− Rotation</button>
  <button type="button" class="pillBtn" id="aroCircleBtn" style="display:none" aria-pressed="false" style="display:none" title="Mode aromatique (formule simplifiée) : cercle dans l’anneau">Aromatique (cercle)</button>
  <button type="button" class="pillBtn" id="radicalBtn" style="display:none" aria-pressed="false" title="Transformer benzène/toluène en radical aromatique">Radical</button>
  <button type="button" class="pillBtn" id="resetSim" title="Recommencer depuis le début">Reset</button>
</div>

<div class="chips" aria-label="À glisser (méthyl / éthyl / double liaison)">
          <div class="chip" draggable="true" data-dragSub="méthyl">méthyl <small>(CH₃)</small></div>
          <div class="chip" draggable="true" data-dragSub="éthyl">éthyl <small>(C₂H₅)</small></div>
          <div class="chip bondChip" draggable="true" data-bond="2" title="Double liaison (déposer sur une liaison)"><span class="bondSym">═</span></div>
        </div>

</div>

      <div class=\"right\">
        <span class="badge" id="phaseTxt">Formule semi‑développée</span>
        <span class="badge" id="msg">Par défaut : cycloalcane.</span>
        <span class="badge alert" id="aromaticAlert" style="float:right;margin-left:auto;" style="display:none">⚠ Aromatique</span>
      </div>
    </div>

    <div class="stage">
      <div class="nameTag" id="molName">cyclohexane</div>
      <svg id="svg" viewBox="0 -60 980 700" aria-label="Cycle"></svg>
      <div class="caption">
        <div id="countTxt">Carbones : 6</div>
        
      </div>
    </div>
  </div>

<script>

(() => {
  const svg = document.getElementById('svg');
  const nC = document.getElementById('nC');
  const aro = document.getElementById('aro');
  const optA = document.getElementById('optA');
  const optB = document.getElementById('optB');
  const repAroSimp = document.getElementById('repAroSimp');
  const phaseTxt = document.getElementById('phaseTxt');
  const toggleNums = document.getElementById('toggleNums');
  const rotPlus = document.getElementById('rotPlus');
  const resetSim = document.getElementById('resetSim');
  const rotMinus = document.getElementById('rotMinus');
  const aroCircleBtn = document.getElementById('aroCircleBtn');
  const radicalBtn = document.getElementById('radicalBtn');

  const msg = document.getElementById('msg');
  const aromaticAlert = document.getElementById('aromaticAlert');
  const countTxt = document.getElementById('countTxt');

  // --- UI épurée demandée : on masque ces contrôles/badges sans supprimer la logique ---
  try{
    if(phaseTxt) phaseTxt.style.display = 'none';   // "Formule …"
    if(msg) msg.style.display = 'none';             // "Par défaut …"
    if(aro){
      const lab = aro.closest('label');
      if(lab) lab.style.display = 'none';           // case "Aromatique"
    }
    if(optA) optA.style.display = 'none';           // options aromatique
    if(optB) optB.style.display = 'none';
  }catch(e){}

  let phaseVal = 2; // 2 = semi, 3 = simplifiée (mêmes index que ton programme) fileciteturn3file1
  let aromaticStyle = 'A'; // A = Kekulé, B = cercle
  let aromaticCircleMode = false; // bouton "Aromatique (cercle)"
  let radicalMode = false; // radical aromatique
  let radicalSiteId = null; // carbone portant le point
  let radicalType = null;   // "phenyl" | "benzyl"
  let showNumbers = false;
  let baseN = 0;
  let animTimer = null;

  // --- Graph (cycle) ---
  let nextId = 0;
  let nodes = new Map();       // id -> {id, neighbors:Set}
  let lockedPos = new Map();   // id -> {x,y}
  let initialBaseIds = [];     // l'anneau (dans l'ordre)

  // liaisons multiples : uniquement pour aromatic Option A (doubles alternées)
  const bondOrders = new Map(); // key "a|b" -> 1 or 2
  function edgeKey(a,b){ return (a<b) ? (a+"|"+b) : (b+"|"+a); }
  function getBondOrder(a,b){ return bondOrders.get(edgeKey(a,b)) || 1; }
  // --- helpers for aromatic "circle" representation ---
  function isRingEdge(a,b){
    // true only for edges belonging to the original cycle (base ring)
    const ia = initialBaseIds.indexOf(a);
    const ib = initialBaseIds.indexOf(b);
    if(ia<0 || ib<0) return false;
    const n = initialBaseIds.length;
    return ((ia+1)%n===ib) || ((ib+1)%n===ia);
  }
  function getVisualBondOrder(a,b){
    // In "Formule simplifiée pour aromatique", we display the ring as all single bonds + circle,
    // even if the underlying model stores alternating double bonds.
    if(aromaticCircleMode && isRingEdge(a,b)) return 1;
    return getBondOrder(a,b);
  }

  function setBondOrder(a,b,ord){ bondOrders.set(edgeKey(a,b), ord); }

  function node(id){ return nodes.get(id); }
  function connect(a,b){ node(a).neighbors.add(b); node(b).neighbors.add(a); }

  function clampInt(v, lo, hi){
    v = Number(v);
    if(!Number.isFinite(v)) v = lo;
    v = Math.round(v);
    return Math.max(lo, Math.min(hi, v));
  }

  function resetCycle(n){
    bondOrders.clear();
    nextId = 0;
    nodes = new Map();
    lockedPos = new Map();
    initialBaseIds = [];

    for(let i=0;i<n;i++){
      const id = nextId++;
      nodes.set(id, {id, neighbors:new Set()});
      initialBaseIds.push(id);
    }
    for(let i=0;i<n;i++){
      connect(initialBaseIds[i], initialBaseIds[(i+1)%n]);
    }
    layoutRing(initialBaseIds);
  }

  function layoutRing(ringIds){
    const cx = 490, cy = 210;
    const R = 100; // scaled 2/3 so all segments are 1/3 smaller
    const n = ringIds.length;
    for(let i=0;i<n;i++){
      const ang = -Math.PI/2 + (2*Math.PI*i)/n;
      lockedPos.set(ringIds[i], {x: cx + R*Math.cos(ang), y: cy + R*Math.sin(ang)});
    }
  }

  function carbonHydrogens(id){
    let sum = 0;
    node(id).neighbors.forEach(nb => { sum += getBondOrder(id, nb); });
    let h = Math.max(0, 4 - sum);
    if(radicalMode && radicalSiteId!=null && id === radicalSiteId){
      h = Math.max(0, h - 1);
    }
    return h;
  }

  function carbonGroupText(id){
    // même convention que ton programme: "C H₂" etc fileciteturn3file0
    const h = carbonHydrogens(id);
    if(h===3) return "C H₃";
    if(h===2) return "C H₂";
    if(h===1) return "C H";
    return "C";
  }

  // --- Orientation semi-développée (CH₂ vs H₂C) ---
  function principalNeighborDir(id){
    const p = lockedPos.get(id);
    if(!p) return {x:0,y:0};
    let best = null, bestScore = -Infinity;
    node(id).neighbors.forEach(nb=>{
      const q = lockedPos.get(nb);
      if(!q) return;
      const dx = q.x - p.x, dy = q.y - p.y;
      const L = Math.hypot(dx,dy) || 1;
      // on privilégie une liaison plutôt horizontale pour décider CHx / HxC
      const score = Math.abs(dx/L);
      if(score > bestScore){
        bestScore = score;
        best = {x: dx/L, y: dy/L};
      }
    });
    return best || {x:0,y:0};
  }

  function carbonGroupTextOriented(id){
    const h = carbonHydrogens(id);
    if(h===0) return "C";
    const v = principalNeighborDir(id);
    const preferHxC = (v.x > 0); // liaison principale vers la droite => HxC
    const sub = (n)=> (n===3?'₃': n===2?'₂': n===1?'':'');
    const H = "H" + sub(h);
    return preferHxC ? (H + "C") : ("C" + H);
  }

  
  function alkylPrefix(n){
    return ["","meth","eth","prop","but","pent","hex","hept","oct","non","dec"][n] || ("C"+n);
  }
  function moleculeName(n){
    // nom affiché mis à jour dynamiquement via updateMolNameTag()
    if(aro.checked){
      return (n===6) ? "benzène" : "";
    }
    return "cyclo" + alkylPrefix(n) + "ane";
  }


  function ensureBaseRing(n){
    // Si le nombre de carbones de base change, on reconstruit tout
    if(baseN !== n){
      resetCycle(n);
      baseN = n;
      return;
    }
    // si pas initialisé
    if(baseN===0){
      resetCycle(n);
      baseN = n;
    }
  }

  function occupiedSet(){
    const s = new Set();
    for(const p of lockedPos.values()){
      s.add(Math.round(p.x)+","+Math.round(p.y));
    }
    return s;
  }
  

  function ringBondLength(){
    // Longueur C–C du cycle (distance entre deux carbones voisins du cycle).
    // Sert à donner aux substituants une liaison de même longueur que dans le cycle.
    if(initialBaseIds && initialBaseIds.length >= 2){
      const a = initialBaseIds[0], b = initialBaseIds[1];
      const pa = lockedPos.get(a), pb = lockedPos.get(b);
      if(pa && pb){
        const d = Math.hypot(pb.x - pa.x, pb.y - pa.y);
        if(d && isFinite(d)) return d;
      }
    }
    return 100; // fallback (matches scaled ring)
  }

  function placeNewCarbonRadial(carrierId, newId, offsetIndex=0){
    const p = lockedPos.get(carrierId);
    if(!p) return;

    // Placement radial (vers l'extérieur du cycle) + offsets anti-chevauchement (comportement d'avant)
    const c = ringCentroid();
    let vx = p.x - c.x, vy = p.y - c.y;
    const L = Math.hypot(vx,vy) || 1;
    vx/=L; vy/=L;

    // Rotate placement direction so branches don't overlap when there are multiple substituants.
    const OFFSETS = [0, Math.PI/3, -Math.PI/3, 2*Math.PI/3, -2*Math.PI/3, Math.PI];
    const ang = OFFSETS[Math.max(0, Math.min(OFFSETS.length-1, offsetIndex))] || 0;
    const cosA = Math.cos(ang), sinA = Math.sin(ang);
    const rvx = vx*cosA - vy*sinA;
    const rvy = vx*sinA + vy*cosA;
    vx = rvx; vy = rvy;

    const step = ringBondLength();
    const occ = occupiedSet();
    for(let k=1;k<=10;k++){
      const x = p.x + vx*step*k;
      const y = p.y + vy*step*k;
      const key = Math.round(x)+","+Math.round(y);
      if(!occ.has(key)){
        lockedPos.set(newId,{x,y});
        return;
      }
    }
    lockedPos.set(newId,{x:p.x+vx*step,y:p.y+vy*step});
  }

  function branchRoots(carrierId){
    // Substituants directement attachés au carbone du cycle (les "racines" des branches)
    const nd = node(carrierId);
    if(!nd) return [];
    const out = [];
    nd.neighbors.forEach(nb=>{
      if(!isBaseCarbon(nb)) out.push(nb);
    });
    return out;
  }

  function ringNeighborsOf(carrierId){
    const nd = node(carrierId);
    if(!nd) return [];
    const out = [];
    nd.neighbors.forEach(nb=>{
      if(isBaseCarbon(nb)) out.push(nb);
    });
    return out;
  }

  function collectSubtreeIds(rootId, parentId){
    // Collect all non-ring atoms in the substituent (root included)
    const out = new Set();
    const stack = [[rootId, parentId]];
    while(stack.length){
      const [cur, prev] = stack.pop();
      if(isBaseCarbon(cur)) continue;
      out.add(cur);
      const nd = node(cur);
      if(!nd) continue;
      nd.neighbors.forEach(nb=>{
        if(nb === prev) return;
        if(isBaseCarbon(nb)) return;
        stack.push([nb, cur]);
      });
    }
    return out;
  }

  function occupiedSetExcluding(excludeIds){
    // occupiedSet() but ignore any nodes whose id is in excludeIds (useful when repositioning)
    const occ = new Set();
    for(const [id,pos] of lockedPos.entries()){
      if(excludeIds && excludeIds.has(id)) continue;
      occ.add(Math.round(pos.x)+","+Math.round(pos.y));
    }
    return occ;
  }

  function translateSubtree(rootId, parentId, dx, dy){
    // Translate every node in the substituent subtree (root included), excluding ring atoms.
    const stack = [[rootId, parentId]];
    while(stack.length){
      const [cur, prev] = stack.pop();
      if(isBaseCarbon(cur)) continue;
      const p = lockedPos.get(cur);
      if(p) lockedPos.set(cur, {x: p.x + dx, y: p.y + dy});
      const nd = node(cur);
      if(!nd) continue;
      nd.neighbors.forEach(nb=>{
        if(nb === prev) return;
        if(isBaseCarbon(nb)) return;
        stack.push([nb, cur]);
      });
    }
  }

  function applyGeminalOppositeRingAngle(carrierId){
    // Quand il y a exactement 2 substituants sur un même carbone du cycle:
    // on veut que les deux segments des substituants forment un angle = 360/n (n = taille du cycle),
    // et qu'ils soient tous les deux "à l'extérieur" du cycle.
    //
    // Stratégie robuste:
    // - direction de base = rayon sortant (du centre du cycle vers le carbone porteur)
    // - on place les 2 substituants à baseAngle ± (π/n)
    // => l'angle entre eux vaut 2*(π/n) = 2π/n = 360/n.
    const roots = branchRoots(carrierId);
    if(roots.length !== 2) return;

    const pc = lockedPos.get(carrierId);
    if(!pc) return;

    const n = (baseN || (initialBaseIds ? initialBaseIds.length : 0) || clampInt(nC.value, 3, 10));
    const c = ringCentroid();
    const baseAngle = Math.atan2(pc.y - c.y, pc.x - c.x); // vers l'extérieur
    const delta = Math.PI / n; // = (2π/n)/2

    const a0 = baseAngle - delta;
    const a1 = baseAngle + delta;
    const d0 = {x: Math.cos(a0), y: Math.sin(a0)};
    const d1 = {x: Math.cos(a1), y: Math.sin(a1)};

    // Assigner chaque substituant à la direction la plus proche de sa direction actuelle
    const rPos0 = lockedPos.get(roots[0]);
    const rPos1 = lockedPos.get(roots[1]);
    if(!rPos0 || !rPos1) return;

    const vA = {x: rPos0.x - pc.x, y: rPos0.y - pc.y};
    const vB = {x: rPos1.x - pc.x, y: rPos1.y - pc.y};
    const nA = Math.hypot(vA.x, vA.y) || 1;
    const nB = Math.hypot(vB.x, vB.y) || 1;
    vA.x/=nA; vA.y/=nA;
    vB.x/=nB; vB.y/=nB;

    const dotA0 = vA.x*d0.x + vA.y*d0.y;
    const dotA1 = vA.x*d1.x + vA.y*d1.y;

    const assign = {};
    if(dotA0 >= dotA1){
      assign[roots[0]] = d0; assign[roots[1]] = d1;
    }else{
      assign[roots[0]] = d1; assign[roots[1]] = d0;
    }

    const step = ringBondLength();

    // Angle interne du cycle (angle au sommet d'un polygone régulier)
    // ex: n=6 -> 120°
    const thetaInt = (n-2)*Math.PI / n;
    function rot(v, ang){
      const c = Math.cos(ang), s = Math.sin(ang);
      return {x: v.x*c - v.y*s, y: v.x*s + v.y*c};
    }
    function layoutBranchZigzag(curId, parentId, incomingDir){
      // Construit la chaîne en respectant l'angle du cycle:
      // à chaque étape, l'angle au carbone courant (entre le lien vers le parent et le lien vers l'enfant)
      // est égal à l'angle interne du cycle.
      const pcurr = lockedPos.get(curId);
      if(!pcurr) return;
      const nd = node(curId);
      if(!nd) return;

      const kids = [];
      nd.neighbors.forEach(nb=>{
        if(nb === parentId) return;
        if(isBaseCarbon(nb)) return;
        kids.push(nb);
      });
      if(!kids.length) return;

      // direction vers le parent
      const toParent = {x: -incomingDir.x, y: -incomingDir.y};

      // Choisir le sens de rotation qui éloigne le plus le prochain atome du centre du cycle
      const c0 = ringCentroid();
      const candPlus = rot(toParent, +thetaInt);
      const candMinus = rot(toParent, -thetaInt);
      const testP = {x: pcurr.x + candPlus.x*step, y: pcurr.y + candPlus.y*step};
      const testM = {x: pcurr.x + candMinus.x*step, y: pcurr.y + candMinus.y*step};
      const dP = Math.hypot(testP.x - c0.x, testP.y - c0.y);
      const dM = Math.hypot(testM.x - c0.x, testM.y - c0.y);
      const outDir = (dP >= dM) ? candPlus : candMinus;

      kids.forEach((kid, idx)=>{
        // Une branche linéaire (éthyle) n'a qu'un seul enfant; s'il y en a plusieurs, on les aligne.
        const dir = (idx===0) ? outDir : incomingDir;
        lockedPos.set(kid, {x: pcurr.x + dir.x*step, y: pcurr.y + dir.y*step});
        layoutBranchZigzag(kid, curId, dir);
      });
    }

    // Repositionner les deux racines à EXACTEMENT 1 liaison du carbone porteur,
    // puis remettre leur sous-chaîne dans le même axe (évite les "cassures" après translation).
    roots.forEach(rootId=>{
      const dir = assign[rootId];
      if(!dir) return;
      lockedPos.set(rootId, {x: pc.x + dir.x*step, y: pc.y + dir.y*step});
      layoutBranchZigzag(rootId, carrierId, dir);
    });
  }

  function addCarbon(){
    const id = nextId++;
    nodes.set(id,{id, neighbors:new Set()});
    return id;
  }

  
  function existingBranchesCount(carrierId){
    // count substituents directly attached to a base-ring carbon
    let c = 0;
    const nd = node(carrierId);
    if(!nd) return 0;
    nd.neighbors.forEach(nb=>{
      if(!isBaseCarbon(nb)) c++;
    });
    return c;
  }

function canAttachAt(id){
    return carbonHydrogens(id) > 0;
  }

  function addMethyl(targetId){
    if(!isBaseCarbon(targetId)) return false;
    if(!canAttachAt(targetId)) return false;

    // UN_SEUL_SUBSTITUANT_AROMATIQUE : en aromatique (Kekulé), on limite à 1 substituant sur l'anneau
    if(isKekuleAromaticRing() && substituentsOnRing().length >= 1){
      return false;
    }
    const idx = existingBranchesCount(targetId); // how many already on this carbon
    const m = addCarbon();
    connect(targetId, m);
    placeNewCarbonRadial(targetId, m, idx);
    if(idx===1) applyGeminalOppositeRingAngle(targetId);
    return true;
  }

  function addEthyl(targetId){
    if(!isBaseCarbon(targetId)) return false;
    if(!canAttachAt(targetId)) return false;

    // UN_SEUL_SUBSTITUANT_AROMATIQUE : en aromatique (Kekulé), on limite à 1 substituant sur l'anneau
    if(isKekuleAromaticRing() && substituentsOnRing().length >= 1){
      return false;
    }
    const idx = existingBranchesCount(targetId);
    const a = addCarbon();
    const b = addCarbon();
    connect(targetId, a);
    connect(a, b);
    placeNewCarbonRadial(targetId, a, idx);
    // place b with a "cycle-like" angle: turn by ±(360/n) relative to the outgoing direction
    const pa = lockedPos.get(a);
    const pt = lockedPos.get(targetId);
    if(pa && pt){
      const dx = pa.x - pt.x, dy = pa.y - pt.y;
      const L = Math.hypot(dx,dy) || 1;
      const ux = dx/L, uy = dy/L; // direction target -> a
      // Au carbone a, on veut un angle égal à l'angle interne du cycle (ex: 120° pour n=6)
      // entre (a->target) et (a->b).
      const n = (baseN || (initialBaseIds ? initialBaseIds.length : 0) || clampInt(nC.value, 3, 10));
      const thetaInt = (n-2)*Math.PI / n;
      const step = ringBondLength();
      const c0 = ringCentroid();
      const rot = (vx,vy,ang)=>({x: vx*Math.cos(ang) - vy*Math.sin(ang), y: vx*Math.sin(ang) + vy*Math.cos(ang)});
      // toParent = direction a -> target
      const toParent = {x: -ux, y: -uy};
      const vP = rot(toParent.x,toParent.y,+thetaInt);
      const vM = rot(toParent.x,toParent.y,-thetaInt);
      const pP = {x: pa.x + vP.x*step, y: pa.y + vP.y*step};
      const pM = {x: pa.x + vM.x*step, y: pa.y + vM.y*step};
      // pick the one farther from the ring center (keeps substituent outside)
      const dP = Math.hypot(pP.x - c0.x, pP.y - c0.y);
      const dM = Math.hypot(pM.x - c0.x, pM.y - c0.y);
      const best = (dP >= dM) ? pP : pM;
      lockedPos.set(b, best);
    } else {
      placeNewCarbonRadial(a, b);
    }
    if(idx===1) applyGeminalOppositeRingAngle(targetId);
    return true;
  }

  function toggleDoubleBond(a,b){
    // pas de triple; toggle 1<->2
    const cur = getBondOrder(a,b);
    const nxt = (cur===2)?1:2;
    // vérifie valence (ne pas dépasser 4)
    const sumA = Array.from(node(a).neighbors).reduce((s,nb)=>s + (nb===b?0:getBondOrder(a,nb)),0) + nxt;
    const sumB = Array.from(node(b).neighbors).reduce((s,nb)=>s + (nb===a?0:getBondOrder(b,nb)),0) + nxt;
    if(sumA>4 || sumB>4) return false;
    setBondOrder(a,b,nxt);
    return true;
  }

  // --- SVG helpers ---
  // Parent de dessin courant (permet d'animer une rotation via un <g>)
  let DRAW_PARENT = svg;

  function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }
  function el(name, attrs={}, parent=null){
    const e = document.createElementNS("http://www.w3.org/2000/svg", name);
    for(const [k,v] of Object.entries(attrs)) e.setAttribute(k, String(v));
    (parent || DRAW_PARENT).appendChild(e);
    return e;
  }
  function textEl(x,y,txt,attrs={}){
    const t = el('text', Object.assign({x, y, 'text-anchor':'middle','dominant-baseline':'middle'}, attrs));
    t.textContent = txt;
    return t;
  }


  // --- Number badge (fond + contour), comme dans fonctions_organiques.html ---
  function drawNumberBadge(x,y,label){
    const g = el('g', {class:'numBadge'});
    const s = String(label);
    const w = 22 + Math.max(0, (s.length-1))*12;
    const h = 22;
    const rect = el('rect', {class:'numBadgeRect', x:x-w/2, y:y-h/2, width:w, height:h, rx:10, ry:10});
    const t = el('text', {class:'numBadgeText', x, y});
    t.textContent = s;
    g.appendChild(rect);
    g.appendChild(t);
    svg.appendChild(g);
    return g;
  }

  // --- padded lines (repris du programme original, adapté) fileciteturn3file16
  function linePadded(x1,y1,x2,y2,pad1,pad2,attrs={}){
    const dx = x2-x1, dy = y2-y1;
    const L = Math.hypot(dx,dy) || 1;
    const ux = dx/L, uy = dy/L;
    const ax1 = x1 + ux*pad1, ay1 = y1 + uy*pad1;
    const ax2 = x2 - ux*pad2, ay2 = y2 - uy*pad2;
    if(Math.hypot(ax2-ax1, ay2-ay1) < 2){
      return el('line', Object.assign({x1,y1,x2,y2}, attrs));
    }
    return el('line', Object.assign({x1:ax1,y1:ay1,x2:ax2,y2:ay2}, attrs));
  }
  function linePaddedMulti(x1,y1,x2,y2,padA,padB,attrs,order){
    const dx = x2-x1, dy = y2-y1;
    const L = Math.hypot(dx,dy) || 1;
    const nx = -dy / L, ny = dx / L;
    const off = 4;
    const offsets = (order===2) ? [-off, off] : [0];
    offsets.forEach(o=>{
      linePadded(x1 + nx*o, y1 + ny*o, x2 + nx*o, y2 + ny*o, padA, padB, attrs);
    });
  }

  const PAD_CC_SEMI = 22; // même valeur que ton programme fileciteturn3file16
  const PAD_CC_SIMP = 0;

  function drawBondPadded(a,b,padA,padB,klass,strokeWidth){
    const pa = lockedPos.get(a), pb = lockedPos.get(b);
    if(!pa||!pb) return;
    const order = getVisualBondOrder(a,b);
    const attrs = {class: klass, stroke:'#111', 'stroke-width': strokeWidth, 'stroke-linecap':'round'};
    if(order===1){
      linePadded(pa.x, pa.y, pb.x, pb.y, padA, padB, attrs);
    } else {
      linePaddedMulti(pa.x, pa.y, pb.x, pb.y, padA, padB, attrs, order);
    }
  }

  function moleculeCentroid(){
    let sx=0, sy=0, n=0;
    for(const p of lockedPos.values()){ sx+=p.x; sy+=p.y; n++; }
    return n ? {x:sx/n, y:sy/n} : {x:490,y:210};
  }
  function ringCentroid(){
    // centroid computed only on base ring atoms (stable for circle placement)
    let sx=0, sy=0, n=0;
    for(const id of initialBaseIds){
      const p = lockedPos.get(id);
      if(!p) continue;
      sx += p.x; sy += p.y; n++;
    }
    return n ? {x:sx/n, y:sy/n} : {x:490, y:210};
  }


  // --- Ajuste automatiquement le cadrage pour garder tous les carbones visibles ---
  function fitViewBox(){
  // Ajuste automatiquement le cadrage pour garder la molécule au plus serré,
  // tout en gardant une petite marge.
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;

  for(const p of lockedPos.values()){
    if(!p) continue;
    if(p.x < minX) minX = p.x;
    if(p.y < minY) minY = p.y;
    if(p.x > maxX) maxX = p.x;
    if(p.y > maxY) maxY = p.y;
  }

  // Si rien à cadrer, fallback
  if(!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)){
    svg.setAttribute('viewBox','0 -80 980 620');
    svg.setAttribute('preserveAspectRatio','xMidYMid meet');
    return;
  }

  // Marge : inclut le texte CHx et les points radicaux
  const PAD = 120;

  minX -= PAD; minY -= PAD;
  maxX += PAD; maxY += PAD;

  // Assurer une taille minimale (évite un zoom excessif sur des petites molécules)
  const minW = 700;
  const minH = 520;

  let w = maxX - minX;
  let h = maxY - minY;

  if(w < minW){
    const d = (minW - w)/2;
    minX -= d; maxX += d; w = minW;
  }
  if(h < minH){
    const d = (minH - h)/2;
    minY -= d; maxY += d; h = minH;
  }

  svg.setAttribute('viewBox', `${minX} ${minY} ${w} ${h}`);
  svg.setAttribute('preserveAspectRatio','xMidYMid meet');
}



    let isRotating = false;

  // --- Rotation globale (toute la molécule) ---
  function ringCentroid(){
    // Centre basé uniquement sur l'anneau (ne dépend pas des substituants)
    let sx=0, sy=0, k=0;
    for(const id of initialBaseIds){
      const p = lockedPos.get(id);
      if(!p) continue;
      sx += p.x; sy += p.y; k++;
    }
    if(k===0) return {x:490, y:210};
    return {x:sx/k, y:sy/k};
  }

  function rotateMolecule(step){
    // Rotation fluide : on anime un <g> (transform) puis on "committe" les nouvelles positions.
    // Cela évite de re-dessiner à chaque frame (plus net, plus fluide).
    if(isRotating) return;
    isRotating = true;

    const n = baseN || clampInt(nC.value, 3, 10);
    const alpha = (2*Math.PI) / n;
    const theta = step * alpha;
    const thetaDeg = theta * 180 / Math.PI;

    const c = ringCentroid();
    const g = document.getElementById('molGroup');

    // Snapshot + positions cibles
    const before = new Map();
    for(const [id,p] of lockedPos.entries()){
      if(p) before.set(id, {x:p.x, y:p.y});
    }
    const cosT = Math.cos(theta), sinT = Math.sin(theta);
    const target = new Map();
    for(const [id,p] of before.entries()){
      const x = p.x - c.x;
      const y = p.y - c.y;
      const xr = x*cosT - y*sinT;
      const yr = x*sinT + y*cosT;
      target.set(id, {x: c.x + xr, y: c.y + yr});
    }

    const dur = 380; // ms (plus doux)
    const t0 = performance.now();

    function easeInOut(u){
      return u<0.5 ? 2*u*u : 1 - Math.pow(-2*u+2,2)/2;
    }

    function done(){
      // Commit positions
      for(const [id,p1] of target.entries()){
        lockedPos.set(id, {x:p1.x, y:p1.y});
      }
      // Nettoyage transform et re-render net
      if(g) g.removeAttribute('transform');
      render();
      isRotating = false;
    }

    if(!g){
      // Fallback (au cas où) : interpolation + render par frame
      function frameFallback(t){
        const u = Math.min(1, (t - t0) / dur);
        const e = easeInOut(u);
        for(const [id,p0] of before.entries()){
          const p1 = target.get(id);
          lockedPos.set(id, {
            x: p0.x + (p1.x - p0.x)*e,
            y: p0.y + (p1.y - p0.y)*e
          });
        }
        render();
        if(u < 1) requestAnimationFrame(frameFallback);
        else { isRotating = false; }
      }
      requestAnimationFrame(frameFallback);
      return;
    }

    // Animation du groupe
    function frame(t){
      const u = Math.min(1, (t - t0) / dur);
      const e = easeInOut(u);
      const deg = thetaDeg * e;

      // Rotation autour du centre de l'anneau
      g.setAttribute('transform', `rotate(${deg} ${c.x} ${c.y})`);

      if(u < 1) requestAnimationFrame(frame);
      else done();
    }
    requestAnimationFrame(frame);
  }



  // ----------------------------
  // Numérotation IUPAC du cycle
  // - C1 est un carbone porteur d'un substituant (si possible)
  // - on choisit le sens qui minimise la somme des locants
  // - si égalité : départage par ordre alphabétique des substituants
  // ----------------------------
  function alphaKey(s){
    return (s||"").normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
  }
  function lexLess(A,B){
    const n=Math.max(A.length,B.length);
    for(let i=0;i<n;i++){
      const a=(i<A.length)?A[i]:Infinity;
      const b=(i<B.length)?B[i]:Infinity;
      if(a<b) return true;
      if(a>b) return false;
    }
    return false;
  }
  function branchSizeFrom(nei, carrier){
    const baseSet = new Set(initialBaseIds);
    const seen = new Set([carrier]);
    const q=[nei];
    let cnt=0;
    while(q.length){
      const u=q.shift();
      if(seen.has(u)) continue;
      seen.add(u);
      if(baseSet.has(u)) continue; // ne pas traverser l'anneau
      cnt++;
      const nd = node(u);
      if(!nd) continue;
      nd.neighbors.forEach(v=>{
        if(!seen.has(v) && !baseSet.has(v)) q.push(v);
      });
    }
    return cnt;
  }
  function alkylNameFromLen(len){
    // 1->méthyl, 2->éthyl, 3->propyl, ...
    const p = alkylPrefix(len);
    if(len===1) return "méthyl";
    if(len===2) return "éthyl";
    return p + "yl";
  }
  function substituentsOnRing(){
    // retourne une liste d'objets {carrierId, kind}
    const baseSet = new Set(initialBaseIds);
    const subs = [];
    for(const rid of initialBaseIds){
      const nd = node(rid);
      if(!nd) continue;
      nd.neighbors.forEach(nb=>{
        if(baseSet.has(nb)) return;
        const len = branchSizeFrom(nb, rid);
        const kind = alkylNameFromLen(len);
        subs.push({ringId: rid, carrierId: rid, kind});
      });
    }
    return subs;
  }

    function ringDoubleBonds(){
    // Retourne la liste des liaisons doubles sur l'anneau de base (ordre 2).
    const n = initialBaseIds.length;
    const out = [];
    for(let i=0;i<n;i++){
      const a = initialBaseIds[i];
      const b = initialBaseIds[(i+1)%n];
      if(getBondOrder(a,b)===2) out.push([a,b]);
    }
    return out;
  }

  function bondLocantsForCandidate(num, dblEdges){
    // Locant d'une double liaison = plus petit numéro de ses deux carbones.
    const loc = dblEdges.map(([a,b]) => Math.min(num.get(a), num.get(b)));
    loc.sort((x,y)=>x-y);
    return loc;
  }

  function lexLessArr(A,B){
    const n=Math.max(A.length,B.length);
    for(let i=0;i<n;i++){
      const a = (i<A.length)?A[i]:Infinity;
      const b = (i<B.length)?B[i]:Infinity;
      if(a<b) return true;
      if(a>b) return false;
    }
    return false;
  }

  function computeRingNumbering(){
    const n = initialBaseIds.length;
    const subs = substituentsOnRing();
    const dblEdges = ringDoubleBonds();

    // Cas simple : pas de substituant & pas d'insaturation -> 1..n (ordre actuel)
    if(subs.length===0 && dblEdges.length===0){
      const num = new Map();
      for(let i=0;i<n;i++) num.set(initialBaseIds[i], i+1);
      return {num, subs, startId: initialBaseIds[0], dir: 1, byKind:new Map(), kindsSorted:[]};
    }

    // Helper: calcule la numérotation à partir d'un index de départ + un sens (dir = +1/-1)
    function numberingFrom(startIdx, dir){
      const num = new Map();
      for(let k=0;k<n;k++){
        const idx = (startIdx + dir*k + n*1000) % n;
        num.set(initialBaseIds[idx], k+1);
      }
      return num;
    }

    function kindKey(s){ return alphaKey(s.kind); }

    function evalCandidate(startIdx, dir){
      const num = numberingFrom(startIdx, dir);

      // Règle IUPAC (cycloalcènes) : dès qu'il y a au moins une double liaison sur le cycle,
      // on DOIT numéroter en commençant par une double liaison : les deux carbones de cette double
      // liaison reçoivent alors les numéros 1 et 2 (dans un sens ou dans l'autre).
      // Donc on ne garde comme candidats QUE ceux où il existe une liaison double (a,b)
      // telle que {num(a), num(b)} = {1,2}.
      if(dblEdges.length>0){
        let ok = false;
        for(const [a,b] of dblEdges){
          const na = num.get(a), nb = num.get(b);
          if((na===1 && nb===2) || (na===2 && nb===1)) { ok = true; break; }
        }
        if(!ok) return null;
      }

      // 1) Priorité IUPAC cyclo-ènes : minimiser d'abord les locants des doubles liaisons
      const bondLoc = bondLocantsForCandidate(num, dblEdges);

      // 2) Puis minimiser la somme des locants des substituants
      const subLocs = subs.map(s => num.get(s.ringId)).slice().sort((a,b)=>a-b);
      const sum = subLocs.reduce((a,b)=>a+b,0);

      // 3) Tie-break alphabétique si égalité parfaite des locants
      //    On compare, pour chaque type de substituant (ordre alphabétique), la liste de ses locants
      const byKind = new Map();
      subs.forEach(s=>{
        const k = s.kind;
        if(!byKind.has(k)) byKind.set(k, []);
        byKind.get(k).push(num.get(s.ringId));
      });
      for(const [k, arr] of byKind.entries()) arr.sort((a,b)=>a-b);
      const kindsSorted = Array.from(byKind.keys()).sort((a,b)=>alphaKey(a).localeCompare(alphaKey(b)));
      const profile = kindsSorted.map(k => byKind.get(k).join(",")).join("|");

      return {startIdx, dir, num, bondLoc, subLocs, sum, byKind, kindsSorted, profile};
    }

    function better(A,B){
      if(!B) return true;

      // doubles liaisons d'abord (lexicographique)
      if(lexLessArr(A.bondLoc, B.bondLoc)) return true;
      if(lexLessArr(B.bondLoc, A.bondLoc)) return false;

      // ensuite somme (puis liste) des substituants
      if(A.sum !== B.sum) return A.sum < B.sum;

      // si somme égale, on minimise la liste complète des locants
      if(lexLessArr(A.subLocs, B.subLocs)) return true;
      if(lexLessArr(B.subLocs, A.subLocs)) return false;

      // enfin tie-break alphabétique
      if(A.profile !== B.profile) return A.profile < B.profile;

      return false;
    }

    // On teste TOUTES les possibilités (startIdx 0..n-1, dir ±1).
    // (n<=10 => très léger)
    let best = null;
    for(let st=0; st<n; st++){
      const c1 = evalCandidate(st, +1);
      if(c1 && better(c1, best)) best = c1;
      const c2 = evalCandidate(st, -1);
      if(c2 && better(c2, best)) best = c2;
    }

    // Si, pour une raison quelconque, aucun candidat n'a survécu à la contrainte 1-2 (cas limite),
    // on retombe sur la recherche exhaustive sans filtre.
    if(!best){
      for(let st=0; st<n; st++){
        const c1 = (function(){
          const num = numberingFrom(st, +1);
          const bondLoc = bondLocantsForCandidate(num, dblEdges);
          const subLocs = subs.map(s => num.get(s.ringId)).slice().sort((a,b)=>a-b);
          const sum = subLocs.reduce((a,b)=>a+b,0);
          const byKind = new Map();
          subs.forEach(s=>{ const k=s.kind; if(!byKind.has(k)) byKind.set(k,[]); byKind.get(k).push(num.get(s.ringId)); });
          for(const [k, arr] of byKind.entries()) arr.sort((a,b)=>a-b);
          const kindsSorted = Array.from(byKind.keys()).sort((a,b)=>alphaKey(a).localeCompare(alphaKey(b)));
          const profile = kindsSorted.map(k => byKind.get(k).join(",")).join("|");
          return {startIdx:st, dir:+1, num, bondLoc, subLocs, sum, byKind, kindsSorted, profile};
        })();
        if(better(c1, best)) best = c1;
        const c2 = (function(){
          const num = numberingFrom(st, -1);
          const bondLoc = bondLocantsForCandidate(num, dblEdges);
          const subLocs = subs.map(s => num.get(s.ringId)).slice().sort((a,b)=>a-b);
          const sum = subLocs.reduce((a,b)=>a+b,0);
          const byKind = new Map();
          subs.forEach(s=>{ const k=s.kind; if(!byKind.has(k)) byKind.set(k,[]); byKind.get(k).push(num.get(s.ringId)); });
          for(const [k, arr] of byKind.entries()) arr.sort((a,b)=>a-b);
          const kindsSorted = Array.from(byKind.keys()).sort((a,b)=>alphaKey(a).localeCompare(alphaKey(b)));
          const profile = kindsSorted.map(k => byKind.get(k).join(",")).join("|");
          return {startIdx:st, dir:-1, num, bondLoc, subLocs, sum, byKind, kindsSorted, profile};
        })();
        if(better(c2, best)) best = c2;
      }
    }

    return {
      num: best.num,
      subs,
      startId: initialBaseIds[best.startIdx],
      dir: best.dir,
      byKind: best.byKind,
      kindsSorted: best.kindsSorted,
      bondLocants: best.bondLoc,
      doubleBonds: dblEdges
    };
  }

  function formatLocants(arr){ return arr.join(","); }

  function cycloParentName(n){
    return "cyclo" + alkylPrefix(n) + "ane";
  }

    function computeIUPACName(){
    const n = initialBaseIds.length;
    const info = computeRingNumbering();
    const subs = info.subs || [];
    const dbl = info.doubleBonds || [];
    const bondLoc = info.bondLocants || [];

    // --- nom du parent (cycloalcane vs cycloalcène) ---
    function parentName(){
      if(!dbl || dbl.length===0) return cycloParentName(n);
      const base = "cyclo" + alkylPrefix(n); // ex: cyclohex
      const k = bondLoc.length;

      const mult = {1:"ène",2:"diène",3:"triène",4:"tétraène",5:"pentaène"};
      const suf = mult[k] || (k + "-ène");

      if(k<=1){
        // ex: cyclohex-1-ène
        const loc = (bondLoc[0] ?? 1);
        return `${base}-${loc}-${suf}`;
      }
      // ex: cyclohex-1,3-diène
      return `${base}-${formatLocants(bondLoc)}-${suf}`;
    }

    const parent = parentName();

    // Aucun substituant
    if(subs.length===0) return parent;

    // Cas monosubstitué :
    // - cycloalcane saturé : locant "1" implicite -> pas de "1-"
    // - cycloalcène / polyène : on garde le locant (sinon ambigu)
    if(subs.length===1){
      const s = subs[0];
      const loc = info.num.get(s.ringId);
      if((!dbl || dbl.length===0) && loc===1){
        return `${s.kind}${parent}`;
      }
      return `${loc}-${s.kind}${parent}`;
    }

    // Regrouper par type de substituant
    const byKind = new Map();
    subs.forEach(s=>{
      const loc = info.num.get(s.ringId);
      if(!byKind.has(s.kind)) byKind.set(s.kind, []);
      byKind.get(s.kind).push(loc);
    });
    for(const [k, arr] of byKind.entries()) arr.sort((a,b)=>a-b);

    const multPrefix = {2:"di",3:"tri",4:"tétra",5:"penta",6:"hexa"};
    const kinds = Array.from(byKind.keys()).sort((a,b)=>alphaKey(a).localeCompare(alphaKey(b)));

    const parts = kinds.map(kind=>{
      const locs = byKind.get(kind);
      const mult = (locs.length>1) ? (multPrefix[locs.length] || (locs.length+"-")) : "";
      const subName = (locs.length>1) ? (mult + kind) : kind;
      return `${formatLocants(locs)}-${subName}`;
    });

    return parts.join("-") + parent;
  }


  // --- Équivalences aromatiques (noms usuels) ---
  
  // --- Équivalences aromatiques (noms usuels) ---
  function isBenzeneSkeleton(){
    // aromatique Kekulé + cycle à 6 carbones avec alternance
    return isKekuleAromaticRing() && (initialBaseIds.length === 6);
  }

  function methylLocantsOnRing(){
    // Retourne les locants (IUPAC) des substituants "méthyl" sur l'anneau
    const info = computeRingNumbering();
    const arr = (info && info.byKind && info.byKind.get('méthyl')) ? info.byKind.get('méthyl').slice() : [];
    arr.sort((a,b)=>a-b);
    return arr;
  }

  function ethylLocantsOnRing(){
    const info = computeRingNumbering();
    const arr = (info && info.byKind && info.byKind.get('éthyl')) ? info.byKind.get('éthyl').slice() : [];
    arr.sort((a,b)=>a-b);
    return arr;
  }

  function benzeneEquivalentName(nm){
    // cyclohex-1,3,5-triène sans substituant = benzène
    if(!isBenzeneSkeleton()) return false;
    const mloc = methylLocantsOnRing();
    return (mloc.length === 0) && (nm === "cyclohex-1,3,5-triène");
  }

  function ethylbenzeneEquivalentName(nm){
    if(!isBenzeneSkeleton()) return false;
    const eloc = ethylLocantsOnRing();
    return (eloc.length === 1) && (/éthylcyclohex-1,3,5-triène$/.test(nm));
  }

  function tolueneEquivalentName(nm){

    // Un seul méthyl sur le squelette benzène = toluène
    if(!isBenzeneSkeleton()) return false;
    const mloc = methylLocantsOnRing();
    return (mloc.length === 1) && (/méthylcyclohex-1,3,5-triène$/.test(nm));
  }

  function methylTolueneNameIfAny(){
    // Si on a exactement 2 méthyls sur le squelette benzène:
    // on affiche "x-méthyltoluène" (o/m/p selon x=2/3/4).
    if(!isBenzeneSkeleton()) return null;
    const mloc = methylLocantsOnRing();
    if(mloc.length !== 2) return null;

    // Normalement la numérotation place un méthyl en 1; sinon on renumérote localement.
    let other = null;
    if(mloc.includes(1)){
      other = mloc.find(v=>v!==1) || null;
    } else {
      const ref = mloc[0];
      const rawOther = mloc[1];
      // conversion modulo 6 vers une numérotation où ref devient 1
      other = ((rawOther - ref + 6) % 6) + 1;
    }
    if(other==null) return null;
    return `${other}-méthyltoluène`;
  }

  function canRadicalNow(){
    const nm = computeIUPACName();
    // On autorise le bouton Radical seulement sur benzène OU toluène (mono-méthyl)
    return isBenzeneSkeleton() && (benzeneEquivalentName(nm) || tolueneEquivalentName(nm));
  }

  function findBenzylicCarbonId(){
    // Cherche le carbone directement attaché à l'anneau (substituant méthyl)
    for(const rid of initialBaseIds){
      const nd = node(rid);
      if(!nd) continue;
      for(const nb of nd.neighbors){
        if(!isBaseCarbon(nb)) return nb;
      }
    }
    return null;
  }

  function drawRadicalDot(){
    if(!radicalMode || radicalSiteId==null) return;
    const p = lockedPos.get(radicalSiteId);
    if(!p) return;

    let x = p.x, y = p.y;

    if(radicalType === "phenyl"){
      // point placé à l'extérieur de l'anneau
      const c = ringCentroid();
      let vx = p.x - c.x, vy = p.y - c.y;
      const L = Math.hypot(vx,vy) || 1;
      vx/=L; vy/=L;
      x = p.x + vx*22;
      y = p.y + vy*22;
    } else if(radicalType === "benzyl"){
      // point dans l'axe du lien anneau -> carbone benzylique
      const nd = node(radicalSiteId);
      let baseNeighbor = null;
      if(nd){
        nd.neighbors.forEach(nb=>{ if(isBaseCarbon(nb)) baseNeighbor = nb; });
      }
      if(baseNeighbor!=null){
        const pb = lockedPos.get(baseNeighbor);
        if(pb){
          let vx = p.x - pb.x, vy = p.y - pb.y;
          const L = Math.hypot(vx,vy) || 1;
          vx/=L; vy/=L;
          x = p.x + vx*22;
          y = p.y + vy*22;
        }
      }
    }

    el('circle', {cx:x, cy:y, r:6.2, fill:'#111'});
  }


  function updateMolNameTag(){
    const tag = document.getElementById('molName');
    if(!tag) return;

    const nm = computeIUPACName();

    // Bouton Radical : visible seulement pour benzène/toluène en aromaticité Kekulé
    if(radicalBtn){
      const ok = canRadicalNow();
      radicalBtn.style.display = ok ? 'inline-block' : 'none';
      radicalBtn.setAttribute('aria-pressed', radicalMode ? 'true' : 'false');
      if(!ok && radicalMode){
        radicalMode = false;
        radicalSiteId = null;
        radicalType = null;
      }
    }

    // Mode radical : afficher uniquement le nom du radical
    if(radicalMode && nm === "cyclohex-1,3,5-triène"){
      tag.innerHTML = `<span style="color:#0b4cb3;font-weight:900;">phényle</span>`;
    }
    else if(radicalMode && nm === "1-méthylcyclohex-1,3,5-triène"){
      tag.innerHTML = `<span style="color:#0b4cb3;font-weight:900;">benzyle</span>`;
    }

    // Équivalences usuelles (rouge)
    else if(nm === "cyclohex-1,3,5-triène"){
      tag.innerHTML = `${nm}<span style="color:#c41313;font-weight:900;margin-left:6px;">= benzène</span>`;
    }
    else if(nm === "1-méthylcyclohex-1,3,5-triène"){
      tag.innerHTML = `${nm}<span style="color:#c41313;font-weight:900;margin-left:6px;">= toluène</span><span style="color:#c41313;font-weight:900;margin-left:6px;">= méthylbenzène</span>`;
    }
    else if(nm === "1-éthylcyclohex-1,3,5-triène"){
      tag.innerHTML = `${nm}<span style="color:#c41313;font-weight:900;margin-left:6px;">= éthylbenzène</span>`;
    }
    else{
      tag.textContent = nm;
    }

    tag.style.display = nm ? 'inline-block' : 'none';
  }

  function drawRingNumbers(){
    if(!showNumbers) return;
    const info = computeRingNumbering();
    const c = moleculeCentroid();
    for(const id of initialBaseIds){
      const p = lockedPos.get(id);
      if(!p) continue;
      let vx = p.x - c.x, vy = p.y - c.y;
      const L = Math.hypot(vx,vy) || 1;
      vx/=L; vy/=L;
      const x = p.x + vx*28;
      const y = p.y + vy*28;
      const num = info.num.get(id);
      drawNumberBadge(x, y, String(num));
    }
  }


function updateAromaticBondsIfNeeded(){
    if(!aro.checked) return;
    // En aromatique, on impose les ordres de liaison sur l'anneau uniquement.
    // On remet à zéro les ordres puis on fixe ceux du cycle.
    bondOrders.clear();
    if(phaseVal===2){
      // en semi : on force Kekulé pour que CH soit cohérent (comme sur ton outil “semi”) fileciteturn3file0
      for(let i=0;i<initialBaseIds.length;i++){
        const a = initialBaseIds[i];
        const b = initialBaseIds[(i+1)%initialBaseIds.length];
        setBondOrder(a,b, (i%2===0)?2:1);
      }
      return;
    }
    // simplifiée : A = Kekulé, B = cercle (liaisons simples)
    if(aromaticStyle==='A'){
      for(let i=0;i<initialBaseIds.length;i++){
        const a = initialBaseIds[i];
        const b = initialBaseIds[(i+1)%initialBaseIds.length];
        setBondOrder(a,b, (i%2===0)?2:1);
      }
    } else {
      // tout simple (on garde bondOrders vide -> 1)
    }
  }

  
  // --- Détection d'aromaticité (Kekulé) : cycle pair + alternance simple/double ---
  function isKekuleAromaticRing(){
    const n = initialBaseIds.length;
    if(n < 4) return false;
    if(n % 2 !== 0) return false;

    const orders = [];
    for(let i=0;i<n;i++){
      const a = initialBaseIds[i];
      const b = initialBaseIds[(i+1)%n];
      const o = getBondOrder(a,b);
      if(!(o===1 || o===2)) return false;
      orders.push(o);
    }
    // alternance stricte (1/2/1/2...) y compris entre dernier et premier
    for(let i=0;i<n;i++){
      if(orders[i] === orders[(i+1)%n]) return false;
    }
    const doubles = orders.filter(o=>o===2).length;
    return doubles === n/2;
  }

  function updateAromaticAlert(){
    if(!aromaticAlert) return;
    const on = isKekuleAromaticRing();
    aromaticAlert.style.display = on ? 'inline-block' : 'none';

    // Badge : Aromatique (rouge) vs Radical aromatique (bleu)
    if(on && radicalMode && canRadicalNow()){
      aromaticAlert.textContent = '● Radical aromatique';
      aromaticAlert.style.borderColor = 'rgba(20,80,200,.45)';
      aromaticAlert.style.background = 'rgba(20,80,200,.10)';
      aromaticAlert.style.color = '#0b4cb3';
      aromaticAlert.style.fontWeight = '900';
    } else {
      aromaticAlert.textContent = '⚠ Aromatique';
      aromaticAlert.style.borderColor = '';
      aromaticAlert.style.background = '';
      aromaticAlert.style.color = '';
      aromaticAlert.style.fontWeight = '';
    }

    // Option "Formule simplifiée pour aromatique" (cercle) : visible seulement quand l'anneau est kekulé aromatique
    if(repAroSimp){
      repAroSimp.style.display = on ? 'inline-flex' : 'none';
      // si on perd l'aromaticité (plus d'alternance), on quitte le mode cercle et on revient à "Formule simplifiée"
      if(!on && aromaticCircleMode){
        aromaticCircleMode = false;
        // activer le bouton simplifiée (data-i="3")
        const simp = document.querySelector('.tickBtn[data-i="3"]');
        if(simp){
          document.querySelectorAll('.tickBtn').forEach(b=>{
            const active = (b===simp);
            b.classList.toggle('active', active);
            b.setAttribute('aria-checked', active ? 'true':'false');
          });
        }
      }
      // si on est en mode cercle alors que l'option n'est pas dispo (sécurité)
      if(!on) repAroSimp.setAttribute('aria-checked','false');
    }
  }
function validateUI(){
    const n = clampInt(nC.value, 3, 10);
    if(String(n) !== String(nC.value)) nC.value = n;
    countTxt.textContent = "Carbones : " + n;
    const nm = moleculeName(n);
    const tag = document.getElementById('molName');
    tag.textContent = nm;
    tag.style.display = nm ? 'inline-block' : 'none';

    // règle aromatique demandée : n doit être pair
    if(aro.checked && (n%2!==0)){
      nC.classList.add('bad');
      msg.textContent = "Aromatique impossible : nombre de carbones pair requis.";
      aro.checked = false;
    } else {
      nC.classList.remove('bad');
      msg.textContent = aro.checked ? "Mode aromatique activé." : "Par défaut : cycloalcane.";
    }

    // Option A/B uniquement en simplifiée + aromatique
    const enableAB = (phaseVal===3 && aro.checked);
    optA.disabled = !enableAB;
    optB.disabled = !enableAB;

    // Chips double liaison : désactivée en aromatique (comme le bouton)
    const bondChip = document.querySelector('.chips .bondChip');
    if(bondChip){
      const dis = aro.checked;
      bondChip.classList.toggle('disabled', dis);
      bondChip.setAttribute('draggable', dis ? 'false' : 'true');
      bondChip.setAttribute('aria-disabled', dis ? 'true' : 'false');
    }

    if(!enableAB){
      optA.setAttribute('aria-pressed', aromaticStyle==='A'?'true':'false');
      optB.setAttribute('aria-pressed', aromaticStyle==='B'?'true':'false');
    }

    phaseTxt.textContent = (phaseVal===2) ? "Formule semi‑développée" : "Formule simplifiée";
    return n;
  }


  function addHotAtom(id){
    const p = lockedPos.get(id);
    if(!p) return;
    const c = el('circle', {cx:p.x, cy:p.y, r:22, class:'hotAtom'});
    c.addEventListener('click', (ev)=>{ ev.stopPropagation(); });
    c.addEventListener('pointerdown', (ev)=>{
      
      ev.preventDefault();
      ev.stopPropagation();
      startDrag(id, ev);
    });


  }

  function addHotBond(a,b){
    const pa = lockedPos.get(a), pb = lockedPos.get(b);
    if(!pa||!pb) return;
    const l = el('line', {x1:pa.x,y1:pa.y,x2:pb.x,y2:pb.y, class:'hotBond'});
    l.addEventListener('click', (ev)=>{ ev.stopPropagation(); });
  }

  function render(){
    const n = validateUI();
    ensureBaseRing(n);
    updateAromaticBondsIfNeeded();
    updateAromaticAlert();

    updateMolNameTag();

    clearSVG();
    // Cadrage fixe (serré) : évite l'effet "zoom" pendant la rotation
    svg.setAttribute('viewBox','0 -60 980 700');
    svg.setAttribute('preserveAspectRatio','xMidYMid meet');

    // Groupe racine de la molécule (utile pour une rotation fluide sans re-dessiner)
    const molGroup = el('g', {id:'molGroup'}, svg);
    DRAW_PARENT = molGroup;

    // --- SEMI ---
    if(phaseVal===2){
      // 1) mesurer les labels (pour que les liaisons viennent "toucher" le texte)
      const labelPads = new Map(); // id -> padding px
      const tempTexts = [];
      for(const [id] of nodes.entries()){
        const p = lockedPos.get(id);
        const t = textEl(p.x, p.y, carbonGroupTextOriented(id), {
          'font-size':22,'font-weight':800, fill:'#111', opacity:0
        });
        tempTexts.push(t);
        const bb = t.getBBox();
        const pad = Math.max(bb.width, bb.height) * 0.55 + 2; // ajuste 0.50–0.65 si besoin
        labelPads.set(id, pad);
      }
      tempTexts.forEach(t => t.remove());

      // 2) liaisons C–C avec padding par extrémité
      for(const [id, nd] of nodes.entries()){
        for(const nb of nd.neighbors){
          if(id>nb) continue;
          const padA = labelPads.get(id) ?? PAD_CC_SEMI;
          const padB = labelPads.get(nb) ?? PAD_CC_SEMI;
          drawBondPadded(id, nb, padA, padB, 'semiBond', 2.4);
        }
      }

      // hotspots bonds (pour doubles)
      for(const [id, nd] of nodes.entries()){
        for(const nb of nd.neighbors){
          if(id>nb) continue;
          addHotBond(id, nb);
        }
      }

      // 3) labels (CH₂ / H₂C auto)
      for(const [id] of nodes.entries()){
        const p = lockedPos.get(id);
        textEl(p.x, p.y, carbonGroupTextOriented(id), {'font-size':22,'font-weight':800, fill:'#111'});
      }

      // hotspots atoms (pour ajouter des radicaux)
      for(const [id] of nodes.entries()){
        addHotAtom(id);
      }

      drawRingNumbers();
      drawRadicalDot();
      return;
    }

    // --- SIMPLIFIÉE ---
    // skeleton polygon
    for(const [id, nd] of nodes.entries()){
      for(const nb of nd.neighbors){
        if(id>nb) continue;
        drawBondPadded(id, nb, PAD_CC_SIMP, PAD_CC_SIMP, 'skeletal', 3.2);
      }
    }

    // hotspots bonds
    for(const [id, nd] of nodes.entries()){
      for(const nb of nd.neighbors){
        if(id>nb) continue;
        addHotBond(id, nb);
      }
    }
    // hotspots atoms
    for(const [id] of nodes.entries()){
      addHotAtom(id);
    }

    drawRingNumbers();

    drawRadicalDot();

    // cercle aromatique si option B / mode cercle
    // IMPORTANT : le cercle doit être centré sur l'anneau (pas sur le barycentre de toute la molécule),
    // sinon les substituants décalent le centre et "ça bave".
    if((aro && aro.checked && aromaticStyle==='B') || aromaticCircleMode){
      const c = ringCentroid();

      // Rayon de l'anneau estimé (distance centre -> un carbone de l'anneau)
      const p0 = lockedPos.get(initialBaseIds[0]);
      let R = 100;
      if(p0){
        const d = Math.hypot(p0.x - c.x, p0.y - c.y);
        if(d && isFinite(d)) R = d;
      }

      // Cercle aromatique : un peu plus petit que l'anneau
      const r = Math.max(30, R * 0.72);

      el('circle', {cx:c.x, cy:c.y, r:r, class:'skeletal', 'stroke-width':2.8});
    }
      
    // Reset du parent de dessin
    DRAW_PARENT = svg;
}

  function renderAnimated(){
    svg.classList.add('switching');
    if(animTimer) clearTimeout(animTimer);
    animTimer = setTimeout(()=>{
      render();
      requestAnimationFrame(()=> svg.classList.remove('switching'));
    }, 160);
  }

  
  // Bouton "Aromatique (cercle)" : disponible uniquement quand l'alerte aromatique est active
  if(aroCircleBtn){
    aroCircleBtn.addEventListener('click', ()=>{
      aromaticCircleMode = !aromaticCircleMode;
      aroCircleBtn.setAttribute('aria-pressed', aromaticCircleMode ? 'true' : 'false');

      if(aromaticCircleMode){
        // Force la formule simplifiée et le cercle aromatique (liaisons simples + cercle)
        phaseVal = 3;
        aro.checked = true;
        aromaticStyle = 'B';
      } else {
        // On revient au comportement "normal" (sans cercle imposé)
        aro.checked = false;
        aromaticStyle = 'A';
      }
      validateUI();
      renderAnimated();
    });
  }


  // Bouton Radical : phényle / benzyle (uniquement benzène/toluène)
  if(radicalBtn){
    radicalBtn.addEventListener('click', ()=>{
      if(!canRadicalNow()){
        radicalBtn.classList.add('shake');
        setTimeout(()=>radicalBtn.classList.remove('shake'), 260);
        return;
      }
      radicalMode = !radicalMode;

      if(radicalMode){
        const nm = computeIUPACName();
        if(benzeneEquivalentName(nm)){
          radicalType = "phenyl";
          radicalSiteId = initialBaseIds[0] ?? null; // un H quelconque sur l'anneau
        } else if(tolueneEquivalentName(nm)){
          radicalType = "benzyl";
          radicalSiteId = findBenzylicCarbonId();    // CH3 -> CH2•
          if(radicalSiteId==null){
            radicalMode = false;
            radicalType = null;
          }
        }
      } else {
        radicalSiteId = null;
        radicalType = null;
      }

      radicalBtn.setAttribute('aria-pressed', radicalMode ? 'true' : 'false');
      renderAnimated();
    });
  }

  // Numérotation du cycle
  if(toggleNums){
    toggleNums.addEventListener('click', ()=>{
      showNumbers = !showNumbers;
      toggleNums.setAttribute('aria-pressed', showNumbers ? 'true':'false');
      renderAnimated();
    });

    // Rotation : + (horaire) / − (anti-horaire)
    if(rotPlus) rotPlus.addEventListener('click', ()=> rotateMolecule(+1));
    if(rotMinus) rotMinus.addEventListener('click', ()=> rotateMolecule(-1));
  }

  
    // Reset complet (recommencer depuis le début)
    function resetSimulation(){
      const n0 = 6;
      nC.value = n0;

      // Revenir à la représentation par défaut : semi‑développée
      phaseVal = 2;
      document.querySelectorAll('.tickBtn[role="radio"]').forEach(b=>{
        const i = parseInt(b.dataset.i,10);
        const active = (i===phaseVal);
        b.classList.toggle('active', active);
        b.setAttribute('aria-checked', active ? 'true' : 'false');
      });

      // Outils / options
      showNumbers = false;
      if(toggleNums) toggleNums.setAttribute('aria-pressed','false');
      toolMode = 'none';
      try{ setTool('none'); }catch(e){}

      // On garde le code aromatique en arrière-plan mais on remet à zéro l'état
      try{ aro.checked = false; }catch(e){}
      aromaticStyle = 'A';

      // Reset du graphe
      resetCycle(n0);
      baseN = n0;

      renderAnimated();
    }
    if(resetSim) resetSim.addEventListener('click', resetSimulation);


  // --- Drag & drop (comme dans l'outil d'origine) ---
  let draggingId = null;
  let dragOffset = {x:0,y:0};

  function svgPointFromEvent(ev){
    const pt = svg.createSVGPoint();
    pt.x = ev.clientX;
    pt.y = ev.clientY;
    const ctm = svg.getScreenCTM();
    if(!ctm) return {x:0,y:0};
    const sp = pt.matrixTransform(ctm.inverse());
    return {x: sp.x, y: sp.y};
  }

  function startDrag(id, ev){
    draggingId = id;
    const p = lockedPos.get(id);
    const m = svgPointFromEvent(ev);
    dragOffset = {x: (p?.x||0) - m.x, y: (p?.y||0) - m.y};
    svg.setPointerCapture?.(ev.pointerId);
  }

  function moveDrag(ev){
    if(draggingId==null) return;
    const m = svgPointFromEvent(ev);
    lockedPos.set(draggingId, {x: m.x + dragOffset.x, y: m.y + dragOffset.y});
    // rendu direct sans animation (plus fluide)
    render();
  }

  function endDrag(ev){
    if(draggingId==null) return;
    draggingId = null;
    try{ svg.releasePointerCapture?.(ev.pointerId); }catch(_){}
  }

  svg.addEventListener('pointermove', moveDrag);
  svg.addEventListener('pointerup', endDrag);
  svg.addEventListener('pointercancel', endDrag);

  
  /* =========================================================
     Drag & Drop (chips) : méthyl / éthyl / double liaison
     - drop sur le SVG -> atome ou liaison la plus proche
     - double liaison interdite en aromatique (comme le bouton)
     ========================================================= */
  let dragSub = null;   // "méthyl" | "éthyl"
  let dragBond = null;  // 2

  let hoverRing = null;
  let hoverBond = null;

  function clearHover(){
    if(hoverRing){ hoverRing.remove(); hoverRing=null; }
    if(hoverBond){ hoverBond.remove(); hoverBond=null; }
  }

  function showHoverAtom(id){
    const p = lockedPos.get(id);
    if(!p) return;
    const c = el('circle', {cx:p.x, cy:p.y, r:20, class:'hoverRing', fill:'none',
      stroke:'rgba(60,120,255,0.65)', 'stroke-width':4});
    hoverRing = c;
  }

  function showHoverBond(a,b){
    const pa = lockedPos.get(a), pb = lockedPos.get(b);
    if(!pa||!pb) return;
    const l = el('line', {x1:pa.x,y1:pa.y,x2:pb.x,y2:pb.y, class:'hoverRing',
      stroke:'rgba(60,120,255,0.65)', 'stroke-width':10, 'stroke-linecap':'round'});
    hoverBond = l;
  }

  function nearestCarbon(x,y){
    let best=null, d2=Infinity;
    for(const [id,p] of lockedPos.entries()){
      const dx=p.x-x, dy=p.y-y;
      const dd=dx*dx+dy*dy;
      if(dd<d2){ d2=dd; best=id; }
    }
    return {id:best, d2};
  }


  function isBaseCarbon(id){
    return initialBaseIds.includes(id);
  }

  function nearestBaseCarbon(x,y){
    let best=null, d2=Infinity;
    for(const id of initialBaseIds){
      const p = lockedPos.get(id);
      if(!p) continue;
      const dx=p.x-x, dy=p.y-y;
      const dd=dx*dx+dy*dy;
      if(dd<d2){ d2=dd; best=id; }
    }
    return {id:best, d2};
  }


  function nearestBond(x,y){
    let bestA=null, bestB=null, d2=Infinity;
    for(const [id, nd] of nodes.entries()){
      for(const nb of nd.neighbors){
        if(id>nb) continue;
        const pa = lockedPos.get(id), pb = lockedPos.get(nb);
        if(!pa||!pb) continue;
        // distance point-segment squared
        const ax=pa.x, ay=pa.y, bx=pb.x, by=pb.y;
        const vx=bx-ax, vy=by-ay;
        const wx=x-ax, wy=y-ay;
        const L2=vx*vx+vy*vy || 1;
        let t = (wx*vx+wy*vy)/L2;
        t = Math.max(0, Math.min(1, t));
        const px = ax + t*vx, py = ay + t*vy;
        const dx = x-px, dy = y-py;
        const dd = dx*dx+dy*dy;
        if(dd<d2){ d2=dd; bestA=id; bestB=nb; }
      }
    }
    return {a:bestA, b:bestB, d2};
  }

  // drag events
  svg.addEventListener('dragover', (e)=>{
    e.preventDefault();
    if(e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
    const {x,y} = svgPointFromEvent(e);
    clearHover();

    if(dragBond){
      const bb = nearestBond(x,y);
      if(bb.a!=null && bb.d2 < (22*22)) showHoverBond(bb.a, bb.b);
      return;
    }

    const nc = dragSub ? nearestBaseCarbon(x,y) : nearestCarbon(x,y);
    if(dragSub && nc.id!=null && nc.d2 < (140*140)) showHoverAtom(nc.id);
  });

  svg.addEventListener('dragleave', ()=>{ clearHover(); });

  svg.addEventListener('drop', (e)=>{
    e.preventDefault();
    const {x,y} = svgPointFromEvent(e);
    clearHover();

    // double liaison : drop sur une liaison
    if(dragBond){
      if(aro.checked) return; // cohérent avec le blocage en aromatique
      const bb = nearestBond(x,y);
      if(bb.a!=null && bb.d2 < (22*22)){
        if(toggleDoubleBond(bb.a, bb.b)) renderAnimated();
      }
      return;
    }

    // substituants : drop sur un carbone (semi ou simplifiée)
    if(!dragSub) return;
    const nc = nearestBaseCarbon(x,y);
    if(nc.id==null || nc.d2 > (140*140)) return;

    let ok=false;
    if(dragSub==='méthyl') ok = addMethyl(nc.id);
    if(dragSub==='éthyl') ok = addEthyl(nc.id);
    if(ok) renderAnimated();
  });

  // chips dragstart/dragend
  document.querySelectorAll('.chips .chip[draggable="true"]').forEach(ch=>{
    ch.addEventListener('dragstart', (e)=>{
      dragSub = ch.getAttribute('data-dragSub') || ch.dataset.dragSub || null;
      dragBond = ch.dataset.bond ? parseInt(ch.dataset.bond,10) : null;
      if(e.dataTransfer){
        e.dataTransfer.setData('text/plain', dragSub || '');
        e.dataTransfer.effectAllowed = 'copy';
      }
    });
    ch.addEventListener('dragend', ()=>{ dragSub=null; dragBond=null; clearHover(); });
  });


// --- UI wiring ---
  document.querySelectorAll('.tickBtn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const i = parseInt(btn.dataset.i,10);

      // 2 = semi-développée
      // 3 = simplifiée (Kekulé)
      // 4 = simplifiée pour aromatique (cercle)
      if(i===2){
        phaseVal = 2;
        aromaticCircleMode = false;
      } else if(i===3){
        phaseVal = 3;
        aromaticCircleMode = false; // Kekulé (doubles visibles)
      } else if(i===4){
        phaseVal = 3;              // c'est toujours la formule simplifiée
        aromaticCircleMode = true; // mais avec cercle
      } else {
        phaseVal = 2;
        aromaticCircleMode = false;
      }

      // update UI state
      document.querySelectorAll('.tickBtn').forEach(b=>{
        const active = (b===btn);
        b.classList.toggle('active', active);
        b.setAttribute('aria-checked', active ? 'true':'false');
      });

      renderAnimated();
    });
  });

  optA.addEventListener('click', ()=>{
    if(optA.disabled) { optA.classList.remove('shake'); void optA.offsetWidth; optA.classList.add('shake'); return; }
    aromaticStyle = 'A';
    optA.setAttribute('aria-pressed','true');
    optB.setAttribute('aria-pressed','false');
    renderAnimated();
  });
  optB.addEventListener('click', ()=>{
    if(optB.disabled) { optB.classList.remove('shake'); void optB.offsetWidth; optB.classList.add('shake'); return; }
    aromaticStyle = 'B';
    optA.setAttribute('aria-pressed','false');
    optB.setAttribute('aria-pressed','true');
    renderAnimated();
  });

  nC.addEventListener('input', renderAnimated);
  aro.addEventListener('change', renderAnimated);

  // start
  render();
})();
</script>

<div id="versionLabel" style="
  position:fixed;
  bottom:16px;
  right:16px;
  background:#ffffff;
  border:2px solid #d0d0d0;
  border-radius:14px;
  padding:10px 14px;
  font-family:system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  font-size:16px;
  line-height:1.25;
  text-align:center;
  box-shadow:0 6px 18px rgba(0,0,0,0.12);
">
  <div style="font-weight:700;">Version 1.8</div>
  <div style="font-weight:600;">ECG Henry‑Dunant</div>
  <div style="font-weight:600;">S. Ulrich</div>
</div>

</body>
</html>