<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Simulation de titrage – sigmoïde</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
    }
    h1 {
      font-size: 1.4rem;
      margin-bottom: 10px;
      text-align: center;
    }
    #container {
      background: white;
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      position: relative;
    }
    #controls {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      border: none;
      padding: 8px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    }
    button#goutte {
      background: #2563eb;
      color: white;
    }
    button#reset {
      background: #e5e7eb;
    }
    #info {
      margin-top: 10px;
      font-size: 0.9rem;
    }
    #info span {
      font-weight: 600;
    }

    #panelIons {
      position: absolute;
      top: 80px;
      right: 20px;
      background: rgba(255,255,255,0.95);
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      padding: 8px 10px;
      font-size: 0.8rem;
      max-width: 260px;
    }
    #panelIons label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-weight: 600;
      margin-bottom: 4px;
    }
    #ionsCounts {
      margin-left: 4px;
      line-height: 1.4;
      margin-bottom: 6px;
    }
    #phTable {
      margin-top: 4px;
      border-top: 1px solid #e5e7eb;
      padding-top: 4px;
      font-family: "SF Mono","Consolas","Courier New",monospace;
      font-size: 0.7rem;
      white-space: pre;
    }
    #phTableTitle {
      font-weight: 600;
      margin-bottom: 2px;
    }
    #modeChoice span {
      font-weight: 700;
      display: block;
      margin-bottom: 2px;
    }

    /* Mini-graphique à gauche, aligné verticalement à la burette */
    #miniGraph {
      position: absolute;
      left: -180px;   /* ← décalé vers la droite par rapport à -240px */
      top: 80px;
      border: 1px solid #ddd;
      background: #ffffff;
    }
  
    .version-box {
      position: fixed;
      top: 10px;
      right: 10px;
      border: 1px solid #fff;
      padding: 4px 6px;
      font-size: 8px;
      line-height: 1.2;
      background: rgba(0,0,0,0.4);
      border-radius: 4px;
      text-align: center;
      color:#fff;
      z-index: 999;
    }

  </style>
<style>
/* Added by script: small top-left home button */
.home-btn{
  position:fixed;
  top:8px;
  left:8px;
  width:22px;
  height:22px;
  display:flex;
  align-items:center;
  justify-content:center;
  text-decoration:none;
  font-size:14px;
  line-height:1;
  border-radius:6px;
  background:rgba(255,255,255,0.8);
  color:#111;
  border:1px solid rgba(0,0,0,0.25);
  box-shadow:0 1px 3px rgba(0,0,0,0.15);
  z-index:2147483647;
}
.home-btn:hover{ background:rgba(255,255,255,0.95); }
.home-btn:active{ transform:translateY(1px); }
@media (prefers-color-scheme: dark){
  .home-btn{
    background:rgba(30,30,30,0.75);
    color:#f5f5f5;
    border:1px solid rgba(255,255,255,0.25);
  }
}

</style>
</head>
<body>
<a href="https://7cmfcn8mqw-rgb.github.io/dossierulrich/" class="home-btn" aria-label="Retour au menu principal" title="Menu">⟵</a>

  <h1>Dosage acide/base</h1>

  <div id="container">
    <!-- BADGE EN HAUT À GAUCHE -->
    <div class="version-box">
  Version 3.1<br>
  S. Ulrich — ECG Henry-Dunant
</div>

    <canvas id="titrationCanvas" width="800" height="480"></canvas>

    <!-- Mini-graphique pH = f(V ajouté) à gauche du container -->
    <canvas id="miniGraph" width="220" height="120"></canvas>

    <div id="panelIons">
      <div id="modeChoice">
        <span>Type de dosage :</span>
        <label>
          <input type="radio" name="modeDosage" id="modeAcid" value="acid" checked />
          Doser un acide par une base
        </label>
        <label>
          <input type="radio" name="modeDosage" id="modeBase" value="base" />
          Doser une base par un acide
        </label>
      </div>

      <hr style="margin:6px 0;border:none;border-top:1px solid #e5e7eb;" />

      <label>
        <input type="checkbox" id="toggleIons" />
        Afficher H⁺ / OH⁻
      </label>
      <label>
        <input type="checkbox" id="toggleIndicatorColor" />
        Indicateurs colorés (BBT)
      </label>
      <div id="ionsCounts">
        H⁺ dans l'erlen : <span id="countH">0</span><br />
        OH⁻ dans l'erlen : <span id="countOH">0</span>
      </div>

      <label>
        <input type="checkbox" id="togglePhNumber" />
        Afficher pH
      </label>
      <label>
        <input type="checkbox" id="togglePhTable" />
        Afficher tableau V–pH
      </label>

      <div id="phTable">
        <div id="phTableTitle">Table V–pH (entiers)</div>
        <pre id="phTableContent"></pre>
      </div>
    </div>

    <div id="controls">
      <button id="goutte">Ajouter une goutte</button>
      <button id="reset">Réinitialiser</button>
    </div>
    <div id="info">
      Volume ajouté : <span id="volT">0.0</span> mL<br />
      pH : <span id="phValue">—</span><br />
    </div>
  </div>

  <script>
    const canvas = document.getElementById("titrationCanvas");
    const ctx = canvas.getContext("2d");

    const volTSpan = document.getElementById("volT");
    const phSpanEl = document.getElementById("phValue");

    const goutteBtn = document.getElementById("goutte");
    const resetBtn = document.getElementById("reset");

    const toggleIons = document.getElementById("toggleIons");
    const ionsCountsDiv = document.getElementById("ionsCounts");
    const countHSpan = document.getElementById("countH");
    const countOHSpan = document.getElementById("countOH");

    const togglePhNumber = document.getElementById("togglePhNumber");
    const togglePhTable = document.getElementById("togglePhTable");
    const phTableDiv = document.getElementById("phTable");
    const phTableContent = document.getElementById("phTableContent");

    const toggleIndicatorColor = document.getElementById("toggleIndicatorColor");

    const modeAcidRadio = document.getElementById("modeAcid");
    const modeBaseRadio = document.getElementById("modeBase");

    // "acid" : acide dans l'erlen, base dans la burette
    // "base" : base dans l'erlen, acide dans la burette
    let mode = "acid";

    const V_BURETTE_MAX = 50;
    const V_ERLEN_INITIAL = 20;
    const V_ERLEN_MAX = 70;
    const DROP_VOL = 0.5;
    const DROP_SPEED = 1.5;

    const INITIAL_UNITS = 30;
    let netUnits;

    let V_burette, V_erlen, V_transf;

    const centerX = 400;

    const burette = {
      x: centerX,
      topY: 10,
      bottomY: 180,
      width: 40
    };

    const flask = {
      x: centerX,
      liquidBottomY: 380,
      liquidTopMinY: 230,
      topWidth: 120,
      bottomWidth: 320
    };

    const tip = {
      x: burette.x,
      y: burette.bottomY + 10
    };

    let lastTime = null;

    const ION_RADIUS = 12;
    const SMALL_ION_RADIUS = 4;

    const H_COLOR   = "rgba(255, 0, 0, 0.95)";
    const OH_COLOR  = "rgba(0, 128, 255, 0.95)";
    const SMALL_COLOR = "rgba(180, 180, 180, 0.9)";

    let buretteIons = [];
    let erlenIons = [];
    let erlenSmallIons = [];

    let activeDrop = null;

    let flashes = [];
    let waterMolecules = [];
    let greenFlashLife = 0;

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function getBuretteLiquidBounds() {
      const usableHeightB = (burette.bottomY - 10) - (burette.topY + 10);
      const hB = usableHeightB * (V_burette / V_BURETTE_MAX);
      const topLiquidB = burette.bottomY - 10 - hB;

      return {
        xMin: burette.x - burette.width / 2 + 10,
        xMax: burette.x + burette.width / 2 - 10,
        yMin: topLiquidB + 6,
        yMax: burette.bottomY - 10 - 6
      };
    }

    function getErlenLiquidBounds() {
      const usableHeightE = flask.liquidBottomY - flask.liquidTopMinY;
      const fracH = clamp(V_erlen / V_ERLEN_MAX, 0, 1);
      const hE = usableHeightE * fracH;
      const topLiquidE = flask.liquidBottomY - hE;

      const widthBottom = flask.bottomWidth;

      return {
        xMin: flask.x - widthBottom / 2 + 22,
        xMax: flask.x + widthBottom / 2 - 22,
        yMin: topLiquidE + 18,
        yMax: flask.liquidBottomY - 18,
        topLiquidY: topLiquidE
      };
    }

    function makeIon(symbol, color, radius, bounds) {
      const x = bounds.xMin + Math.random() * (bounds.xMax - bounds.xMin);
      const y = bounds.yMin + Math.random() * (bounds.yMax - bounds.yMin);
      const speed = 15 + Math.random() * 15;
      const angle = Math.random() * Math.PI * 2;
      return {
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        symbol,
        color,
        radius
      };
    }

    function resetIons() {
      const bBounds = getBuretteLiquidBounds();
      const eBounds = getErlenLiquidBounds();

      buretteIons = [];
      erlenIons = [];
      erlenSmallIons = [];
      flashes = [];
      waterMolecules = [];
      activeDrop = null;
      greenFlashLife = 0;

      const NB_OH = 80;

      if (mode === "acid") {
        for (let i = 0; i < NB_OH; i++) {
          buretteIons.push(makeIon("OH⁻", OH_COLOR, ION_RADIUS, bBounds));
        }
        for (let i = 0; i < INITIAL_UNITS; i++) {
          const ion = makeIon("H⁺", H_COLOR, ION_RADIUS, eBounds);
          ion.y += (i - INITIAL_UNITS / 2) * 1.5;
          erlenIons.push(ion);
        }
      } else {
        for (let i = 0; i < NB_OH; i++) {
          buretteIons.push(makeIon("H⁺", H_COLOR, ION_RADIUS, bBounds));
        }
        for (let i = 0; i < INITIAL_UNITS; i++) {
          const ion = makeIon("OH⁻", OH_COLOR, ION_RADIUS, eBounds);
          ion.y += (i - INITIAL_UNITS / 2) * 1.5;
          erlenIons.push(ion);
        }
      }

      const N_SMALL = INITIAL_UNITS;
      for (let i = 0; i < N_SMALL; i++) {
        erlenSmallIons.push(makeIon("", SMALL_COLOR, SMALL_ION_RADIUS, eBounds));
      }
    }

    // --- Courbe théorique forte/forte (sigmoïde) ---
    const CA = 0.10;
    const CB = 0.10;
    const VEQ_ML = 15;
    const VA = VEQ_ML / 1000;

    function log10(x) {
      return Math.log(x) / Math.LN10;
    }

    function computePHacid(V) {
      if (V < 0) V = 0;
      const VB = V / 1000;
      const Vtot = VA + VB;

      if (Math.abs(VB - VA) < 1e-9) {
        return 7;
      }

      let pH;

      if (VB < VA) {
        const nH_exces = CA * VA - CB * VB;
        const H = nH_exces / Vtot;
        pH = -log10(H);
      } else {
        const nOH_exces = CB * VB - CA * VA;
        const OH = nOH_exces / Vtot;
        const pOH = -log10(OH);
        pH = 14 - pOH;
      }

      if (!isFinite(pH)) pH = 7;
      pH = Math.max(0, Math.min(14, pH));
      return pH;
    }

    function computePH(V) {
      if (mode === "acid") {
        return computePHacid(V);
      } else {
        return 14 - computePHacid(V);
      }
    }

    function buildPhTable(currentV) {
      if (!togglePhTable.checked) {
        phTableDiv.style.display = "none";
        return;
      }
      phTableDiv.style.display = "block";

      const maxV = currentV;
      let lines = " V (mL)   pH\n";
      lines += "----------------\n";

      for (let v = 0; v <= maxV + 1e-9; v += 0.5) {
        const pH = computePH(v);
        const vStr = v.toFixed(1).padStart(4, " ");
        const pStr = pH.toFixed(2).padStart(5, " ");
        lines += `  ${vStr}   ${pStr}\n`;
      }

      phTableContent.textContent = lines;
    }

    function drawMiniGraph() {
      const c = document.getElementById("miniGraph");
      if (!c || !togglePhTable.checked) {
        if (c) c.style.display = "none";
        return;
      }
      c.style.display = "block";

      const ctx2 = c.getContext("2d");
      ctx2.clearRect(0, 0, c.width, c.height);

      ctx2.strokeStyle = "#999";
      ctx2.strokeRect(30, 10, c.width - 40, c.height - 30);

      const maxV = Math.floor(V_transf);
      if (maxV <= 0) return;

      // Axes
      ctx2.beginPath();
      ctx2.moveTo(30, c.height - 20);
      ctx2.lineTo(c.width - 10, c.height - 20); // axe X (V ajouté)
      ctx2.moveTo(30, c.height - 20);
      ctx2.lineTo(30, 10); // axe Y (pH)
      ctx2.strokeStyle = "#777";
      ctx2.stroke();

      // Labels des axes
      ctx2.font = "10px system-ui";
      ctx2.textAlign = "center";
      ctx2.textBaseline = "middle";
      // Label horizontal : Volume ajouté
      ctx2.fillText("V ajouté (mL)", c.width / 2, c.height - 6);
      // Label vertical : pH (écrit verticalement)
      ctx2.save();
      ctx2.translate(12, c.height / 2);
      ctx2.rotate(-Math.PI / 2);
      ctx2.fillText("pH", 0, 0);
      ctx2.restore();

      // Courbe pH(V)
      ctx2.beginPath();
      ctx2.strokeStyle = "#2563eb";
      ctx2.lineWidth = 2;

      for (let v = 0; v <= maxV; v++) {
        const pH = computePH(v);

        const x = 30 + ((c.width - 40) * v) / Math.max(1, maxV);
        const y = (c.height - 20) - ((c.height - 40) * (pH - 0) / 14);

        if (v === 0) ctx2.moveTo(x, y);
        else ctx2.lineTo(x, y);
      }
      ctx2.stroke();
    }

    function updateIonArray(arr, bounds, dt) {
      const jitter = 10;
      const maxV  = 55;

      for (const ion of arr) {
        ion.vx += (Math.random() - 0.5) * jitter;
        ion.vy += (Math.random() - 0.5) * jitter;

        const v = Math.hypot(ion.vx, ion.vy);
        if (v > maxV) {
          ion.vx = (ion.vx / v) * maxV;
          ion.vy = (ion.vy / v) * maxV;
        }

        ion.x += ion.vx * dt;
        ion.y += ion.vy * dt;

        if (ion.x < bounds.xMin + ion.radius) {
          ion.x = bounds.xMin + ion.radius;
          ion.vx *= -0.7;
        }
        if (ion.x > bounds.xMax - ion.radius) {
          ion.x = bounds.xMax - ion.radius;
          ion.vx *= -0.7;
        }
        if (ion.y < bounds.yMin + ion.radius) {
          ion.y = bounds.yMin + ion.radius;
          ion.vy *= -0.7;
        }
        if (ion.y > bounds.yMax - ion.radius) {
          ion.y = bounds.yMax - ion.radius;
          ion.vy *= -0.7;
        }

        ion.vx *= 0.985;
        ion.vy *= 0.985;
      }
    }

    function drawIons(ions, showLabels = true, obeyToggle = true) {
      if (obeyToggle && !toggleIons.checked) return;

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (const ion of ions) {
        if (showLabels && ion.symbol) {
          ctx.font = ion.radius <= 8 ? "8px system-ui" : "11px system-ui";
          ctx.fillStyle = "black";
          ctx.fillText(ion.symbol, ion.x, ion.y);
        }
      }
    }

    function startDrop() {
      if (activeDrop) return;
      if (V_burette <= 0) return;

      const speciesFromBurette = (mode === "acid") ? "OH⁻" : "H⁺";
      const index = buretteIons.findIndex(i => i.symbol === speciesFromBurette);
      if (index < 0) return;

      const ion = buretteIons.splice(index, 1)[0];

      ion.x = tip.x;
      ion.y = tip.y;
      ion.vx = 0;
      ion.vy = 0;

      const eBounds = getErlenLiquidBounds();
      const yEnd = eBounds.topLiquidY;

      activeDrop = {
        ion,
        progress: 0,
        yStart: tip.y,
        yEnd
      };

      const dV = clamp(DROP_VOL, 0, V_burette);
      V_burette -= dV;
      V_erlen = clamp(V_erlen + dV, 0, V_ERLEN_MAX);
      V_transf += dV;

      updateInfo();
    }

    function resetSimulation() {
      V_burette = V_BURETTE_MAX;
      V_erlen   = V_ERLEN_INITIAL;
      V_transf  = 0;
      netUnits  = (mode === "acid") ? INITIAL_UNITS : -INITIAL_UNITS;
      lastTime  = null;
      resetIons();
      updateInfo();
    }

    function getIndicatorColorAndState() {
      let color, stateText;
      if (netUnits > 0) {
        color = "rgb(250, 220, 0)";
        stateText = "acide (jaune, H⁺ en excès)";
      } else if (netUnits < 0) {
        color = "rgb(0, 120, 255)";
        stateText = "basique (bleu, OH⁻ en excès)";
      } else {
        color = "rgb(60, 180, 90)";
        stateText = "neutre (vert, ni H⁺ ni OH⁻ visibles)";
      }

      if (!toggleIndicatorColor.checked) {
        color = "rgba(220, 220, 220, 0.4)";
      }

      return { color, stateText };
    }

    function updateInfo() {
      volTSpan.textContent = V_transf.toFixed(1);

      let V = V_transf;
      let pH = computePH(V);
      pH = Math.max(0, Math.min(14, pH));

      if (togglePhNumber.checked) {
        phSpanEl.textContent = pH.toFixed(1);
      } else {
        phSpanEl.textContent = "—";
      }

      const countH = erlenIons.filter(i => i.symbol === "H⁺").length;
      const countOH = erlenIons.filter(i => i.symbol === "OH⁻").length;
      if (toggleIons.checked) {
        ionsCountsDiv.style.display = "block";
        countHSpan.textContent = countH;
        countOHSpan.textContent = countOH;
      } else {
        ionsCountsDiv.style.display = "none";
      }

      buildPhTable(V_transf);
      drawMiniGraph();
    }

    function forceExclusiveSpecies() {
      if (netUnits > 0) {
        erlenIons = erlenIons.filter(i => i.symbol === "H⁺");
      } else if (netUnits < 0) {
        erlenIons = erlenIons.filter(i => i.symbol === "OH⁻");
      } else {
        erlenIons = erlenIons.filter(i => i.symbol !== "H⁺" && i.symbol !== "OH⁻");
      }
    }

    function drawGlassware() {
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(0,0,0,0.7)";

      // support
      ctx.beginPath();
      ctx.moveTo(burette.x, burette.topY - 20);
      ctx.lineTo(burette.x, burette.topY - 40);
      ctx.moveTo(burette.x - 70, burette.topY - 40);
      ctx.lineTo(burette.x + 70, burette.topY - 40);
      ctx.stroke();

      // burette : parois latérales + fond, mais haut ouvert
      const w = burette.width;
      const top = burette.topY;
      const bottom = burette.bottomY;

      ctx.beginPath();
      ctx.moveTo(burette.x - w/2, top);
      ctx.lineTo(burette.x - w/2, bottom);
      ctx.lineTo(burette.x + w/2, bottom);
      ctx.lineTo(burette.x + w/2, top);
      ctx.stroke();

      // tube + robinet
      ctx.beginPath();
      ctx.moveTo(burette.x, burette.bottomY);
      ctx.lineTo(burette.x, burette.bottomY + 15);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(burette.x - 10, burette.bottomY + 5);
      ctx.lineTo(burette.x + 10, burette.bottomY + 5);
      ctx.stroke();

      // erlenmeyer
      const neckTopY = 190;
      const neckBottomY = 230;
      const neckWidthTop = 40;
      const neckWidthBottom = 80;

      ctx.beginPath();
      ctx.moveTo(flask.x - neckWidthTop / 2, neckTopY);
      ctx.lineTo(flask.x + neckWidthTop / 2, neckTopY);
      ctx.lineTo(flask.x + neckWidthBottom / 2, neckBottomY);
      ctx.lineTo(flask.x + flask.bottomWidth / 2, flask.liquidBottomY);
      ctx.lineTo(flask.x - flask.bottomWidth / 2, flask.liquidBottomY);
      ctx.lineTo(flask.x - neckWidthBottom / 2, neckBottomY);
      ctx.closePath();
      ctx.stroke();
    }

    function drawLiquids() {
      const usableHeightB = (burette.bottomY - 10) - (burette.topY + 10);
      const hB = usableHeightB * (V_burette / V_BURETTE_MAX);
      const topLiquidB = burette.bottomY - 10 - hB;

      ctx.fillStyle = "rgba(0, 120, 255, 0.45)";
      ctx.fillRect(
        burette.x - burette.width / 2 + 3,
        topLiquidB,
        burette.width - 6,
        hB
      );

      const usableHeightE = flask.liquidBottomY - flask.liquidTopMinY;
      const fracH = clamp(V_erlen / V_ERLEN_MAX, 0, 1);
      const hE = usableHeightE * fracH;
      const topLiquidE = flask.liquidBottomY - hE;

      const indicatorInfo = getIndicatorColorAndState();
      const indicatorColor = indicatorInfo.color;

      const tTop = (topLiquidE - flask.liquidTopMinY) /
                   (flask.liquidBottomY - flask.liquidTopMinY);
      const widthTop = flask.topWidth +
        (flask.bottomWidth - flask.topWidth) * clamp(tTop, 0, 1);
      const widthBottom = flask.bottomWidth;

      ctx.save();
      const neckTopY = 190;
      const neckBottomY = 230;
      const neckWidthTop = 40;
      const neckWidthBottom = 80;
      ctx.beginPath();
      ctx.moveTo(flask.x - neckWidthTop / 2, neckTopY);
      ctx.lineTo(flask.x + neckWidthTop / 2, neckTopY);
      ctx.lineTo(flask.x + neckWidthBottom / 2, neckBottomY);
      ctx.lineTo(flask.x + flask.bottomWidth / 2, flask.liquidBottomY);
      ctx.lineTo(flask.x - flask.bottomWidth / 2, flask.liquidBottomY);
      ctx.lineTo(flask.x - neckWidthBottom / 2, neckBottomY);
      ctx.closePath();
      ctx.clip();

      ctx.fillStyle = indicatorColor;
      ctx.beginPath();
      ctx.moveTo(flask.x - widthTop / 2, topLiquidE);
      ctx.lineTo(flask.x + widthTop / 2, topLiquidE);
      ctx.lineTo(flask.x + widthBottom / 2, flask.liquidBottomY);
      ctx.lineTo(flask.x - widthBottom / 2, flask.liquidBottomY);
      ctx.closePath();
      ctx.fill();

      if (greenFlashLife > 0 && toggleIndicatorColor.checked) {
        const alpha = clamp(greenFlashLife / 0.5, 0, 1);
        ctx.fillStyle = `rgba(0, 200, 0, ${0.4 * alpha})`;
        ctx.beginPath();
        ctx.moveTo(flask.x - widthTop / 2, topLiquidE);
        ctx.lineTo(flask.x + widthTop / 2, topLiquidE);
        ctx.lineTo(flask.x + widthBottom / 2, flask.liquidBottomY);
        ctx.lineTo(flask.x - widthBottom / 2, flask.liquidBottomY);
        ctx.closePath();
        ctx.fill();
      }

      drawIons(erlenSmallIons, false, true);
      drawIons(erlenIons, true, true);

      for (const f of flashes) {
        const alpha = clamp(f.life / 0.25, 0, 1);
        const r = 18;
        const r2 = 30;
        ctx.beginPath();
        ctx.fillStyle = `rgba(255,255,255,${0.6 * alpha})`;
        ctx.arc(f.x, f.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,200,${0.8 * alpha})`;
        ctx.lineWidth = 2;
        ctx.arc(f.x, f.y, r2, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const w of waterMolecules) {
        const alpha = clamp(w.life / 3.0, 0, 1);
        ctx.beginPath();
        ctx.fillStyle = `rgba(80, 160, 255, ${0.4 + 0.6 * alpha})`;
        ctx.arc(w.x, w.y, w.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.font = "9px system-ui";
        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
        ctx.fillText("H₂O", w.x, w.y);
      }

      ctx.restore();

      if (activeDrop && toggleIons.checked) {
        const ion = activeDrop.ion;
        const rDrop = 6;

        ctx.beginPath();
        ctx.fillStyle = "rgba(0,128,255,0.9)";
        ctx.arc(ion.x, ion.y, rDrop, 0, Math.PI * 2);
        ctx.fill();

        ctx.font = "11px system-ui";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(ion.symbol, ion.x, ion.y);
      }

      drawIons(buretteIons, true, true);
    }

    function handleDropArrival(dropIon) {
      const eBounds = getErlenLiquidBounds();
      const dropSymbol = dropIon.symbol;

      if (dropSymbol === "OH⁻") {
        if (netUnits > 0) {
          netUnits--;
          let idxH = erlenIons.findIndex(i => i.symbol === "H⁺");
          let flashX, flashY;
          if (idxH >= 0) {
            const h = erlenIons[idxH];
            flashX = h.x;
            flashY = h.y;
            erlenIons.splice(idxH, 1);
          } else {
            flashX = dropIon.x;
            flashY = eBounds.yMin + (eBounds.yMax - eBounds.yMin) / 2;
          }
          flashes.push({ x: flashX, y: flashY, life: 0.25 });
          waterMolecules.push({ x: flashX, y: flashY, radius: 7, life: 3.0 });
        } else {
          netUnits--;
          const ohIon = {
            x: dropIon.x,
            y: eBounds.yMin + 10,
            vx: (Math.random() - 0.5) * 40,
            vy: (Math.random() - 0.5) * 40,
            symbol: "OH⁻",
            color: OH_COLOR,
            radius: ION_RADIUS
          };
          erlenIons.push(ohIon);
        }
      } else if (dropSymbol === "H⁺") {
        if (netUnits < 0) {
          netUnits++;
          let idxOH = erlenIons.findIndex(i => i.symbol === "OH⁻");
          let flashX, flashY;
          if (idxOH >= 0) {
            const oh = erlenIons[idxOH];
            flashX = oh.x;
            flashY = oh.y;
            erlenIons.splice(idxOH, 1);
          } else {
            flashX = dropIon.x;
            flashY = eBounds.yMin + (eBounds.yMax - eBounds.yMin) / 2;
          }
          flashes.push({ x: flashX, y: flashY, life: 0.25 });
          waterMolecules.push({ x: flashX, y: flashY, radius: 7, life: 3.0 });
        } else {
          netUnits++;
          const hIon = {
            x: dropIon.x,
            y: eBounds.yMin + 10,
            vx: (Math.random() - 0.5) * 40,
            vy: (Math.random() - 0.5) * 40,
            symbol: "H⁺",
            color: H_COLOR,
            radius: ION_RADIUS
          };
          erlenIons.push(hIon);
        }
      }

      erlenSmallIons.push(
        makeIon("", SMALL_COLOR, SMALL_ION_RADIUS, eBounds)
      );

      forceExclusiveSpecies();

      if (Math.abs(netUnits) === 1) {
        greenFlashLife = 0.5;
      }

      updateInfo();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#f3f4f6";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#e5e7eb";
      ctx.fillRect(0, 400, canvas.width, 80);

      drawGlassware();
      drawLiquids();
    }

    function update(dt) {
      if (activeDrop) {
        activeDrop.progress += DROP_SPEED * dt;
        const t = Math.min(activeDrop.progress, 1);
        activeDrop.ion.x = tip.x;
        activeDrop.ion.y =
          activeDrop.yStart + (activeDrop.yEnd - activeDrop.yStart) * t;

        if (activeDrop.progress >= 1) {
          handleDropArrival(activeDrop.ion);
          activeDrop = null;
        }
      }

      const bBounds = getBuretteLiquidBounds();
      const eBounds = getErlenLiquidBounds();

      updateIonArray(buretteIons, bBounds, dt);
      updateIonArray(erlenIons, eBounds, dt);
      updateIonArray(erlenSmallIons, eBounds, dt);

      if (netUnits === 0) {
        erlenIons = erlenIons.filter(i => i.symbol !== "H⁺" && i.symbol !== "OH⁻");
      }

      for (let i = flashes.length - 1; i >= 0; i--) {
        flashes[i].life -= dt;
        if (flashes[i].life <= 0) {
          flashes.splice(i, 1);
        }
      }

      for (let i = waterMolecules.length - 1; i >= 0; i--) {
        const w = waterMolecules[i];
        w.life -= dt;
        w.y += 10 * dt;
        const eBounds2 = getErlenLiquidBounds();
        w.y = Math.min(w.y, eBounds2.yMax - 5);
        if (w.life <= 0) {
          waterMolecules.splice(i, 1);
        }
      }

      if (greenFlashLife > 0) {
        greenFlashLife -= dt;
        if (greenFlashLife < 0) greenFlashLife = 0;
      }

      updateInfo();
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }

    goutteBtn.addEventListener("click", startDrop);
    resetBtn.addEventListener("click", resetSimulation);
    toggleIons.addEventListener("change", updateInfo);
    togglePhNumber.addEventListener("change", updateInfo);
    togglePhTable.addEventListener("change", updateInfo);
    toggleIndicatorColor.addEventListener("change", updateInfo);

    modeAcidRadio.addEventListener("change", () => {
      if (modeAcidRadio.checked) {
        mode = "acid";
        resetSimulation();
      }
    });
    modeBaseRadio.addEventListener("change", () => {
      if (modeBaseRadio.checked) {
        mode = "base";
        resetSimulation();
      }
    });

    resetSimulation();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
