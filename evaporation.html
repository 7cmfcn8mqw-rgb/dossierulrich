<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title> Eau salée – Évaporation et cristallisation</title>
<style>

@media (max-width: 640px){
  .wrap{ max-width:none; margin:0; padding:10px; }
  .card{ border-radius:18px; }
  canvas{ border-radius:14px; }
  button{ padding:12px 14px; font-size:15px; border-radius:14px; }
  .badge{ font-size:11px; padding:9px 11px; right:10px; }
}



.canvasWrap{ padding:14px; }
#c{ width:100%; height:auto; display:block; }


.badge{
  position:fixed;
  right:12px;
  bottom:max(12px, env(safe-area-inset-bottom));
  padding:10px 12px;
  border-radius:12px;
  background:rgba(245,245,245,.92);
  border:1px solid rgba(0,0,0,.18);
  box-shadow:0 10px 30px rgba(0,0,0,.28);
  color:rgba(15,18,28,.95);
  font-weight:650;
  font-size:12px;
  line-height:1.2;
  text-align:left;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  user-select:none;
  pointer-events:none;
  z-index:2147483647;
}
.badge .v{font-size:12px;font-weight:850;letter-spacing:.2px;}
.badge .s{font-size:12px;font-weight:650;opacity:.92;}

:root{--bg:#0b1220;--panel:#111a2e;--ink:#e8eefc;--muted:#a9b4d6;--accent:#7dd3fc;--heat:#fb7185}
*{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
body{margin:0;background:linear-gradient(180deg,#070b14,#0b1220 30%,#070b14);color:var(--ink)}
.wrap{max-width:980px;margin:24px auto;padding:16px}
h1{margin:0 0 10px;font-size:18px;font-weight:650}
p{margin:0 0 14px;color:var(--muted);line-height:1.35;font-size:13px}
.grid{
  display:grid;
  grid-template-columns: 1fr;
  gap:16px;
}
@media (max-width:920px){.grid{grid-template-columns:1fr}}
.card{background:rgba(17,26,46,.85);border:1px solid rgba(125,211,252,.18);border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.35);overflow:hidden}
.canvasWrap{padding:10px; position:relative}
canvas{width:100%;height:auto;display:block;border-radius:12px;background:
  radial-gradient(1200px 600px at 50% 20%, rgba(125,211,252,.10), transparent 55%),
  radial-gradient(900px 500px at 30% 90%, rgba(251,113,133,.08), transparent 55%),
  #081028}
.controls{padding:14px;display:flex;flex-direction:column;gap:12px}
.btns{display:flex;gap:10px;flex-wrap:wrap}
button{background:#0a1230;color:var(--ink);border:1px solid rgba(125,211,252,.25);border-radius:12px;padding:9px 12px;cursor:pointer}
button:hover{border-color:rgba(125,211,252,.45)}
button.primary{background:linear-gradient(180deg, rgba(125,211,252,.22), rgba(125,211,252,.06))}
.stats{display:grid;gap:8px}
.stat{display:flex;justify-content:space-between;gap:10px;font-size:12px;color:var(--muted)}
.stat b{color:var(--ink);font-weight:650}
.hint{padding:12px 14px 14px;border-top:1px solid rgba(125,211,252,.12);color:var(--muted);font-size:12px;line-height:1.45}
.pill{display:inline-flex;gap:8px;align-items:center;border:1px solid rgba(125,211,252,.22);border-radius:999px;padding:6px 10px;background:rgba(0,0,0,.12);font-size:12px;color:var(--muted)}
.dot{width:10px;height:10px;border-radius:999px;display:inline-block;background:var(--accent)}

</style>
<style>
/* Added by script: small top-left home button */
.home-btn{
  position:fixed;
  top:8px;
  left:8px;
  width:22px;
  height:22px;
  display:flex;
  align-items:center;
  justify-content:center;
  text-decoration:none;
  font-size:14px;
  line-height:1;
  border-radius:6px;
  background:rgba(255,255,255,0.8);
  color:#111;
  border:1px solid rgba(0,0,0,0.25);
  box-shadow:0 1px 3px rgba(0,0,0,0.15);
  z-index:2147483647;
}
.home-btn:hover{ background:rgba(255,255,255,0.95); }
.home-btn:active{ transform:translateY(1px); }
@media (prefers-color-scheme: dark){
  .home-btn{
    background:rgba(30,30,30,0.75);
    color:#f5f5f5;
    border:1px solid rgba(255,255,255,0.25);
  }
}

</style>
</head>
<body>
<a href="https://7cmfcn8mqw-rgb.github.io/dossierulrich/" class="home-btn" aria-label="Retour au menu principal" title="Menu">⟵</a>

<div class="wrap">
  <h1>Eau salée - capsule chauffée : évaporation → cristallisation</h1>
  <p>Allume le bain (flamme sous la coupelle). L’eau s’évapore (vapeurs/nuages). Quand il reste peu d’eau, le sel cristallise au fond.</p>

  <div class="grid">
    <div class="card canvasWrap">
<div class="s">S. Ulrich — ECG Henry-Dunant</div>
      </div>
      <canvas id="c" width="980" height="520" aria-label="Simulation"></canvas>
    </div>

    <div class="card">
      <div class="controls">
        <div class="btns">
          <button class="primary" id="toggle">▶︎ Allumer le bain</button>
          <button id="reset">↺ Réinitialiser</button>
        </div>

        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <span class="pill"><span class="dot"></span> Vapeur d’eau</span>
        </div>

        <div class="stats">
          <div class="stat"><span>Eau restante</span><b><span id="water">100</span> %</b></div>
          <div class="stat"><span>Cristallisation</span><b><span id="salt">0</span> %</b></div>
          <div class="stat"><span>État</span><b><span id="phase">Repos</span></b></div>
          <div class="stat"><span>Temps</span><b><span id="time">0.0</span> s</b></div>
        </div>
      </div>

      <div class="hint">
        <b>Notes :</b> la flamme est sous la coupelle. Les vapeurs sont représentées par des « nuages » semi-transparents. La cristallisation apparaît par petits sauts (effet « popcorn » visuel).
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const toggleBtn = document.getElementById('toggle');
  const resetBtn  = document.getElementById('reset');
  const waterEl   = document.getElementById('water');
  const saltEl    = document.getElementById('salt');
  const phaseEl   = document.getElementById('phase');
  const timeEl    = document.getElementById('time');

  // Geometry (stylised)
  const G = {
    // Coupelle 10 cm plus haut (à l'échelle du schéma)
    capsule: {x: 490, y: 240, r: 170, innerR: 164},
    // Flamme bien visible sous la grille, avec un bel écart
    flame:   {x: 490, y: 500},
    baseY:   505,
  };

  // Simulation state
  const state = {
    running:false,
    t:0,
    water:100,
    salt:0,
    vapor:[],      // particles
    crystals:[],   // objects
    popTimer:0,
    lastPopAt:0,
    sizzleStart:null,
    sizzleDone:false,
    sizzleFadeUntil:0,
    vaporHoldUntil:0,
  };

  // utils
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rnd=(a,b)=>a+Math.random()*(b-a);

  // --- Audio : grésillement lors de la cristallisation (WebAudio) ---
  // Objectif : un bruit de "saisie" / grésillement quand l'eau est presque partie et que le sel cristallise.
  let audioCtx=null;
  let sizzle=null;

  function ensureAudio(){
    if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    return audioCtx;
  }

  function startSizzle(intensity=0.6){
    try{
      // crée le générateur une seule fois et le garde en vie (Safari + fiable)
      const ctxA = ensureAudio();
      if(!sizzle){
        // Bruit blanc en boucle
        const bufferSize = 2 * ctxA.sampleRate;
        const noiseBuffer = ctxA.createBuffer(1, bufferSize, ctxA.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) output[i] = Math.random()*2 - 1;

        const noise = ctxA.createBufferSource();
        noise.buffer = noiseBuffer;
        noise.loop = true;

        const high = ctxA.createBiquadFilter();
        high.type = 'highpass';
        high.frequency.value = 700;

        const band = ctxA.createBiquadFilter();
        band.type = 'bandpass';
        band.frequency.value = 2600;
        band.Q.value = 1.2;

        const gain = ctxA.createGain();
        gain.gain.value = 0.0001; // inaudible par défaut

        noise.connect(high);
        high.connect(band);
        band.connect(gain);
        gain.connect(ctxA.destination);

        noise.start();
        sizzle = {noise, gain, band, high};
      }

      setSizzle(intensity, true);
    }catch(e){}
  }

  function setSizzle(intensity=0.6, fast=false){
    try{
      if(!sizzle || !audioCtx) return;
      const t0 = audioCtx.currentTime;
      const target = Math.max(0.0001, Math.min(0.22, 0.03 + 0.19*intensity)); // audible
      sizzle.gain.gain.cancelScheduledValues(t0);
      sizzle.gain.gain.setValueAtTime(Math.max(0.0001, sizzle.gain.gain.value), t0);
      sizzle.gain.gain.exponentialRampToValueAtTime(target, t0 + (fast?0.06:0.18));
      sizzle.band.frequency.setValueAtTime(1800 + 1500*intensity, t0);
    }catch(e){}
  }

  function stopSizzle(fadeSec=1.2){
    try{
      if(!sizzle || !audioCtx) return;
      const t0 = audioCtx.currentTime;
      const end = t0 + Math.max(0.15, fadeSec);

      sizzle.gain.gain.cancelScheduledValues(t0);
      sizzle.gain.gain.setValueAtTime(Math.max(0.0001, sizzle.gain.gain.value), t0);
      sizzle.gain.gain.exponentialRampToValueAtTime(0.0001, end);

      // on garde le générateur en vie, juste inaudible (évite les soucis Safari)
    }catch(e){}
  }

  // Particles: vaporeux = nuages (plusieurs blobs)
  function spawnVaporCloud(){
    const x = G.capsule.x + rnd(-120,120);
    const y = G.capsule.y - rnd(40,110);
    const base = {
      x, y,
      vx: rnd(-12,12),
      vy: rnd(-30,-55),
      life: rnd(2.2,3.8),
      age: 0,
      seed: Math.random()*Math.PI*2,
      scale: rnd(0.8,1.2),
    };
    // Un nuage = 3 à 6 blobs liés
    const blobs = [];
    const n = Math.floor(rnd(3,6));
    for(let i=0;i<n;i++){
      blobs.push({
        ox: rnd(-20,20),
        oy: rnd(-12,12),
        r: rnd(14,26),
        ph: Math.random()*Math.PI*2,
      });
    }
    state.vapor.push({...base, blobs});
  }

  // Crystals
  
  
  
  function ensureCrystals(){
    // Cristaux collés à la paroi (bas de coupelle), en laissant le centre plus libre
    if(state.crystals.length>0) return;

    const n = 22;                     // moins de cristaux pour éviter l'effet "bouchon"
    const r = (G.capsule.innerR - 10);
    const cx = G.capsule.x;
    const cy = G.capsule.y;

    function pickTheta(){
      // On évite la zone centrale (autour de PI/2) et on privilégie les côtés
      // gauche : ~ 0.20π à 0.42π ; droite : ~ 0.58π à 0.80π
      const left = Math.random() < 0.5;
      if(left) return rnd(Math.PI*0.20, Math.PI*0.42);
      return rnd(Math.PI*0.58, Math.PI*0.80);
    }

    for(let i=0;i<n;i++){
      const th = pickTheta();
      const x = cx + r * Math.cos(th);
      const yArc = cy + r * Math.sin(th);

      // orientation : légèrement alignée avec la tangente du fond
      const rot = (th - Math.PI/2) * 0.55 + rnd(-0.12, 0.12);

      state.crystals.push({
        x,
        y: yArc - rnd(2,6),     // collé au fond (dans la parabole)
        h: rnd(8,18),           // un peu plus petits
        w: rnd(5,9),
        rot,
        grow: 0,
        jitter: Math.random()*Math.PI*2
      });
    }
  }

  // --- Draw helpers ---
  function roundRect(x,y,w,h,r,fill,stroke){
    const rr=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  function drawGrid(){
    ctx.globalAlpha=0.14;
    ctx.beginPath();
    for(let x=20;x<canvas.width;x+=40){ctx.moveTo(x,0);ctx.lineTo(x,canvas.height)}
    for(let y=20;y<canvas.height;y+=40){ctx.moveTo(0,y);ctx.lineTo(canvas.width,y)}
    ctx.strokeStyle='#7dd3fc';
    ctx.lineWidth=1; ctx.stroke();
    ctx.globalAlpha=1;
  }

  function drawStand(){
    ctx.strokeStyle='rgba(232,238,252,.55)';
    ctx.lineWidth=5;
    ctx.beginPath();
    ctx.moveTo(170,90); ctx.lineTo(170,G.baseY);
    ctx.lineTo(820,G.baseY);
    ctx.stroke();
    // Small platform under capsule
    ctx.fillStyle='rgba(0,0,0,.22)';
    ctx.strokeStyle='rgba(232,238,252,.30)';
    ctx.lineWidth=2;
    roundRect(G.capsule.x-220, G.baseY-18, 440, 18, 10, true, true);
  }
  function drawGrill(){
    // Grille métallique (entre la flamme et la coupelle)
    const w = 260, h = 16;
    const x = G.capsule.x - w/2;
    const y = G.baseY - 40;

    // cadre
    ctx.fillStyle = 'rgba(0,0,0,.18)';
    ctx.strokeStyle = 'rgba(232,238,252,.35)';
    ctx.lineWidth = 2;
    roundRect(x, y, w, h, 6, true, true);

    // maillage
    ctx.globalAlpha = 0.45;
    ctx.strokeStyle = 'rgba(232,238,252,.30)';
    ctx.lineWidth = 1;

    for(let gx = x+8; gx < x+w-6; gx += 12){
      ctx.beginPath();
      ctx.moveTo(gx, y+3);
      ctx.lineTo(gx, y+h-3);
      ctx.stroke();
    }
    for(let gy = y+5; gy < y+h-3; gy += 6){
      ctx.beginPath();
      ctx.moveTo(x+3, gy);
      ctx.lineTo(x+w-3, gy);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }



  function drawCapsule(){
    // Coupelle / capsule (ouverte vers le haut : forme en U)
    // Outer glass
    ctx.strokeStyle='rgba(232,238,252,.82)';
    ctx.lineWidth=6;
    ctx.beginPath();
    ctx.arc(G.capsule.x, G.capsule.y, G.capsule.r, 0, Math.PI, false); // demi-cercle du bas (∪)
    ctx.stroke();

    // inner lip
    ctx.strokeStyle='rgba(232,238,252,.28)';
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.arc(G.capsule.x, G.capsule.y, G.capsule.innerR, 0, Math.PI, false);
    ctx.stroke();

    // Eau : elle est DANS la coupelle, et la surface (en haut) DESCEND quand ça chauffe
    const level = state.water / 100; // 1 (plein) -> 0 (vide)
    const maxDepth = 160;            // profondeur max d'eau visible dans la coupelle
    const waterH = maxDepth * level;

    ctx.save();
    // clip à l'intérieur de la coupelle (demi-cercle inférieur)
    ctx.beginPath();
    ctx.arc(G.capsule.x, G.capsule.y, G.capsule.innerR - 3, 0, Math.PI, false);
    ctx.clip();

    // point le plus bas intérieur (sur l'écran)
    const bottomY = G.capsule.y + (G.capsule.innerR - 6);

    // eau : remplissage depuis le bas -> la ligne du haut baisse avec l'évaporation
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(125,211,252,.35)';
    ctx.fillRect(
      G.capsule.x - (G.capsule.innerR - 6),
      bottomY - waterH,
      (G.capsule.innerR - 6) * 2,
      waterH
    );

    // ménisque (surface)
    ctx.globalAlpha = 0.85;
    ctx.strokeStyle = 'rgba(232,238,252,.35)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(G.capsule.x - 120, bottomY - waterH);
    ctx.lineTo(G.capsule.x + 120, bottomY - waterH);
    ctx.stroke();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function drawFlame(){
    // base glow
    ctx.save();
    ctx.translate(G.flame.x, G.flame.y);
    const heat = 0.25 + 0.75*(state.running?1:0);
    ctx.globalAlpha = state.running ? 1 : 0.15;

    // soft glow
    ctx.fillStyle='rgba(251,113,133,.20)';
    ctx.beginPath(); ctx.ellipse(0, 26, 110, 22, 0, 0, Math.PI*2); ctx.fill();

    // flame body
    const wob = Math.sin(state.t*9)*5;
    const h = (state.running ? 60 : 28) + Math.sin(state.t*12)*6; // belle flamme (ça brûle)
    ctx.fillStyle='rgba(251,113,133,.92)';
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.quadraticCurveTo(-22+wob*0.35, -h*0.70, 0+wob*0.25, -h);
    ctx.quadraticCurveTo(22+wob*0.35, -h*0.70, 0, 0);
    ctx.closePath(); ctx.fill();

    // inner flame
    ctx.globalAlpha = state.running ? 0.9 : 0.12;
    ctx.fillStyle='rgba(232,238,252,.55)';
    const h2 = h*0.62;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.quadraticCurveTo(-12, -h2*0.70, 0, -h2);
    ctx.quadraticCurveTo(12, -h2*0.70, 0, 0);
    ctx.closePath(); ctx.fill();

    ctx.restore();
  }

  function drawVapor(){
    // clouds
    for(const p of state.vapor){
      const k = clamp(p.age/p.life, 0, 1);
      const fadeIn = clamp(k/0.15, 0, 1);
      const fadeOut = 1 - clamp((k-0.65)/0.35, 0, 1);
      const alpha = 0.40 * fadeIn * fadeOut;

      // Slight bluish white
      ctx.fillStyle = `rgba(232,238,252,${alpha})`;

      const wob = Math.sin(p.seed + state.t*2) * 10;
      for(const b of p.blobs){
        const bx = p.x + b.ox + Math.sin(b.ph + state.t*1.5)*4 + wob*0.15;
        const by = p.y + b.oy + Math.cos(b.ph + state.t*1.1)*3;
        ctx.beginPath();
        ctx.arc(bx, by, b.r * (0.85 + 0.25*k) * p.scale, 0, Math.PI*2);
        ctx.fill();
      }
      // subtle outline
      ctx.strokeStyle = `rgba(125,211,252,${alpha*0.30})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 34*(0.9+0.3*k)*p.scale, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  
  
  function drawCrystals(){
    // Les cristaux apparaissent dès que la cristallisation commence (salt > 0)
    if(state.salt <= 0.5) return;

    ensureCrystals();

    ctx.save();
    ctx.beginPath();
    ctx.arc(G.capsule.x, G.capsule.y, G.capsule.innerR-3, 0, Math.PI, false);
    ctx.clip();

    const amount = state.salt / 100;
    const visibleCount = Math.floor(lerp(0, state.crystals.length, amount));

    for(let i=0;i<visibleCount;i++){
      const cr = state.crystals[i];
      const g = cr.grow;
      const h = cr.h * g;   // plus de "rondulations" (pas de wobble)

      ctx.save();
      ctx.translate(cr.x, cr.y);
      ctx.rotate(cr.rot);

      ctx.fillStyle='rgba(232,238,252,.95)';
      ctx.beginPath();
      ctx.moveTo(-cr.w, 0);
      ctx.lineTo(-cr.w*0.35, -h*0.55);
      ctx.lineTo(0, -h);
      ctx.lineTo(cr.w*0.35, -h*0.55);
      ctx.lineTo(cr.w, 0);
      ctx.closePath();
      ctx.fill();

      // petit trait de brillance
      ctx.strokeStyle='rgba(125,211,252,.20)';
      ctx.lineWidth=1.5;
      ctx.beginPath();
      ctx.moveTo(0, -h);
      ctx.lineTo(0, 0);
      ctx.stroke();

      ctx.restore();
    }

    ctx.restore();
  }

  
  
  
  
  
  function drawLegend(){
    ctx.save();
    ctx.font='600 12px system-ui, sans-serif';
    ctx.fillStyle='rgba(232,238,252,.85)';
    ctx.strokeStyle='rgba(232,238,252,.45)';
    ctx.lineWidth=2;

    function arrow(x1,y1,x2,y2){
      ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      const ang=Math.atan2(y2-y1,x2-x1);
      const head=7;
      ctx.beginPath();
      ctx.moveTo(x2,y2);
      ctx.lineTo(x2-head*Math.cos(ang-0.6), y2-head*Math.sin(ang-0.6));
      ctx.lineTo(x2-head*Math.cos(ang+0.6), y2-head*Math.sin(ang+0.6));
      ctx.closePath();
      ctx.fill();
    }

    // Coupelle / capsule (toujours visible)
    ctx.fillText('Coupelle / capsule', 70, 150);
    arrow(
      230, 150,
      G.capsule.x - G.capsule.r + 6,
      G.capsule.y + 40
    );

    const crystalsOn = (state.water <= 2);
    const vaporOn = (state.t < state.vaporHoldUntil);

    // Vapeur d'eau : seulement quand il y a réellement de la vapeur
    if(vaporOn && !crystalsOn){
      ctx.fillText('Vapeur d\'eau', 70, 200);
      arrow(230, 200, G.capsule.x-30, G.capsule.y-120);
    }

    // Cristaux : seulement quand ils apparaissent
    if(crystalsOn){
      ctx.fillText('Cristaux (sel)', 70, 220);
      arrow(
        230, 220,
        G.capsule.x,
        G.capsule.y + (G.capsule.innerR - 10)
      );
    }

    // Bain / flamme
    ctx.fillText('Bain / flamme', 700, 505);
    arrow(820, 505, G.flame.x+5, G.flame.y-8);

    ctx.restore();
  }


  function drawError(msg){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // fond
    ctx.fillStyle='#081028';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle='rgba(232,238,252,.95)';
    ctx.font='700 18px system-ui, sans-serif';
    ctx.fillText('La simulation s\'est arrêtée (erreur)', 26, 44);

    ctx.fillStyle='rgba(169,180,214,.95)';
    ctx.font='500 12px system-ui, sans-serif';
    const s = String(msg || 'Erreur inconnue');
    const lines = s.split('\n').slice(0,10);
    let y = 70;
    for(const line of lines){
      ctx.fillText(line.slice(0,140), 26, y);
      y += 18;
    }

    ctx.fillStyle='rgba(169,180,214,.85)';
    ctx.fillText('Ouvre la console (Safari: Développement → Afficher la console JavaScript) pour voir le détail.', 26, y+8);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGrid();
    drawStand();
    drawGrill();
    drawCapsule();
    drawCrystals();
    drawVapor();
    drawFlame();
    drawLegend();

    // Title temp-like HUD (small)
    ctx.fillStyle='rgba(232,238,252,.92)';
    ctx.font='700 16px system-ui, sans-serif';
    ctx.fillText('Évaporation / cristallisation', 26, 34);
    ctx.font='500 12px system-ui, sans-serif';
    ctx.fillStyle='rgba(169,180,214,.95)';
    ctx.fillText('Modèle simplifié (animation pédagogique).', 26, 56);
    // HUD tick
    ctx.fillStyle='rgba(169,180,214,.75)';
    ctx.font='500 11px system-ui, sans-serif';
    ctx.fillText('t=' + state.t.toFixed(1) + 's', 26, 76);
  }

  // --- Update loop ---
  function update(dt){
    state.t += dt;

    // Evap rate: faster when running; stop at 0
    if(state.running && state.water > 0){
      // non-linear: strong at start, slower near end
      const evap = (7.5 + 6.5*Math.sin(state.t*0.6)*0.15) * (0.35 + 0.65*(state.water/100));
      state.water = Math.max(0, state.water - evap*dt);

      // vaporeux: spawn clouds proportional to evap
      const spawnRate = 2.0 + 4.0*(state.water/100); // clouds/sec
      const prob = 1 - Math.exp(-spawnRate*dt);
      if(Math.random() < prob) spawnVaporCloud();

            // If almost dry -> crystallize smoothly (sans à-coups)
      if(state.water < 28){
        const gain = (10 + 18*(1 - state.water/28)) * dt;
        state.salt = Math.min(100, state.salt + gain);
      }
    }


    
    // Grésillement : démarre quand la cristallisation commence (salt > 0),
    // dure max 10 s puis fade-out doux (sans être écrasé par des stops répétés).
    const inFade = (state.t < state.sizzleFadeUntil);

    if(state.running && !state.sizzleDone && state.salt > 0.5){
      if(state.sizzleStart === null) state.sizzleStart = state.t;
      const elapsed = state.t - state.sizzleStart;

      if(elapsed >= 10){
        // lance un fade-out plus long et marque une fenêtre de fade
        stopSizzle(2.8);
        state.sizzleFadeUntil = state.t + 2.8;
        state.sizzleDone = true;
      }else{
        const intensity = clamp(state.salt/100, 0, 1);
        startSizzle(0.35 + 0.65*intensity);
      }
    }else{
      // Hors fenêtre : si on est en train de "fade", on ne touche pas (sinon ça rend l'arrêt brutal)
      if(!inFade){
        stopSizzle(0.8);
      }
    }

    // Update vapor particles
    for(const p of state.vapor){
      p.age += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      // drift + diffusion
      p.vx += (Math.sin(p.seed + state.t*1.3)*6) * dt;
      p.vy -= 4*dt;
    }
    state.vapor = state.vapor.filter(p => p.age < p.life && p.y > -40);

    // Anti-clignotement : on garde l'état "vapeur visible" pendant un court instant
    if(state.vapor.length > 0){
      state.vaporHoldUntil = state.t + 1.2; // 1.2 s de maintien
    }

    // Update crystals growth according to salt
    if(state.salt > 0){
      ensureCrystals();
      const amount = state.salt/100;
      const targetCount = Math.floor(lerp(0, state.crystals.length, amount));
      for(let i=0;i<state.crystals.length;i++){
        const cr = state.crystals[i];
        const targetGrow = i < targetCount ? 1 : 0;
        cr.grow += (targetGrow - cr.grow) * (1 - Math.exp(-dt*3.2));
      }
    }
  }

  function syncUI(){
    waterEl.textContent = state.water.toFixed(0);
    saltEl.textContent  = state.salt.toFixed(0);
    timeEl.textContent  = state.t.toFixed(1);

    let phase = 'Repos';
    if(state.running && state.water > 30) phase = 'Évaporation';
    if(state.running && state.water <= 30 && state.water > 0) phase = 'Fin d\'évaporation';
    if(state.running && state.water === 0 && state.salt < 100) phase = 'Cristallisation';
    if(state.water === 0 && state.salt >= 100) phase = 'Cristallisé';
    phaseEl.textContent = phase;
  }

  function reset(){
    state.running=false;
    state.t=0;
    state.water=100;
    state.salt=0;
    state.vapor=[];
    state.crystals=[];
    state.popTimer=0;
    state.sizzleStart=null;
    state.sizzleDone=false;
    state.sizzleFadeUntil=0;
    state.vaporHoldUntil=0;
    stopSizzle();
    syncUI();
    draw();
  }

  // Controls
  toggleBtn.addEventListener('click', async () => {
    state.running = !state.running;
    toggleBtn.textContent = state.running ? '⏸︎ Éteindre' : '▶︎ Allumer le bain';
    // Ensure audio allowed after user gesture
    if(state.running){
      try{
        ensureAudio();
        await audioCtx.resume();
        // initialisation audio (inaudible) pour Safari
        try{ startSizzle(0.001); stopSizzle(0.2); }catch(e){}
      }catch(e){}
    }
  });

  resetBtn.addEventListener('click', () => {
    toggleBtn.textContent = '▶︎ Allumer le bain';
    reset();
  });

  // Main loop
  let last = performance.now();
  function tick(now){
    
    const dt = clamp((now-last)/1000, 0, 0.05);
    last = now;

    try{
      update(dt);
      syncUI();
      draw();
    }catch(e){
      console.error(e);
      drawError(e && e.stack ? e.stack : e);
      // on continue d'animer pour éviter un "freeze" silencieux
    }


    requestAnimationFrame(tick);
  }

  reset();
  requestAnimationFrame(tick);
})();
</script>
<div class="badge" aria-label="Version et établissement">
        <div class="v">Version 1.1</div>
</body>
</html>
