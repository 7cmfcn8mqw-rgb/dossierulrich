<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Alcane – 4 représentations + substituants (méthyl/éthyl) – fusion</title>
  <style>
    :root{
      --bg:#f6f7fb; --card:#fff; --ink:#111; --muted:#666; --line:#e3e5ef;
      --shadow:0 10px 30px rgba(0,0,0,.10);
      --ch:#d11;      /* rouge liaisons C–H (développée) */
      --accent:#1a8f3a;  /* rouge surlignage/numérotation */
      --r:16px;
    }
    body{margin:0;padding:24px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink);}
    .wrap{max-width:1020px;margin:0 auto;display:grid;gap:14px;}
    .panel{background:var(--card);border-radius:var(--r);box-shadow:var(--shadow);padding:14px;display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between;}
    .left{display:flex;gap:12px;flex-wrap:wrap;align-items:center;flex:1;}
    label{display:flex;gap:8px;align-items:center;font-size:.95rem;}
    input[type="number"]{width:92px;padding:7px 10px;border-radius:10px;border:1px solid var(--line);outline:none;}
    input[type="range"]{width:min(560px, 92vw);}
    .ticks{display:flex;justify-content:space-between;color:var(--muted);font-size:.85rem;margin-top:6px;user-select:none}
    .tick{display:flex;flex-direction:column;align-items:center;gap:4px}
    .dot{width:12px;height:8px;border-radius:999px;background:#dcdcdc}
    .dot.active{background:#111}

    /* sélection représentation (ronds cliquables) */
    .reps{display:flex;justify-content:space-between;gap:8px;align-items:flex-start}
    .tickBtn{
      background:transparent;border:0;padding:0;cursor:pointer;
      display:flex;flex-direction:column;align-items:center;gap:6px;
      color:var(--muted);font-size:.85rem;user-select:none;
    }
    .tickBtn .dot{width:10px;height:10px;border-radius:999px;background:#dcdcdc}
    .tickBtn.active{color:#111}
    .tickBtn.active .dot{background:#111}
    .tickBtn:focus-visible{outline:2px solid rgba(17,17,17,.35);outline-offset:6px;border-radius:12px;}

    /* Désactivation de la représentation "Formule simplifiée" lorsqu'il y a des substituants */
    .tickBtn.disabled{
      opacity:.35;
      cursor:not-allowed;
      filter:grayscale(1);
    }
    .tickBtn.disabled .dot{background:#dcdcdc}
    .tickBtn.shake{animation:shake .25s linear 1;}

    /* transition douce entre représentations */
    #svg{transition:opacity .28s ease, transform .28s ease; transform:translateY(0); opacity:1}
    #svg.switching{opacity:0; transform:translateY(10px)}
    .right{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end;}
    .badge{border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:#fbfbfe;font-size:.9rem;white-space:nowrap}
    .pill{border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:#fff;font-size:.92rem;white-space:nowrap}
    .pillRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pillBtn{border:1px solid var(--line);border-radius:999px;padding:7px 12px;background:#fff;font-size:.92rem;cursor:pointer}
    .pillBtn[aria-pressed="true"]{border-color:rgba(209,17,17,.55);box-shadow:0 0 0 3px rgba(209,17,17,.12);font-weight:700}


    button{
      padding:8px 11px;border-radius:12px;border:1px solid var(--line);
      background:transparent;color:#111;cursor:pointer;font-weight:750;
    }
    button.primary{background:#111;color:#fff;border-color:#111;}
    button.danger{border-color:rgba(209,17,17,.35);}

    /* chips (drag&drop) */
    .chips{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .chip{
      display:inline-flex;align-items:center;gap:8px;
      border:1px solid var(--line);border-radius:999px;padding:8px 12px;
      background:#fff;font-weight:850;cursor:grab; user-select:none;
    }
    .chip:active{cursor:grabbing;}
    .chip small{font-weight:700;color:var(--muted)}

    .stage{background:var(--card);border-radius:var(--r);box-shadow:var(--shadow);padding:10px;position:relative;overflow:hidden;}
    svg{width:100%;height:420px;display:block;}
    .caption{display:flex;justify-content:space-between;color:var(--muted);font-size:.92rem;padding:8px 4px 2px;}

    /* modal formule brute */
    .modal{
      position:absolute; inset: 16px;
      background: rgba(255,255,255,.92);
      border:1px solid var(--line);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 16px;
      display:none;
      backdrop-filter: blur(6px);
    }
    .modal h2{margin:0;font-size:1.05rem;}
    .row{margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .big{margin-top:10px;font-size:2rem;font-weight:900;letter-spacing:.4px;}

    /* Formule brute typographiée (indices alignés) */
    .chemFormula{letter-spacing:.2px;}
    .chemFormula sub{font-size:0.62em; line-height:0; vertical-align:-0.38em;}

    /* hint simplifiée (uniquement en phase 3) */
    .hintBox{ margin-top: 10px; display:none; }

    /* SVG */
    .fade{transition:opacity .22s ease;}
    .hidden{opacity:0;pointer-events:none;}

    .carbon{pointer-events:none;fill:#111;font-size:16px;font-weight:900;text-anchor:middle;dominant-baseline:middle;}
    .hydrogen{pointer-events:none;fill:#111;font-size:14px;font-weight:800;text-anchor:middle;dominant-baseline:middle;}
    .hydrogenEnd{pointer-events:none;fill:#333;font-size:14px;font-weight:750;text-anchor:middle;dominant-baseline:middle;}
    .bondCC{pointer-events:none;stroke:#111;stroke-width:2.4;stroke-linecap:round;}
    .bondCH{pointer-events:none;stroke:var(--ch);stroke-width:2.6;stroke-linecap:round;}

    .semiGroup{fill:#111;font-size:16px;font-weight:900;text-anchor:middle;dominant-baseline:middle;}
    .semiBond{stroke:#111;stroke-width:2.4;stroke-linecap:round;}

    .skeletal{stroke:#111;stroke-width:3.2;stroke-linecap:round;stroke-linejoin:round;fill:none;}

    /* chaîne principale : surlignage + numérotation (option) */
    .mainHL{stroke:rgba(209,17,17,.22);stroke-width:10;stroke-linecap:round;stroke-linejoin:round;fill:none;}
    .numLabel{pointer-events:none;fill:var(--accent);font-size:12px;font-weight:900;text-anchor:middle;dominant-baseline:middle;}

    .numBadgeText{font-size:18px;font-weight:800;fill:#c41313;dominant-baseline:middle;text-anchor:middle;paint-order:stroke;stroke:rgba(255,255,255,0.95);stroke-width:4;}
    .numBadgeRect{fill:rgba(255,255,255,0.45);stroke:rgba(0,0,0,0.18);stroke-width:1;}

    /* zones de drop / gomme */
    .hit{fill:transparent; cursor:copy; pointer-events:all;}
    .dropRing{fill:none;stroke:rgba(209,17,17,.35);stroke-width:3;}
  
.pillBtn[disabled]{opacity:.45; cursor:not-allowed;}
.pillBtn.shake{animation:shake .25s linear 1;}
@keyframes shake{0%{transform:translateX(0)}25%{transform:translateX(-3px)}50%{transform:translateX(3px)}75%{transform:translateX(-2px)}100%{transform:translateX(0)}}

    /* --- Avertissements de limitations (hors semi-développée) --- */
    .limitBar{
      display:none;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      margin:10px 0 8px;
      border-radius:12px;
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(220,0,0,0.18);
      box-shadow:0 6px 18px rgba(0,0,0,0.06);
    }
    .limitBar.show{ display:flex; }
    .limitBar .tri{
      width:34px;height:34px;flex:0 0 34px;
      display:grid;place-items:center;
      border-radius:10px;
      background:rgba(220,0,0,0.08);
      border:1px solid rgba(220,0,0,0.18);
      font-size:20px;
    }
    .warnMini{
      display:none;
      margin-left:auto;
      align-self:center;
      width:18px;height:18px;
      border-radius:6px;
      display:grid;place-items:center;
      font-size:12px;
      background:rgba(220,0,0,0.10);
      border:1px solid rgba(220,0,0,0.20);
      color:#b80000;
    }
    .warnOn .warnMini{ display:grid; }
    /* quand un bouton est disabled, on garde l'icône visible si warnOn */
    .pillBtn.warnOn[disabled]{ opacity:0.55; }


.numWarning{
  display:flex;
  align-items:flex-start;
  gap:12px;
  margin-left:16px;
}

.numWarningIcon{
  width:36px;
  height:36px;
  border-radius:50%;
  background:#fdecea;
  color:#c0392b;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:22px;
  font-weight:900;
  border:2px solid #e0b4b4;
}

.numWarningText{
  font-size:13px;
  line-height:1.25;
  max-width:260px;
}




.formulaBrute dragSub.cIndex{
  margin-right:12px;
}


    .bondChip{ width:56px; justify-content:center; font-weight:900; }
    .bondChip .bondSym{ font-size:22px; line-height:1; }
    .bondChip.disabled{ opacity:.35; filter:grayscale(1); pointer-events:none; }
    
    /* --- Label version en haut à droite --- */
    
    /* --- Label version (haut à droite de la page) --- */
    .topRightLabel{
      position:fixed;
      top:12px;
      right:12px;
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(17,17,17,0.22);
      border-radius:12px;
      padding:8px 12px;
      font-size:13px;
      font-weight:650;
      letter-spacing:0.1px;
      box-shadow:0 6px 18px rgba(0,0,0,0.10);
      text-align:right;
      z-index:9999;
      line-height:1.15;
      backdrop-filter: blur(6px);
    }
    .topRightLabel .l1{font-weight:800;}
    .topRightLabel .l2{font-weight:650; opacity:0.92;}
    .topRightLabel .l3{font-weight:650; opacity:0.92;}

    /* --- Mode mobile : sélection -> tap (sans drag) --- */
    .chip.selected{
      border-color: rgba(26,143,58,.55);
      box-shadow: 0 0 0 3px rgba(26,143,58,.14);
      font-weight: 950;
    }
    .tapHint{
      display:none;
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      background: rgba(255,255,255,.92);
      border:1px solid rgba(17,17,17,.18);
      box-shadow: 0 6px 18px rgba(0,0,0,0.06);
      color:#111;
      font-size:13px;
      line-height:1.25;
      align-items:center;
      gap:10px;
    }
    .tapHint.show{ display:flex; }
    .tapHint .dot{
      width:10px;height:10px;border-radius:999px;background:rgba(26,143,58,.85);
      flex:0 0 10px;
    }
    .tapHint .muted{ color: var(--muted); font-weight:650; }

</style>
<style>
/* Added by script: small top-left home button */
.home-btn{
  position:fixed;
  top:8px;
  left:8px;
  width:22px;
  height:22px;
  display:flex;
  align-items:center;
  justify-content:center;
  text-decoration:none;
  font-size:14px;
  line-height:1;
  border-radius:6px;
  background:rgba(255,255,255,0.8);
  color:#111;
  border:1px solid rgba(0,0,0,0.25);
  box-shadow:0 1px 3px rgba(0,0,0,0.15);
  z-index:2147483647;
}
.home-btn:hover{ background:rgba(255,255,255,0.95); }
.home-btn:active{ transform:translateY(1px); }
@media (prefers-color-scheme: dark){
  .home-btn{
    background:rgba(30,30,30,0.75);
    color:#f5f5f5;
    border:1px solid rgba(255,255,255,0.25);
  }
}

</style>
</head>
<body>
<a href="https://7cmfcn8mqw-rgb.github.io/dossierulrich/" class="home-btn" aria-label="Retour au menu principal" title="Menu">⟵</a>


  <div class="topRightLabel" aria-label="Informations de version">
    <div class="l1">Version 1.9</div>
    <div class="l2">ECG Henry-Dunant</div>
    <div class="l3">Serge Ulrich</div>
  </div>

  <div class="wrap">
    <div class="panel">
      <div class="left">
        <label>Carbones au départ <input type="number" id="nC" min="3" max="20" value="8"></label>

        <div style="display:grid;gap:6px;min-width:min(560px,92vw);flex:1;">
          <div class="ticks reps" role="radiogroup" aria-label="Choisir la représentation">
            <button class="tick tickBtn" type="button" role="radio" aria-checked="false" data-i="0">
              <span class="dot" aria-hidden="true"></span>
              <span>Formule brute</span>
            </button>
<button class="tick tickBtn active" type="button" role="radio" aria-checked="true" data-i="1">
              <span class="dot" aria-hidden="true"></span>
              <span>Formule développée</span>
            </button>
            <button class="tick tickBtn" type="button" role="radio" aria-checked="false" data-i="2">
              <span class="dot" aria-hidden="true"></span>
              <span>Formule semi-développée</span>
            </button>
            <button class="tick tickBtn" type="button" role="radio" aria-checked="false" data-i="3">
              <span class="dot" aria-hidden="true"></span>
              <span>Formule simplifiée</span>
            </button>
          </div>
        </div>

        <div class="chips" aria-label="Substituants à glisser">
          <div class="chip" draggable="true" data-dragSub="méthyl">méthyl <small>(CH₃)</small></div>
          <div class="chip" draggable="true" data-dragSub="éthyl">éthyl <small>(C₂H₅)</small></div>
          <div class="chip bondChip" draggable="true" data-bond="2" title="Double liaison (déposer sur une liaison)"><span class="bondSym">═</span></div>
          <div class="chip bondChip" draggable="true" data-bond="3" title="Triple liaison (déposer sur une liaison)"><span class="bondSym">≡</span></div>
          <button id="eraseOne" class="danger" title="Remet tout à zéro (octane en formule brute)">Reset</button>
          <button class="primary" id="reset">Réinitialiser</button>
        </div>

        <div class="tapHint" id="tapHint" aria-live="polite">
          <span class="dot" aria-hidden="true"></span>
          <span id="tapHintText"><span class="muted">Mode tactile :</span> sélectionne un outil puis tape sur la molécule.</span>
        </div>


        <div class="pillRow">
          <button type="button" class="pillBtn" id="toggleChain" aria-pressed="false" title="Afficher / masquer la chaîne principale">Afficher la chaîne principale</button>
          <button type="button" class="pillBtn" id="toggleNumbers" data-warn="semiOnly" aria-pressed="false" title="Afficher / masquer la numérotation (uniquement la chaîne principale)">Afficher la numérotation</button>
          <button type="button" class="pillBtn" id="flipLogicBtn" aria-pressed="false" title="Inverser le sens de la chaîne (uniquement en semi‑développée)">Flip</button>

          <div class="numWarning inlineWarnPills" aria-live="polite">
            <div class="numWarningIcon">!</div>
            <div class="numWarningText">
              Certaines fonctions du programme ne sont accessibles<br>
              qu'en représentation <strong>semi‑développée</strong>.
            </div>
          </div>

        </div>
      </div>

      <div class="right">
        <span class="badge" id="badge">Décane</span>
        <span class="badge" id="summary">Substituants : aucun</span>
      </div>
    </div>

    <div class="stage">
<svg id="svg" viewBox="0 0 980 420" aria-label="Représentations d'un alcane (avec substituants)"></svg>
<div id="molName" style="margin-top:10px;font-size:18px;font-weight:600;"></div>

      <div class="modal" id="modal" role="note" aria-label="Formule brute">
        <h2>Formule brute</h2>
        <div class="row"><span class="pill">Alcane acyclique saturé : CₙH₂ₙ₊₂</span></div>
        <div class="big chemFormula" id="bruteBig">C<sub>10</sub>H<sub>22</sub></div>
        <div class="row">
          <span class="pill" id="namePill">Décane</span>
          <span class="pill" id="countPill">Chaîne principale : 10</span>
        </div>
      </div>

      <div class="caption">
        <div id="phaseTxt">Formule développée</div>
        <div id="countTxt">Carbones : 10</div>
      </div>
    </div>

    <div class="hintBox" id="hintBox">
      <span class="pill">En formule simplifiée, les H sont implicites</span>
    </div>
  </div>

<script>


/* =========================================================
   Alcane interactif – correctifs:
   - chaîne physique figée (positions verrouillées)
   - ajout substituants uniquement sur chaîne physique de base
   - DnD robuste (drop sur SVG -> carbone le plus proche)
   - valence respectée (H = 4 - degré)
   - chaîne principale IUPAC = plus longue (diamètre de l'arbre)
     -> n'affecte que numérotation/surlignage, jamais la géométrie
   - surlignage propre (par liaison, pas polyline "caverne")
   ========================================================= */

const svg = document.getElementById('svg');
const nC = document.getElementById('nC');
let phaseVal = 0; // 0..3 (brute, développée, semi, simplifiée) // 0..3 (brute, développée, semi, simplifiée)

const badge = document.getElementById('badge');
const summary = document.getElementById('summary');
const phaseTxt = document.getElementById('phaseTxt');

const bruteBig = document.getElementById('bruteBig');
const countTxt = document.getElementById('countTxt');
const countPill = document.getElementById('countPill');
const resetBtn = document.getElementById('reset');
const eraseOne = document.getElementById('eraseOne');
const toggleChain = document.getElementById('toggleChain');
const toggleNumbers = document.getElementById('toggleNumbers');
const flipLogicBtn = document.getElementById('flipLogicBtn');
let chainFlipped = false;
let showChain = false;
let showNumbers = false;

function updateLimitUI(){
  const isSemi = (phaseVal===2);
  const bar = document.getElementById('limitBar');
  if(bar) bar.classList.toggle('show', !isSemi);

  // Numérotation uniquement en semi-développée
  toggleNumbers.disabled = !isSemi;
  toggleNumbers.classList.toggle('warnOn', !isSemi);

  if(!isSemi && showNumbers){
    showNumbers = false;
    setToggle(toggleNumbers, false);
  }

    // Flip (inversion logique de la chaîne) uniquement en semi‑développée
  if(flipLogicBtn){
    flipLogicBtn.disabled = !isSemi;
    flipLogicBtn.classList.toggle('warnOn', !isSemi);

    // Si on quitte la semi‑développée alors que la chaîne est inversée, on remet en normal.
    if(!isSemi && chainFlipped){
      chainFlipped = false;
      flipMainChain(); // re‑inverse -> revient à l’état normal
      flipLogicBtn.setAttribute('aria-pressed','false');
    }
  }

// Marqueurs ⚠ sur les fonctions "semi seulement"
  document.querySelectorAll('[data-warn="semiOnly"]').forEach(el=>{
    el.classList.toggle('warnOn', !isSemi);
  });

  // Message d'avertissement : visible uniquement hors semi-développée
  const warn = document.querySelector('.numWarning');
  if(warn) warn.style.display = isSemi ? 'none' : '';

  // Désactivation/activation des outils selon la représentation
  try{ updateBondChipAvailability(); }catch(e){}
  try{ updateSubChipAvailability(); }catch(e){}
  try{ updateSimplifiedAvailability(); }catch(e){}
}


/* --- Règle demandée : Formule simplifiée interdite dès qu'il y a un substituant (méthyl/éthyl). ---
   Une double/triple liaison reste compatible avec la formule simplifiée, tant qu'il n'y a AUCUN substituant. */
function hasSubstituents(){
  // Dans ce programme, les substituants ajoutent des carbones en dehors de la chaîne de base initiale.
  return nodes.size > initialBaseIds.length;
}

function updateSimplifiedAvailability(){
  const simpBtn = document.querySelector('.tickBtn[data-i="3"]');
  if(!simpBtn) return;

  const disabled = hasSubstituents();

  // style + accessibilité
  simpBtn.classList.toggle('disabled', disabled);
  simpBtn.setAttribute('aria-disabled', disabled ? 'true' : 'false');

  // tooltip informatif
  const baseTitle = "Formule simplifiée";
  simpBtn.setAttribute('title', disabled
    ? "Indisponible dès qu'un substituant (méthyl/éthyl) est présent"
    : baseTitle
  );

  // si on est déjà en "simplifiée" (cas rare), on revient en semi-développée
  if(disabled && phaseVal===3){
    phaseVal = 2;
    document.querySelectorAll('.tickBtn').forEach(b=>{
      const active = (parseInt(b.dataset.i,10)===phaseVal);
      b.classList.toggle('active', active);
      b.setAttribute('aria-checked', active ? 'true':'false');
    });
  }
}

let animTimer = null;

/* --- Error overlay (pour éviter "plus rien") --- */
(function(){
  const box = document.createElement('div');
  box.style.cssText = "position:fixed;left:12px;bottom:12px;right:12px;max-width:1100px;margin:auto;padding:10px 12px;border-radius:12px;background:#fff3f3;border:1px solid #ffd0d0;color:#7a0000;box-shadow:0 8px 18px rgba(0,0,0,.08);display:none;z-index:9999;font-size:13px;line-height:1.35";
  box.id = "errBox";
  document.body.appendChild(box);
  window.addEventListener('error', (e)=>{
    box.style.display = 'block';
    box.textContent = "Erreur JS: " + (e.message || e.error || e.type) + " (ligne " + (e.lineno||"?") + ")";
  });
})();

/* --- Graph model (arbre) --- */
let nextId = 0;
let nodes = new Map(); // id -> {id, neighbors:Set<int>}
let initialBaseIds = []; // chaîne physique de base (horizontale)

let lockedPos = new Map(); // id -> {x,y} (géométrie figée)
const ORTHO_STEP = 72;

function node(id){ return nodes.get(id); }

function connect(a,b){
  node(a).neighbors.add(b);
  node(b).neighbors.add(a);
}

function disconnect(a,b){
  node(a).neighbors.delete(b);
  node(b).neighbors.delete(a);
}


function resetToStart(){
  // Retour à l'état initial : Octane (8 C) en formule brute
  nC.value = 8;
  resetGraph(8);

  phaseVal = 0; // formule brute
  document.querySelectorAll('.tickBtn').forEach(b=>{
    const active = (parseInt(b.dataset.i,10)===0);
    b.classList.toggle('active', active);
    b.setAttribute('aria-checked', active ? 'true':'false');
  });

  showChain = false;
  showNumbers = false;
  updateLimitUI();
  updateBondChips();
  renderAnimated();
}

function resetGraph(n){
  bondOrders.clear();
  nextId = 0;
  nodes = new Map();
  lockedPos = new Map();
  initialBaseIds = [];

  for(let i=0;i<n;i++){
    const id = nextId++;
    nodes.set(id, {id, neighbors:new Set()});
    initialBaseIds.push(id);
  }
  for(let i=0;i<n-1;i++) connect(initialBaseIds[i], initialBaseIds[i+1]);

  // layout base chain horizontal (figé)
  const startX = 80;
  const y = 220;
  for(let i=0;i<n;i++){
    lockedPos.set(initialBaseIds[i], {x:startX + i*ORTHO_STEP, y});
  }
}


/* --- Flip logique de la chaîne (uniquement en semi‑développée) --- */
function flipMainChain(){
  // Inverse l’ordre logique de la chaîne de base
  initialBaseIds.reverse();

  // Snapshot des positions actuelles (pour calculer les deltas)
  const oldPos = new Map();
  for(const id of initialBaseIds){
    const p = lockedPos.get(id);
    if(p) oldPos.set(id, {x:p.x, y:p.y});
  }

  // Recalcule les positions HORIZONTALES uniquement (chaîne de gauche à droite)
  const startX = 80;
  const y = 220;
  for(let i=0;i<initialBaseIds.length;i++){
    const id = initialBaseIds[i];
    const newP = {x:startX + i*ORTHO_STEP, y};
    const prev = oldPos.get(id);
    lockedPos.set(id, newP);

    // Déplace aussi tout ce qui est "branché" sur ce carbone (substituants),
    // afin qu’ils restent attachés visuellement au même carbone porteur.
    if(prev){
      const dx = newP.x - prev.x;
      const dy = newP.y - prev.y;
      if(dx!==0 || dy!==0){
        translateBranches(id, dx, dy);
      }
    }
  }
}

function translateBranches(carrierId, dx, dy){
  const baseSet = new Set(initialBaseIds);
  const q = [];
  const seen = new Set([carrierId]);

  // On part des voisins NON‑base (les branches)
  for(const nb of node(carrierId).neighbors){
    if(baseSet.has(nb)) continue;
    q.push(nb);
    seen.add(nb);
  }

  while(q.length){
    const u = q.shift();
    const p = lockedPos.get(u);
    if(p) lockedPos.set(u, {x:p.x + dx, y:p.y + dy});

    for(const v of node(u).neighbors){
      if(seen.has(v)) continue;
      // On NE TRAVERSE JAMAIS la chaîne de base : on reste dans la branche
      if(baseSet.has(v)) continue;
      seen.add(v);
      q.push(v);
    }
  }
}

/* --- Placement substituants (orthogonal, sans bouger l'existant) --- */
function keyXY(x,y){ return `${Math.round(x)}|${Math.round(y)}`; }
function occupiedSet(){
  const s = new Set();
  for(const p of lockedPos.values()) s.add(keyXY(p.x,p.y));
  return s;
}

function placeNewCarbon(anchorId, newId, preferredDir=null){
  const a = lockedPos.get(anchorId);
  if(!a) return false;
  const occ = occupiedSet();

  const dirs = [
    {name:'up', dx:0, dy:-ORTHO_STEP},
    {name:'down', dx:0, dy: ORTHO_STEP},
    {name:'right', dx: ORTHO_STEP, dy:0},
    {name:'left', dx:-ORTHO_STEP, dy:0},
  ];

  const dirByName = new Map(dirs.map(d=>[d.name,d]));

  // If a preferred direction is requested (used for parity rule),
  // we try *only that direction first* and allow stacking further away.
  if(preferredDir && dirByName.has(preferredDir)){
    const d = dirByName.get(preferredDir);
    for(let r=1; r<=10; r++){
      const x = a.x + d.dx*r;
      const y = a.y + d.dy*r;
      if(!occ.has(keyXY(x,y))){
        lockedPos.set(newId, {x,y});
        return d.name;
      }
    }
    // then fall through to generic search
  }

  // Generic search: prefer vertical (branches) then horizontal.
  let order = dirs.filter(d=>d.name==='up' || d.name==='down')
                  .concat(dirs.filter(d=>d.name==='right' || d.name==='left'));

  for(const d of order){
    const x = a.x + d.dx;
    const y = a.y + d.dy;
    if(!occ.has(keyXY(x,y))){
      lockedPos.set(newId, {x,y});
      return d.name;
    }
  }

  // fallback: spiral search on orthogonal grid
  for(let r=2; r<=12; r++){
    for(const d of dirs){
      const x = a.x + d.dx*r;
      const y = a.y + d.dy*r;
      if(!occ.has(keyXY(x,y))){
        lockedPos.set(newId, {x,y});
        return d.name;
      }
    }
  }

  // last resort: still place (rare)
  lockedPos.set(newId, {x:a.x, y:a.y-ORTHO_STEP});
  return 'up';
}

function isBaseCarbon(id){
  return initialBaseIds.includes(id);
}

function substituentCountOnBase(carbonId){
  const nd = nodes.get(carbonId);
  if(!nd) return 0;
  let c=0;
  nd.neighbors.forEach(nb=>{ if(!isBaseCarbon(nb)) c++; });
  return c;
}

function maxSubstituentsPerBaseCarbon(){
  // Requirement: only in semi-developed formula (phaseVal===2) we allow 2 substituents on the same carbon.
  // Otherwise we allow at most 1.
  return (phaseVal===2) ? 2 : 1;
}


function substituentKindsOnBase(carbonId){
  const nd = nodes.get(carbonId);
  const kinds = new Set();
  if(!nd) return kinds;
  nd.neighbors.forEach(nb=>{
    if(isBaseCarbon(nb)) return;
    const n = nodes.get(nb);
    if(n && n.subKind) kinds.add(n.subKind==='éthylTail' ? 'éthyl' : n.subKind);
    else kinds.add('unknown');
  });
  return kinds;
}


function preferredBranchDirForCarrier(carrierId){
  // Rule requested: radicals ABOVE for even-numbered main-chain carbons,
  // BELOW for odd-numbered main-chain carbons.
  // We compute numbering on the current IUPAC main chain (longest chain + lowest set of locants).
  const main = bestMainChain();
  if(!main || main.length===0) return null;
  const numbering = chooseNumbering(main);
  const n = numbering.num.get(carrierId);
  if(!n) return null;
  return (n % 2 === 0) ? 'up' : 'down';
}


function oppositeDir(d){
  if(d==='up') return 'down';
  if(d==='down') return 'up';
  if(d==='left') return 'right';
  if(d==='right') return 'left';
  return d;
}

function existingSubstituentsOn(carrierId){
  const nd = node(carrierId);
  const out = [];
  if(!nd) return out;
  nd.neighbors.forEach(nb=>{ if(!isBaseCarbon(nb)) out.push(nb); });
  return out;
}

// For semi-développée: if there is already 1 substituent, the 2nd is forced on the opposite side.
function preferredDirForNewSubstituent(carrierId){
  const pref = preferredBranchDirForCarrier(carrierId); // your alternating rule along the chain
  if(phaseVal!==2) return pref;

  const subs = existingSubstituentsOn(carrierId);
  if(subs.length===0) return pref;

  // Determine actual side of the first substituent using geometry (robust).
  const p = lockedPos.get(carrierId);
  const q = lockedPos.get(subs[0]);
  if(p && q){
    const dx = q.x - p.x, dy = q.y - p.y;
    const dir = (Math.abs(dx) > Math.abs(dy)) ? (dx>0?'right':'left') : (dy>0?'down':'up');
    return oppositeDir(dir);
  }
  // Fallback: opposite of parity rule
  return oppositeDir(pref);
}


function oppositeDir(d){
  if(d==='up') return 'down';
  if(d==='down') return 'up';
  if(d==='left') return 'right';
  if(d==='right') return 'left';
  return null;
}

// If a base carbon already has ONE substituent and we're in semi-developed mode (phaseVal===2),
// place the next substituent on the OPPOSITE side of the main chain so they don't overlap and remain chemically clear.

function preferredDirConsideringExistingSubstituents(carrierId){
  // Only apply this rule in semi-developed view where 2 substituents on the same carbon are allowed.
  if(phaseVal !== 2) return preferredBranchDirForCarrier(carrierId);

  const nd = node(carrierId);
  if(!nd) return preferredBranchDirForCarrier(carrierId);

  // existing substituents attached directly to this base carbon
  const subs = [];
  nd.neighbors.forEach(nb=>{ if(!isBaseCarbon(nb)) subs.push(nb); });

  // If there is already one substituent, the second must go on the opposite side
  // of the FIRST (based on actual geometry), so they never overlap visually.
  if(subs.length === 1){
    const p = lockedPos.get(carrierId);
    const q = lockedPos.get(subs[0]);
    if(p && q){
      const dx = q.x - p.x;
      const dy = q.y - p.y;

      // We only place branches up/down in semi-developed; decide which side the first one is on.
      const firstSide = (Math.abs(dy) >= Math.abs(dx)) ? (dy < 0 ? 'up' : 'down')
                                                     : preferredBranchDirForCarrier(carrierId);

      return oppositeDir(firstSide) || (firstSide === 'up' ? 'down' : 'up');
    }
    // Fallback: opposite of the parity side
    const paritySide = preferredBranchDirForCarrier(carrierId);
    return oppositeDir(paritySide) || (paritySide === 'up' ? 'down' : 'up');
  }

  // First substituent follows the alternating parity rule (even -> up, odd -> down)
  return preferredBranchDirForCarrier(carrierId);
}


/* --- Substituants --- */
function attachMéthyl(targetId){
  // Valence rule: adding a substituent consumes one H on the carrier carbon
  if(carbonHydrogens(targetId) <= 0) return false;

  const m = nextId++;
  nodes.set(m, {id:m, neighbors:new Set(), subKind:'méthyl'});
  connect(targetId, m);

  // place branch carbon (geometry is locked; no rearrangement)
  const prefDir = preferredDirConsideringExistingSubstituents(targetId);
  placeNewCarbon(targetId, m, prefDir);
  return true;
}

function attachÉthyl(targetId){
  // carrier carbon must have at least one H to replace
  if(carbonHydrogens(targetId) <= 0) return false;

  const e1 = nextId++;
  const e2 = nextId++;
  nodes.set(e1, {id:e1, neighbors:new Set(), subKind:'éthyl'});
  nodes.set(e2, {id:e2, neighbors:new Set(), subKind:'éthylTail'});
  connect(targetId, e1);
  connect(e1, e2);

  const prefDir = preferredDirConsideringExistingSubstituents(targetId);
  const dir = placeNewCarbon(targetId, e1, prefDir);
  // tail continues away from the carrier
  placeNewCarbon(e1, e2, dir);
  return true;
}

/* --- Longest chain in a tree (diameter path) --- */
function bfsFarthest(start){
  const q=[start];
  const dist=new Map([[start,0]]);
  const parent=new Map([[start,null]]);
  let far=start, farD=0;
  for(let qi=0; qi<q.length; qi++){
    const u=q[qi];
    const du=dist.get(u);
    if(du>farD){ farD=du; far=u; }
    for(const v of node(u).neighbors){
      if(!dist.has(v)){
        dist.set(v, du+1);
        parent.set(v, u);
        q.push(v);
      }
    }
  }
  return {far, farD, parent};
}

function longestPath(){
  if(nodes.size===0) return [];
  const any = nodes.keys().next().value;
  const a = bfsFarthest(any).far;
  const res = bfsFarthest(a);
  const b = res.far;
  // reconstruct a->b
  const path=[];
  let cur=b;
  while(cur!==null){
    path.push(cur);
    cur = res.parent.get(cur) ?? null;
  }
  path.reverse();
  return path;
}



function bestMainChain(){
  // IUPAC parent chain selection (tree):
  // Priority order (simplified but robust for this app):
  // 1) Maximize number of multiple bonds (double/triple) included in the parent chain.
  // 2) Then maximize chain length.
  // 3) Then maximize number of substituent attachment points.
  // 4) Then choose the orientation that gives the lowest set of locants
  //    (multiple bonds first, then substituents) via chooseNumbering().
  const N = nodes.size;
  if(N===0) return [];
  const ids = Array.from(nodes.keys());

  // Precompute BFS distances + parents from every node (N is small here, so OK).
  const distFrom = new Map();   // id -> Map(id->dist)
  const parentFrom = new Map(); // id -> Map(id->parent)
  for(const s of ids){
    const q=[s];
    const dist=new Map([[s,0]]);
    const parent=new Map([[s,null]]);
    for(let qi=0; qi<q.length; qi++){
      const u=q[qi];
      const du=dist.get(u);
      for(const v of node(u).neighbors){
        if(!dist.has(v)){
          dist.set(v, du+1);
          parent.set(v, u);
          q.push(v);
        }
      }
    }
    distFrom.set(s, dist);
    parentFrom.set(s, parent);
  }

  function pathBetween(a,b){
    // Reconstruct unique path a->b in a tree using parent map from a
    const parent = parentFrom.get(a);
    const path = [];
    let cur = b;
    while(cur!==null){
      path.push(cur);
      if(cur===a) break;
      cur = parent.get(cur) ?? null;
    }
    path.reverse();
    return path;
  }

  function multipleBondInfo(path){
    let count=0;
    let hasDouble=false, hasTriple=false;
    for(let i=0;i<path.length-1;i++){
      const ord = getBondOrder(path[i], path[i+1]);
      if(ord===2){ count++; hasDouble=true; }
      if(ord===3){ count++; hasTriple=true; }
    }
    return {count, hasDouble, hasTriple};
  }

  function substituentAttachmentCount(path){
    const inPath = new Set(path);
    let c=0;
    for(const id of path){
      for(const nb of node(id).neighbors){
        if(!inPath.has(nb)) c++;
      }
    }
    return c;
  }

  function lexLess(A,B){
    const n=Math.max(A.length,B.length);
    for(let i=0;i<n;i++){
      const a = (i<A.length)?A[i]:Infinity;
      const b = (i<B.length)?B[i]:Infinity;
      if(a<b) return true;
      if(a>b) return false;
    }
    return false;
  }

  function score(path){
    const mb = multipleBondInfo(path);
    const att = substituentAttachmentCount(path);
    const numbering = chooseNumbering(path);
    const bondType = numbering?.bond?.type ?? 1;
    const bondLoc = (numbering?.bond?.locants ?? []).slice().sort((a,b)=>a-b);
    const subLoc  = (numbering?.substituents ?? []).slice().sort((a,b)=>a-b);

    // Build comparable tuples (higher is better for first parts, lower is better for locants)
    // We prioritize presence of triple over double only if both would appear (shouldn't in this app),
    // but we still encode it to be safe.
    return {
      // maximize
      mbCount: mb.count,
      mbTypeRank: (mb.hasTriple?2:(mb.hasDouble?1:0)),
      len: path.length,
      att,
      // minimize
      bondLoc,
      subLoc
    };
  }

  function better(p, q){
    // return true if p is better than q
    if(q==null) return true;
    const a = score(p);
    const b = score(q);

    // 1) Max number of multiple bonds
    if(a.mbCount !== b.mbCount) return a.mbCount > b.mbCount;
    // 1b) If tie, prefer chain that contains higher-order unsaturation (triple > double)
    if(a.mbTypeRank !== b.mbTypeRank) return a.mbTypeRank > b.mbTypeRank;

    // 2) Max length
    if(a.len !== b.len) return a.len > b.len;

    // 3) Max substituent attachments
    if(a.att !== b.att) return a.att > b.att;

    // 4) Minimize locants: multiple bonds first, then substituents
    if(lexLess(a.bondLoc, b.bondLoc)) return true;
    if(lexLess(b.bondLoc, a.bondLoc)) return false;

    if(lexLess(a.subLoc, b.subLoc)) return true;
    if(lexLess(b.subLoc, a.subLoc)) return false;

    return false;
  }

  // Evaluate all unique paths in the tree (between every pair).
  // N is small, so O(N^2 * path) is fine.
  let best = null;
  for(let i=0;i<ids.length;i++){
    const a = ids[i];
    for(let j=i;j<ids.length;j++){
      const b = ids[j];
      const path = pathBetween(a,b);
      if(path.length===0) continue;
      if(better(path, best)) best = path;
    }
  }

  // Fallback
  return best || longestPath();
}


function chooseNumbering(path){
  const inPath = new Set(path);

  function bondTypeOnPath(forward=true){
    // 3 has priority if present (but mixing is prevented elsewhere)
    let has2=false, has3=false;
    for(let i=0;i<path.length-1;i++){
      const a = forward ? path[i] : path[path.length-1-i];
      const b = forward ? path[i+1] : path[path.length-2-i];
      const ord = getBondOrder(a,b);
      if(ord===2) has2=true;
      if(ord===3) has3=true;
    }
    return has3 ? 3 : (has2 ? 2 : 1);
  }

  function bondLocants(forward=true){
    const t = bondTypeOnPath(forward);
    const loc = [];
    if(t===1) return {type:1, locants:loc};
    for(let i=0;i<path.length-1;i++){
      const a = forward ? path[i] : path[path.length-1-i];
      const b = forward ? path[i+1] : path[path.length-2-i];
      const ord = getBondOrder(a,b);
      if(ord===t){
        // locant is the smaller index of the bond: i+1 in the chosen direction
        loc.push(i+1);
      }
    }
    loc.sort((a,b)=>a-b);
    return {type:t, locants:loc};
  }

  function substituentLocants(forward=true){
    const loc=[];
    for(let i=0;i<path.length;i++){
      const pid = forward ? path[i] : path[path.length-1-i];
      const pos = i+1;
      for(const nb of node(pid).neighbors){
        if(!inPath.has(nb)) loc.push(pos);
      }
    }
    loc.sort((a,b)=>a-b);
    return loc;
  }

  function lexLess(A,B){
    // compare two arrays lexicographically (A<B ?)
    const n=Math.max(A.length,B.length);
    for(let i=0;i<n;i++){
      const a = (i<A.length)?A[i]:Infinity;
      const b = (i<B.length)?B[i]:Infinity;
      if(a<b) return true;
      if(a>b) return false;
    }
    return false; // equal
  }

  const bf = bondLocants(true);
  const br = bondLocants(false);

  // Priority 1: smallest locant(s) for multiple bond(s) if any.
  
  function substituentProfile(forward=true){
    // Map substituent name -> list of locants in the chosen direction.
    // Used ONLY as a tie-breaker when locant sets are identical.
    const m = new Map();

    for(let i=0;i<path.length;i++){
      const pid = forward ? path[i] : path[path.length-1-i];
      const pos = i+1;

      for(const nb of node(pid).neighbors){
        if(inPath.has(nb)) continue;

        // branch length = number of carbons outside the main path
        let len = 0;
        const seen = new Set([pid]);
        const stack = [nb];
        while(stack.length){
          const u = stack.pop();
          if(seen.has(u)) continue;
          seen.add(u);
          if(!inPath.has(u)) len++;
          for(const v of node(u).neighbors){
            if(!seen.has(v) && !inPath.has(v)) stack.push(v);
          }
        }

        // For this classroom tool: 1 -> méthyl, >=2 -> éthyl (keeps original behaviour)
        const sname = (len===1) ? 'méthyl' : 'éthyl';

        if(!m.has(sname)) m.set(sname, []);
        m.get(sname).push(pos);
      }
    }

    // sort locants inside each substituent type
    for(const [k, arr] of m.entries()) arr.sort((a,b)=>a-b);

    // alphabetical order (accent-insensitive): éthyl < méthyl
    const names = Array.from(m.keys()).sort((a,b)=>alphaKey(a).localeCompare(alphaKey(b)));
    return {map:m, names};
  }

  function compareProfilesPreferForward(){
    // IUPAC tie-breaker when the *set* of locants is identical:
    // give the lowest possible locant to the substituent that comes first alphabetically.
    const pf = substituentProfile(true);
    const pr = substituentProfile(false);

    const allNames = Array.from(new Set([...pf.names, ...pr.names]))
      .sort((a,b)=>alphaKey(a).localeCompare(alphaKey(b)));

    for(const name of allNames){
      const lf = pf.map.get(name) || [];
      const lr = pr.map.get(name) || [];
      if(lexLess(lf, lr)) return true;
      if(lexLess(lr, lf)) return false;
    }
    return true; // perfectly identical: keep forward
  }

  let forwardBetter = true;
  if(!(bf.type===1 && br.type===1)){
    if(lexLess(br.locants, bf.locants)) forwardBetter = false;
    else if(lexLess(bf.locants, br.locants)) forwardBetter = true;
    else{
      // tie on multiple bonds -> use substituent locants, then alphabetical tie-break
      const sf = substituentLocants(true);
      const sr = substituentLocants(false);

      if(lexLess(sr, sf)) forwardBetter = false;
      else if(lexLess(sf, sr)) forwardBetter = true;
      else forwardBetter = compareProfilesPreferForward();
    }
  }else{
    // No multiple bonds -> use substituent locants, then alphabetical tie-break
    const sf = substituentLocants(true);
    const sr = substituentLocants(false);

    if(lexLess(sr, sf)) forwardBetter = false;
    else if(lexLess(sf, sr)) forwardBetter = true;
    else forwardBetter = compareProfilesPreferForward();
  }

  const forward = forwardBetter;


  const num = new Map();
  for(let i=0;i<path.length;i++){
    const id = forward ? path[i] : path[path.length-1-i];
    num.set(id, i+1);
  }

  return {
    num,
    forward,
    bond: forward ? bf : br,
    substituents: forward ? substituentLocants(true) : substituentLocants(false)
  };
}


/* --- Chemical labels --- */

/* --- Liaisons multiples (double/triple) --- */
const bondOrders = new Map(); // key "a|b" -> 1,2,3
function edgeKey(a,b){ return (a<b) ? (a+"|"+b) : (b+"|"+a); }

function hasAnyBondOrder(ord){
  for(const v of bondOrders.values()){ if(v===ord) return true; }
  return false;
}
function updateBondChipAvailability(){
  const dbl = document.querySelector('.bondChip[data-bond="2"]');
  const tri = document.querySelector('.bondChip[data-bond="3"]');
  if(!dbl || !tri) return;

  const isSemi = (phaseVal===2);

  // Helper to set disabled look + behaviour
  const setDisabled = (el, disabled, msg)=>{
    if(!el.dataset.origTitle) el.dataset.origTitle = el.getAttribute('title') || '';
    el.style.opacity = disabled ? '0.35' : '';
    el.style.filter  = disabled ? 'grayscale(1)' : '';
    el.style.cursor  = disabled ? 'not-allowed' : '';
    el.draggable = !disabled;
    el.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    el.setAttribute('title', disabled ? (el.dataset.origTitle + " — " + msg) : el.dataset.origTitle);
    el.classList.toggle('disabled', disabled);
  };

  // Hors semi-développée : toujours grisé
  if(!isSemi){
    setDisabled(dbl, true, "Disponible uniquement en représentation semi‑développée");
    setDisabled(tri, true, "Disponible uniquement en représentation semi‑développée");
    return;
  }

  // En semi-développée : règle d'exclusivité (jamais double + triple)
// Important : la présence de substituants n'influence PAS l'autorisation des liaisons multiples.
let hasDouble = false;
let hasTriple = false;
for(const ord of bondOrders.values()){
  if(ord===2) hasDouble = true;
  if(ord===3) hasTriple = true;
}

// Double désactivée seulement s'il y a déjà une triple
setDisabled(dbl, hasTriple, "Impossible tant qu'une triple liaison existe (retire-la d'abord)");
// Triple désactivée seulement s'il y a déjà une double
setDisabled(tri, hasDouble, "Impossible tant qu'une double liaison existe (retire-la d'abord)");
}

function updateSubChipAvailability(){
  const isSemi = (phaseVal===2);
  document.querySelectorAll('.chip[data-dragsub], .chip[data-dragSub], .chip[data-dragsub="méthyl"], .chip[data-dragsub="éthyl"]').forEach(ch=>{
    const disabled = !isSemi;
    if(!ch.dataset.origTitle) ch.dataset.origTitle = ch.getAttribute('title') || ch.textContent.trim();
    ch.style.opacity = disabled ? '0.35' : '';
    ch.style.filter  = disabled ? 'grayscale(1)' : '';
    ch.style.cursor  = disabled ? 'not-allowed' : '';
    ch.draggable = !disabled;
    ch.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    // title: keep short
    if(disabled){
      ch.setAttribute('title', ch.dataset.origTitle + " — Disponible uniquement en représentation semi‑développée");
    }else{
      ch.setAttribute('title', ch.dataset.origTitle);
    }
    ch.classList.toggle('disabled', disabled);
  });
}


function getBondOrder(a,b){ return bondOrders.get(edgeKey(a,b)) || 1; }
function setBondOrder(a,b,ord){ bondOrders.set(edgeKey(a,b), ord); }

function carbonHydrogens(id){
  let sum = 0;
  node(id).neighbors.forEach(nb=>{ sum += getBondOrder(id, nb); });
  return Math.max(0, 4 - sum);
}

function carbonGroupText(id, mode){
  // mode: 'semi' (CH3/CH2/CH/C), 'dev' (C)
  const h = carbonHydrogens(id);
  if(mode==='dev') return "C";
  if(h===3) return "C H\u2083";
  if(h===2) return "C H\u2082";
  if(h===1) return "C H";
  return "C";
}

function formulaBrute(){
  const C = nodes.size;
  // tree with only single bonds => alkane acyclic: H = 2C + 2
  const H = 2*C + 2;
  return {C,H};
}

function formatFormulaHTML(C,H){
  return `C<sub>${C}</sub>H<sub>${H}</sub>`;
}

/* --- SVG helpers --- */
function clearSVG(){
  while(svg.firstChild) svg.removeChild(svg.firstChild);
}

function el(name, attrs={}, parent=svg){
  const e=document.createElementNS("http://www.w3.org/2000/svg", name);
  for(const [k,v] of Object.entries(attrs)) e.setAttribute(k, String(v));
  parent.appendChild(e);
  return e;
}

function textEl(x,y,txt,attrs={}){
  return el('text', Object.assign({x, y, 'text-anchor':'middle', 'dominant-baseline':'middle'}, attrs), svg).appendChild(document.createTextNode(txt)).parentNode;
}


function moleculeCentroid(){
  let sx=0, sy=0, n=0;
  for(const p of lockedPos.values()){ sx+=p.x; sy+=p.y; n++; }
  if(!n) return {x:490,y:210};
  return {x:sx/n, y:sy/n};
}


function computeLocantIds(mainPath){
  const inPath = new Set(mainPath);
  const ids = new Set();
  for(const id of mainPath){
    for(const nb of node(id).neighbors){
      if(!inPath.has(nb)){
        ids.add(id);
        break;
      }
    }
  }
  return ids;
}

function computeNumberBadgePos(id, mainPath){
  const p = lockedPos.get(id) || {x:0,y:0};
  const c = moleculeCentroid();

  // Prefer pushing numbers away from the molecule center (reduces clutter).
  let vx = p.x - c.x;
  let vy = p.y - c.y;

  // If nearly centered, use a perpendicular to local path direction.
  if(Math.hypot(vx,vy) < 1){
    const i = mainPath.indexOf(id);
    let ax=1, ay=0;
    if(i>=0){
      const prev = (i>0)? lockedPos.get(mainPath[i-1]) : null;
      const next = (i<mainPath.length-1)? lockedPos.get(mainPath[i+1]) : null;
      const refA = prev || p;
      const refB = next || p;
      ax = (refB.x - refA.x) || 1;
      ay = (refB.y - refA.y) || 0;
    }
    // perpendicular
    vx = -ay; vy = ax;
  }

  const L = Math.hypot(vx,vy) || 1;
  vx/=L; vy/=L;

  const offset = 56;
  let x = p.x + vx*offset;
  let y = p.y + vy*offset;

  // Clamp inside the viewport with margins
  x = Math.max(20, Math.min(960, x));
  y = Math.max(20, Math.min(400, y));
  return {x,y};
}

function drawNumberBadge(x,y,label){
  const g = el('g', {class:'numBadge'});
  // width roughly scales with digits
  const w = 22 + (String(label).length-1)*12;
  const h = 22;
  const rect = el('rect', {class:'numBadgeRect', x:x-w/2, y:y-h/2, width:w, height:h, rx:10, ry:10});
  const t = el('text', {class:'numBadgeText', x, y});
  t.textContent = label;
  g.appendChild(rect);
  g.appendChild(t);
  svg.appendChild(g);
  return g;
}

function drawNumbering(mainPath, numbering, pos){
  if(!showNumbers) return;
  if(!mainPath || !numbering || !numbering.num) return;

  // Numérotation = uniquement sur les carbones de la chaîne principale (les noeuds du graphe).
  // On place un petit badge légèrement décalé par rapport au carbone, dans la direction normale
  // à la chaîne principale, pour rester lisible sans masquer les liaisons.
  const idxOf = new Map();
  for(let i=0;i<mainPath.length;i++) idxOf.set(mainPath[i], i);

  for(const id of mainPath){
    const n = numbering.num.get(id);
    if(!n) continue;
    const p = pos.get(id);
    if(!p) continue;

    // Direction locale (tangente) : vers le voisin précédent/suivant de la chaîne principale.
    const i = idxOf.get(id);
    const prevId = (i>0) ? mainPath[i-1] : null;
    const nextId = (i<mainPath.length-1) ? mainPath[i+1] : null;

    let tx = 1, ty = 0;
    if(prevId!=null && nextId!=null){
      const a = pos.get(prevId), b = pos.get(nextId);
      if(a && b){
        tx = b.x - a.x; ty = b.y - a.y;
      }
    }else if(prevId!=null){
      const a = pos.get(prevId);
      if(a){ tx = p.x - a.x; ty = p.y - a.y; }
    }else if(nextId!=null){
      const b = pos.get(nextId);
      if(b){ tx = b.x - p.x; ty = b.y - p.y; }
    }

    const L = Math.hypot(tx, ty) || 1;
    tx /= L; ty /= L;

    // Normale à la chaîne
    let nx = -ty, ny = tx;

    // Choisir le côté "extérieur" quand il y a une ramification sur le carbone.
    // On regarde s'il existe un voisin hors chaîne ; si oui, on met le badge de l'autre côté.
    let hasBranch = false;
    for(const nb of node(id).neighbors){
      if(!idxOf.has(nb)){ hasBranch = true; break; }
    }
    if(hasBranch){
      // si la branche part dans le sens de la normale, on inverse pour placer le badge "à l'opposé"
      // (heuristique : comparer le vecteur vers la première branche trouvée à la normale)
      for(const nb of node(id).neighbors){
        if(idxOf.has(nb)) continue;
        const q = pos.get(nb);
        if(!q) continue;
        const bx = q.x - p.x, by = q.y - p.y;
        if((bx*nx + by*ny) > 0){ nx = -nx; ny = -ny; }
        break;
      }
    }

    const offN = 26;   // décalage normal (désaxage)
    const offT = -10;  // léger retrait le long de la chaîne
    const x = p.x + nx*offN + tx*offT;
    const y = p.y + ny*offN + ty*offT;

    drawNumberBadge(x, y, String(n));
  }
}



function line(x1,y1,x2,y2,attrs={}){
  return el('line', Object.assign({x1,y1,x2,y2}, attrs));
}


// --- padded line helpers (avoid overlapping labels like CH₂) ---
function linePadded(x1,y1,x2,y2,pad1,pad2,attrs={}){
  const dx = x2-x1, dy = y2-y1;
  const L = Math.hypot(dx,dy) || 1;
  const ux = dx/L, uy = dy/L;
  const ax1 = x1 + ux*pad1, ay1 = y1 + uy*pad1;
  const ax2 = x2 - ux*pad2, ay2 = y2 - uy*pad2;
  // If pads are too large, fallback to original line
  if(Math.hypot(ax2-ax1, ay2-ay1) < 2){
    return line(x1,y1,x2,y2,attrs);
  }
  return line(ax1,ay1,ax2,ay2,attrs);
}
    
function linePaddedMulti(x1,y1,x2,y2,padA,padB,attrs,order){
  // draw 2 or 3 parallel padded lines, offset perpendicular to the segment
  const dx = x2-x1, dy = y2-y1;
  const L = Math.hypot(dx,dy) || 1;
  const nx = -dy / L, ny = dx / L; // unit normal
  const off = 4; // pixel offset between parallel lines

  const offsets = (order===2) ? [-off, off] : (order===3 ? [-off, 0, off] : [0]);
  offsets.forEach(o=>{
    linePadded(x1 + nx*o, y1 + ny*o, x2 + nx*o, y2 + ny*o, padA, padB, attrs);
  });
}


function drawBondPadded(a,b,padA,padB,attrs={}){
  const pa = lockedPos.get(a), pb = lockedPos.get(b);
  if(!pa||!pb) return;
  const order = getBondOrder(a,b);
  const A = Object.assign({stroke:'#111','stroke-width':(order===3?2.6:4),'stroke-linecap':'round'}, attrs);
  if(order===1){
    linePadded(pa.x, pa.y, pb.x, pb.y, padA, padB, A);
  }else{
    linePaddedMulti(pa.x, pa.y, pb.x, pb.y, padA, padB, A, order);
  }
}



function drawBondPaddedShifted(a,b,padA,padB,shiftX,attrs={}){
  const pa = lockedPos.get(a), pb = lockedPos.get(b);
  if(!pa||!pb) return;
  const order = getBondOrder(a,b);
  const A = Object.assign({stroke:'#111','stroke-width':4,'stroke-linecap':'round'}, attrs);
  const x1 = pa.x + shiftX, y1 = pa.y;
  const x2 = pb.x + shiftX, y2 = pb.y;
  if(order===1){
    linePadded(x1, y1, x2, y2, padA, padB, A);
  }else{
    linePaddedMulti(x1, y1, x2, y2, padA, padB, A, order);
  }
}



function drawHighlightBondPaddedHalo(a,b,padA,padB){
  const pa = lockedPos.get(a), pb = lockedPos.get(b);
  if(!pa||!pb) return;

  // BIG stabilo background (very visible)
  linePadded(pa.x, pa.y, pb.x, pb.y, padA, padB, {
    stroke:'rgba(40,160,90,0.12)',
    'stroke-width':52,
    'stroke-linecap':'round'
  });

  // darker core to structure the stabilo
  linePadded(pa.x, pa.y, pb.x, pb.y, padA, padB, {
    stroke:'rgba(20,120,60,0.28)',
    'stroke-width':32,
    'stroke-linecap':'round'
  });
}

// padding tuned for readability
const PAD_CC_DEV  = 16;  // C–C, formule développée
const PAD_CC_SEMI = 22;  // C–C, formule semi-développée (évite CH₂/CH₃)

function drawBond(a,b,attrs={}){
  const pa = lockedPos.get(a), pb = lockedPos.get(b);
  if(!pa||!pb) return;
  line(pa.x, pa.y, pb.x, pb.y, Object.assign({stroke:'#111','stroke-width':4,'stroke-linecap':'round'}, attrs));
}

function drawHighlightBond(a,b){
  const pa = lockedPos.get(a), pb = lockedPos.get(b);
  if(!pa||!pb) return;
  line(pa.x, pa.y, pb.x, pb.y, {stroke:'rgba(20,120,60,0.28)','stroke-width':36,'stroke-linecap':'round'});
}

/* --- Rendering modes --- */
function renderDeveloped({mainPath, numbering}){
  // highlight main chain bonds (clean) — only if requested
  const inPath = new Set(mainPath);
  const mainSet = new Set(mainPath);
  if(showChain){
    for(let i=0;i<mainPath.length-1;i++){
      drawHighlightBondPaddedHalo(mainPath[i], mainPath[i+1], PAD_CC_DEV, PAD_CC_DEV);
    }
  }

  // draw C-C bonds
  const drawn = new Set();
  for(const [id, nd] of nodes.entries()){
    for(const nb of nd.neighbors){
      const k = id<nb ? id+"-"+nb : nb+"-"+id;
      if(drawn.has(k)) continue;
      drawn.add(k);
      drawBondPadded(id, nb, PAD_CC_DEV, PAD_CC_DEV, {stroke:'#111'});
    }
  }

  // draw atoms + hydrogens
  for(const [id] of nodes.entries()){
    const p = lockedPos.get(id);
    if(!p) continue;

    // carbon label
    textEl(p.x, p.y, "C", {'font-size':22, 'font-weight':700, fill:'#111'});

    const h = carbonHydrogens(id);
    // place up to 3 H on free directions (excluding neighbor directions)
    const neighDirs = new Set();
    for(const nb of node(id).neighbors){
      const q = lockedPos.get(nb);
      if(!q) continue;
      const dx = q.x - p.x, dy = q.y - p.y;
      if(Math.abs(dx) > Math.abs(dy)){
        neighDirs.add(dx>0?'right':'left');
      }else{
        neighDirs.add(dy>0?'down':'up');
      }
    }
    const slots = ['up','down','left','right'].filter(d=>!neighDirs.has(d));
    const dmap = {up:[0,-44], down:[0,44], left:[-56,0], right:[56,0]};
    
    // terminal carbons: hydrogens in gris/noir (demande "sauf aux extrémités")
    const isTerminal = node(id).neighbors.size===1;

    for(let i=0;i<h && i<slots.length;i++){
      const d=slots[i];      const [tx,ty]=dmap[d];
      linePadded(
        p.x, p.y, p.x+tx, p.y+ty,
        16, 12,
        {stroke:'var(--ch)','stroke-width':4,'stroke-linecap':'round'}
      );textEl(p.x+tx, p.y+ty, "H", {'font-size':20, 'font-weight':700, fill:'#111'});
    }
}
  // numbering ONLY on main chain
  drawNumbering(mainPath, numbering, lockedPos);
}

function renderSemi({mainPath, numbering}){
  const inPath = new Set(mainPath);
  const mainSet = new Set(mainPath);
  if(showChain){
    for(let i=0;i<mainPath.length-1;i++){
      drawHighlightBondPaddedHalo(mainPath[i], mainPath[i+1], PAD_CC_SEMI, PAD_CC_SEMI);
    }
  }

  // bonds
  const drawn = new Set();
  for(const [id, nd] of nodes.entries()){
    for(const nb of nd.neighbors){
      const k = id<nb ? id+"-"+nb : nb+"-"+id;
      if(drawn.has(k)) continue;
      drawn.add(k);
      {
        const isRadicalBond = !!(nodes.get(id)?.subKind || nodes.get(nb)?.subKind);
        if(isRadicalBond){
          // Décalage léger vers la gauche pour que la liaison du radical "pointe" mieux entre les carbones (semi‑développée)
          drawBondPaddedShifted(id, nb, PAD_CC_SEMI, PAD_CC_SEMI, -10, {stroke:'#111'});
        }else{
          drawBondPadded(id, nb, PAD_CC_SEMI, PAD_CC_SEMI, {stroke:'#111'});
        }
      }
    }
  }

  // labels CHx
  for(const [id] of nodes.entries()){
    const p=lockedPos.get(id); if(!p) continue;
    const lab = carbonGroupText(id, 'semi');
    textEl(p.x, p.y, lab, {'font-size':22, 'font-weight':800, fill:'#111'});
}
  // numbering ONLY on main chain
  drawNumbering(mainPath, numbering, lockedPos);
}

function renderSimplified({mainPath, numbering}){
  // Formule simplifiée : chaîne principale en zigzag SUR UNE SEULE LIGNE.
  // On respecte le sens de numérotation observé en semi‑développée (si possible via lockedPos):
  // si C1 est à droite en semi‑développée, il reste à droite ici.

  if(!mainPath || !mainPath.length) return;

  // Ordonner la chaîne principale selon la numérotation (1 -> n)
  const ordered = mainPath.slice().sort((a,b)=>{
    const na = numbering?.num?.get(a) ?? 0;
    const nb = numbering?.num?.get(b) ?? 0;
    return na - nb;
  });

  const n = ordered.length;
  if(n===0) return;

  // Déterminer le "côté" de C1 à partir des positions figées de la semi‑développée (si dispo)
  let c1Right = false;
  const c1 = ordered[0], cN = ordered[n-1];
  const p1 = lockedPos.get(c1);
  const pN = lockedPos.get(cN);
  if(p1 && pN) c1Right = p1.x > pN.x;

  // Dimensions / placement
  const baseY = 210;
  const dy = 50;

  // Fit horizontal inside viewBox (0..980) with margins
  const marginL = 90, marginR = 90;
  const span = 980 - marginL - marginR;
  const dx = (n<=1) ? 0 : Math.min(100, span/(n-1));

  const dir = c1Right ? -1 : 1;
  const startX = c1Right ? (980 - marginR) : marginL;

  // Positions de la chaîne principale (zigzag)
  const pos = new Map();
  for(let i=0;i<n;i++){
    const id = ordered[i];
    const x = startX + dir*i*dx;
    const y = baseY + ((i%2===0) ? -dy : dy);
    pos.set(id,{x,y});
  }

  // Helpers : tracer liaisons multiples
  function drawBond(x1,y1,x2,y2,order){
    const vx = x2-x1, vy = y2-y1;
    const L = Math.hypot(vx,vy) || 1;
    const nx = -vy/L, ny = vx/L; // normal unitaire
    const off = 6;

    const cap = {'stroke':'#111','stroke-width':5,'stroke-linecap':'round'};
    if(order===1){
      line(x1,y1,x2,y2,cap);
      return;
    }
    if(order===2){
      line(x1+nx*off,y1+ny*off,x2+nx*off,y2+ny*off,cap);
      line(x1-nx*off,y1-ny*off,x2-nx*off,y2-ny*off,cap);
      return;
    }
    // order===3
    line(x1,y1,x2,y2,cap);
    line(x1+nx*off*1.6,y1+ny*off*1.6,x2+nx*off*1.6,y2+ny*off*1.6,cap);
    line(x1-nx*off*1.6,y1-ny*off*1.6,x2-nx*off*1.6,y2-ny*off*1.6,cap);
  }

  // Tracer la chaîne principale
  for(let i=0;i<n-1;i++){
    const A = ordered[i], B = ordered[i+1];
    const a = pos.get(A), b = pos.get(B);
    const ord = getBondOrder(A,B);
    drawBond(a.x,a.y,b.x,b.y,ord);
  }

  // Tracer les substituants (traits courts qui partent de la chaîne)
  const mainSet = new Set(ordered);
  const stubLen = 70;

  for(let i=0;i<n;i++){
    const id = ordered[i];
    const p = pos.get(id);
    const neigh = [...node(id).neighbors];

    // Direction alternée des branches pour rester lisible
    const up = (i%2===0); // même alternance que le zigzag
    const sx = p.x;
    const sy = p.y;
    const ex = sx;
    const ey = sy + (up ? -stubLen : stubLen);

    for(const nb of neigh){
      if(mainSet.has(nb)) continue;

      // position du voisin : s'il a une position verrouillée, on l'utilise
      // sinon on l'accroche sur le stub
      let q = lockedPos.get(nb);
      if(!q){
        q = {x:ex, y:ey};
      }
      pos.set(nb, q);

      // liaison vers le substituant
      const ord = getBondOrder(id, nb);
      drawBond(sx,sy,q.x,q.y,ord);

      // Pour les substituants plus longs (éthyl/chaînes), on laisse la géométrie existante
      // (elles ont déjà leurs positions dans lockedPos via le placement orthogonal).
    }
  }

  // Numérotation éventuelle
  drawNumbering(ordered, numbering, pos);
}




const alkaneNames = {
  1:'méthane',2:'éthane',3:'propane',4:'butane',5:'pentane',6:'hexane',
  7:'heptane',8:'octane',9:'nonane',10:'décane',11:'undécane',12:'dodécane',
  13:'tridécane',14:'tétradécane',15:'pentadécane',16:'hexadécane'
};

const alkaneRoots = {
  1:'méth',2:'éth',3:'prop',4:'but',5:'pent',6:'hex',
  7:'hept',8:'oct',9:'non',10:'déc',11:'undéc',12:'dodéc',
  13:'tridéc',14:'tétradéc',15:'pentadéc',16:'hexadéc'
};

function multipleSuffix(type,count){
  const pref = count===1?'':(count===2?'di':count===3?'tri':count===4?'tétra':'poly');
  if(type===2) return (pref?pref:'') + 'ène';
  if(type===3) return (pref?pref:'') + 'yne';
  return 'ane';
}

function parentWithUnsaturation(n, bondInfo){
  const root = alkaneRoots[n] || String(n);
  if(!bondInfo || bondInfo.type===1) return (alkaneNames[n] || (root+'ane'));
  const t = bondInfo.type;
  const locs = bondInfo.locants || [];
  const count = locs.length || 1;
  const suf = multipleSuffix(t, count);
  // French worksheet convention shown: single -> root-<loc>-ène/yne ; multiple -> roota-<locs>-diène/diyne
  if(count===1){
    return root + '-' + (locs[0]||1) + '-' + suf;
  }
  return root + 'a-' + locs.join(',') + '-' + suf;
}



function normalizeFrenchName(s){
  return s
    .replace(/methyl/g,'méthyl')
    .replace(/ethyl/g,'éthyl')
    .replace(/decane/g,'décane')
    .replace(/undecane/g,'undécane')
    .replace(/dodecane/g,'dodécane')
    .replace(/tridecane/g,'tridécane')
    .replace(/tetradecane/g,'tétradécane')
    .replace(/pentadecane/g,'pentadécane')
    .replace(/hexadecane/g,'hexadécane')
    .replace(/methane/g,'méthane')
    .replace(/ethane/g,'éthane');
}


function alphaKey(s){
  // Accent-insensitive alphabetical key (French classroom convention)
  return (s||'')
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g,''); // strip accents
}

function moleculeName(mainPath, numbering){
  // Substituants sur la chaîne principale
  const subs = {};
  mainPath.forEach(id=>{
    const pos = numbering.num.get(id);
    node(id).neighbors.forEach(nb=>{
      if(mainPath.includes(nb)) return;
      // longueur du substituant : on compte les carbones hors chaîne principale (branche)
      // (plus robuste qu'un simple "méthyl/éthyl" : marche aussi si la branche s'allonge)
      let len = 0;
      const seen = new Set([id]); // ne jamais repasser par le carbone porteur
      const stack = [nb];
      while(stack.length){
        const u = stack.pop();
        if(seen.has(u)) continue;
        seen.add(u);
        if(!mainPath.includes(u)) len++;
        for(const v of node(u).neighbors){
          if(!seen.has(v) && !mainPath.includes(v)) stack.push(v);
        }
      }
const sname = (len===1)?'méthyl':'éthyl';
      if(!subs[sname]) subs[sname]=[];
      subs[sname].push(pos);
    });
  });

  // Parties "radicaux" par ordre alphabétique (accents ignorés), préfixes di/tri... n'influencent pas
  // Règle (IUPAC / usage scolaire) : on n'affiche pas de locant lorsqu'il est redondant (une seule possibilité).
  // Ex: propane -> "méthylpropane" (pas "2-méthylpropane").
  const parts = [];

  const parentLen = mainPath.length;
  const hasMultipleBond = (numbering?.bond?.type ?? 1) !== 1;

  // total d'occurrences de substituants (tous types confondus)
  const totalOccurrences = Object.values(subs).reduce((acc, arr)=>acc + (arr?.length||0), 0);

  function locantIsRedundantForSingle(pos){
    // méthane/éthane : jamais de locant utile
    if(parentLen<=2) return true;

    // Si la chaîne porte une insaturation, le locant peut être utile pour d'autres règles;
    // on ne le retire pas ici.
    if(hasMultipleBond) return false;

    // On ne retire les locants que s'il n'y a qu'UN seul substituant au total
    // (sinon ils servent à distinguer les positions relatives).
    if(totalOccurrences!==1) return false;

    // Cas demandé explicitement : propane (position unique -> on omet toujours le chiffre)
    if(parentLen===3) return true;

    // Symétrie simple de chaîne linéaire : position centrale d'une chaîne impaire (ex: 3 sur 5)
    if(parentLen%2===1 && pos === (parentLen+1)/2) return true;

    return false;
  }

  Object.keys(subs)
    .sort((a,b)=>alphaKey(a).localeCompare(alphaKey(b)))
    .forEach(nm=>{
      const loc = subs[nm].sort((a,b)=>a-b);
      const c = loc.length;
      const pref = c===1?'':(c===2?'di':c===3?'tri':c===4?'tétra':'poly');

      if(c===1 && locantIsRedundantForSingle(loc[0])){
        // ex: "méthylpropane"
        parts.push(pref + nm);
      }else{
        parts.push(loc.join(',')+'-'+pref+nm);
      }
    });

  // Chaîne principale + insaturation(s)
  const parent = parentWithUnsaturation(mainPath.length, numbering.bond);

  // Assemblage : pas de tiret entre radical et chaîne, mais tirets internes conservés
  const full = (parts.length ? parts.join('-') : '') + parent;

  return normalizeFrenchName(full);
}




// --- Undo support ---
const undoStack = [];

function snapshotState(){
  return JSON.stringify({
    nodes: Array.from(nodes.entries()).map(([k,v])=>[k,{neighbors:Array.from(v.neighbors)}]),
    lockedPos: Array.from(lockedPos.entries()),
    phaseVal,
    showChain,
    showNumbers
  });
}

function restoreState(snap){
  const s = JSON.parse(snap);
  nodes.clear();
  s.nodes.forEach(([k,v])=>{
    nodes.set(k,{neighbors:new Set(v.neighbors)});
  });
  lockedPos.clear();
  s.lockedPos.forEach(([k,v])=>lockedPos.set(k,v));
  phaseVal = s.phaseVal;
  showChain = s.showChain;
  showNumbers = s.showNumbers;
  render();
}

function pushUndo(){
  undoStack.push(snapshotState());
  if(undoStack.length>50) undoStack.shift();
}



/* --- Render orchestrator --- */
function setPhaseText(){
  const labels = ["Formule brute","Formule développée","Formule semi-développée","Formule simplifiée"];
  phaseTxt.textContent = labels[phaseVal] || "";
}

function updateNumberingAvailability(){
  const ok = (phaseVal===2); // numérotation autorisée uniquement en formule semi-développée
  if(!ok){
    showNumbers = false;
    setToggle(toggleNumbers, false);
    toggleNumbers.setAttribute('aria-pressed','false');
    toggleNumbers.disabled = true;
    toggleNumbers.title = "La numérotation n'est disponible qu'en formule semi-développée";
  }else{
    toggleNumbers.disabled = false;
    toggleNumbers.title = "Afficher la numérotation (uniquement en formule semi-développée)";
  }
}



function renderBrute(){
  const fb = formulaBrute();
  const cx = 490, cy = 210;

  // Typo: CₙHₘ (indices alignés, espacement basé sur les largeurs réelles)
  const mainSize = 72;
  const subSize  = 36;
  const subDy    = 28;
  const gap      = 6;   // petit espace optique entre n et H

  // point de départ
  const cX = cx - 190;

  // C
  const cT = textEl(cX, cy, "C", {'font-size':mainSize, 'font-weight':900, fill:'#111'});

  // indice n
  const nStr = String(fb.C);
  const nX = cX + 0.68*mainSize; // placement proche de la lettre
  const nT = textEl(nX, cy + subDy, nStr, {'font-size':subSize, 'font-weight':800, fill:'#111'});

  // H juste après l'indice (mesure exacte via getBBox)
  const nBB = nT.getBBox();
  const hX = nBB.x + nBB.width + gap + 0.20*mainSize;
  const hT = textEl(hX, cy, "H", {'font-size':mainSize, 'font-weight':900, fill:'#111'});

  // indice m
  const mStr = String(fb.H);
  const mX = hX + 0.68*mainSize;
  textEl(mX, cy + subDy, mStr, {'font-size':subSize, 'font-weight':800, fill:'#111'});
}


function render(){
  setPhaseText();
  updateNumberingAvailability();
  // sync toggle button visuals
  setToggle(toggleChain, showChain);
  setToggle(toggleNumbers, showNumbers);
  clearSVG();

  const fb = formulaBrute();
  countTxt.textContent = String(fb.C);
  countPill.textContent = `C${fb.C}`;

  const mainPath = bestMainChain();
  const numbering = chooseNumbering(mainPath);

  // Nom IUPAC (alcanes + méthyl/éthyl)
  try{
    const nm = moleculeName(mainPath, numbering);
    const elName = document.getElementById('molName');
    if(elName) elName.textContent = 'Nom : ' + nm;
  }catch(e){
    const elName = document.getElementById('molName');
    if(elName) elName.textContent = '';
  }

  // Summary
  badge.textContent = `Chaîne principale: ${mainPath.length} C`;
  const loc = numbering.substituents.length ? numbering.substituents.join(", ") : "—";
  summary.textContent = `C${fb.C}H${fb.H} • Locants: ${loc}`;

  // Brute modal
  bruteBig.innerHTML = formatFormulaHTML(fb.C, fb.H);

  if(phaseVal===0){ renderBrute(); return; }

  if(phaseVal===1) renderDeveloped({mainPath, numbering});
  else if(phaseVal===2) renderSemi({mainPath, numbering});
  else renderSimplified({mainPath, numbering});
}

function renderAnimated(){
  try{ updateLimitUI(); }catch(e){}

  svg.classList.add('switching');
  if(animTimer) clearTimeout(animTimer);
  animTimer = setTimeout(()=>{
    render();
    try{ updateBondChipAvailability(); }catch(e){}
requestAnimationFrame(()=> svg.classList.remove('switching'));
  }, 160);
}

/* --- UI wiring --- */
function clampN(v){ return Math.max(1, Math.min(14, v|0)); }

document.querySelectorAll('.tickBtn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    // Blocage: si la "Formule simplifiée" est désactivée (présence de substituants), on ignore le clic.
    if(btn.getAttribute('aria-disabled')==='true'){
      btn.classList.remove('shake'); void btn.offsetWidth; btn.classList.add('shake');
      return;
    }

    phaseVal = parseInt(btn.dataset.i,10) || 0;
    document.querySelectorAll('.tickBtn').forEach(b=>{
      const active = (b===btn);
      b.classList.toggle('active', active);
      b.setAttribute('aria-checked', active ? 'true':'false');
    });
    updateBondChips();
    renderAnimated();
  });
});


function updateBondChips(){
  const on = (phaseVal===2);
  document.querySelectorAll('.bondChip').forEach(ch=>{
    ch.classList.toggle('disabled', !on);
    ch.setAttribute('draggable', on ? 'true' : 'false');
  });
}

/* --- Toggle helpers --- */
function setToggle(btn, on){
  btn.setAttribute('aria-pressed', on ? 'true' : 'false');
  btn.classList.toggle('on', on);
}

toggleChain.addEventListener('click', ()=>{
  showChain = !showChain;
  setToggle(toggleChain, showChain);
  renderAnimated();
});

toggleNumbers.addEventListener('click', ()=>{
  if(toggleNumbers.disabled || phaseVal!==2){
    toggleNumbers.classList.remove('shake');
    void toggleNumbers.offsetWidth;
    toggleNumbers.classList.add('shake');
    return;
  }
  showNumbers = !showNumbers;
  setToggle(toggleNumbers, showNumbers);
  renderAnimated();
});
// Flip logique (inversion de la chaîne) — uniquement en semi‑développée
flipLogicBtn.addEventListener('click', ()=>{
  if(flipLogicBtn.disabled || phaseVal!==2){
    flipLogicBtn.classList.add('shake');
    clearTimeout(flipLogicBtn._shakeT);
    flipLogicBtn._shakeT = setTimeout(()=>flipLogicBtn.classList.remove('shake'), 260);
    return;
  }
  chainFlipped = !chainFlipped;
  flipLogicBtn.setAttribute('aria-pressed', chainFlipped ? 'true' : 'false');
  flipMainChain();
  renderAnimated();
});




/* --- Drag & Drop: attach to nearest BASE carbon only --- */
let dragSub = null;
let dragBond = null;
let hoverTarget = null;
let hoverRing = null;

function clearHoverRing(){
  if(hoverRing){ hoverRing.remove(); hoverRing=null; }
  hoverTarget = null;
}


function showHoverAtom(id){
  const p = lockedPos.get(id);
  if(!p) return;
  const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
  c.setAttribute('cx', p.x); c.setAttribute('cy', p.y);
  c.setAttribute('r', 18);
  c.setAttribute('fill', 'none');
  c.setAttribute('stroke', 'rgba(60,120,255,0.6)');
  c.setAttribute('stroke-width', 4);
  c.classList.add('hoverRing');
  svg.appendChild(c);
}
function showHoverBond(a,b){
  const pa = lockedPos.get(a), pb = lockedPos.get(b);
  if(!pa || !pb) return;
  const mx = (pa.x+pb.x)/2, my = (pa.y+pb.y)/2;
  const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
  c.setAttribute('cx', mx); c.setAttribute('cy', my);
  c.setAttribute('r', 16);
  c.setAttribute('fill', 'none');
  c.setAttribute('stroke', 'rgba(60,120,255,0.6)');
  c.setAttribute('stroke-width', 4);
  c.classList.add('hoverRing');
  svg.appendChild(c);
}


function showRingOn(id){
  const p = lockedPos.get(id);
  if(!p) return;
  if(hoverRing) hoverRing.remove();
  hoverRing = el('circle', {cx:p.x, cy:p.y, r:18, fill:'none', stroke:'var(--accent)', 'stroke-width':4, opacity:.9});
}

function svgPointFromEvent(e){
  const pt = svg.createSVGPoint();
  pt.x = e.clientX;
  pt.y = e.clientY;
  const ctm = svg.getScreenCTM();
  if(!ctm) return {x:0,y:0};
  const inv = ctm.inverse();
  const sp = pt.matrixTransform(inv);
  return {x:sp.x, y:sp.y};
}

function nearestBaseCarbon(x,y){
  // NOTE: despite the legacy name, we now allow targeting ANY carbon (main chain or substituent),
  // as long as it has a locked position.
  let best=null, bestD=Infinity;
  for(const [id, nd] of nodes){
    const p=lockedPos.get(id); if(!p) continue;
    const dx=p.x-x, dy=p.y-y;
    const d=dx*dx+dy*dy;
    if(d<bestD){ bestD=d; best=id; }
  }
  return {id:best, d2:bestD};
}

function distPointToSegment(px,py, ax,ay, bx,by){
  const vx = bx-ax, vy = by-ay;
  const wx = px-ax, wy = py-ay;
  const c1 = vx*wx + vy*wy;
  if(c1<=0) return (px-ax)**2 + (py-ay)**2;
  const c2 = vx*vx + vy*vy;
  if(c2<=c1) return (px-bx)**2 + (py-by)**2;
  const t = c1 / c2;
  const projx = ax + t*vx, projy = ay + t*vy;
  return (px-projx)**2 + (py-projy)**2;
}

function nearestBond(px,py){
  let best = {a:null,b:null,d2:Infinity};
  const seen = new Set();
  for(const [id, nd] of nodes.entries()){
    const p = lockedPos.get(id); if(!p) continue;
    for(const nb of nd.neighbors){
      const key = edgeKey(id, nb);
      if(seen.has(key)) continue;
      seen.add(key);
      const q = lockedPos.get(nb); if(!q) continue;
      const d2 = distPointToSegment(px,py, p.x,p.y, q.x,q.y);
      if(d2 < best.d2) best = {a:id,b:nb,d2};
    }
  }
  return best;
}

function canIncreaseBond(a,b,delta){
  return carbonHydrogens(a) >= delta && carbonHydrogens(b) >= delta;
}

function applyBondOrder(a,b,newOrder){
  if(phaseVal !== 2) return false; // only semi-développée

  // Règle: on n'autorise pas double ET triple dans la même molécule.
  // Si une double liaison existe, la triple est interdite (et inversement).
  const cur = getBondOrder(a,b);
  if(newOrder===3){
    const hasDouble = hasAnyBondOrder(2);
    if(hasDouble && cur!==3) return false;
  }
  if(newOrder===2){
    const hasTriple = hasAnyBondOrder(3);
    if(hasTriple && cur!==2) return false;
  }

  const target = (cur===newOrder) ? 1 : newOrder; // toggle off if same
  const delta = target - cur;
  if(delta>0 && !canIncreaseBond(a,b,delta)) return false;

  setBondOrder(a,b,target);
  updateBondChipAvailability();
  return true;
}



svg.addEventListener('dragover', (e)=>{
  e.preventDefault();
  const dt = e.dataTransfer;
  if(dt) dt.dropEffect = 'copy';
  const {x,y}=svgPointFromEvent(e);
  clearHoverRing();

  if(dragBond){
    const bb = nearestBond(x,y);
    if(bb.a!=null && bb.d2 < (22*22)){
      showHoverBond(bb.a, bb.b);
    }
    return;
  }

  const n = nearestBaseCarbon(x,y);
  if(!dragSub || n.id==null || n.d2>(140*140)) return;
  showHoverAtom(n.id);
});


svg.addEventListener('drop', (e)=>{
  e.preventDefault();
  const {x,y}=svgPointFromEvent(e);
  clearHoverRing();

  // Bond mode (double/triple): drop onto a liaison
  if(dragBond){
    if(phaseVal!==2) return;
    const bb = nearestBond(x,y);
    if(bb.a!=null && bb.d2 < (22*22)){
      const okBond = applyBondOrder(bb.a, bb.b, dragBond);
      if(okBond) renderAnimated();
    }
    return;
  }

  // Substituent mode: drop onto a carbone
  if(phaseVal!==2) return;
  const n = nearestBaseCarbon(x,y);
  if(!dragSub || n.id==null || n.d2>(140*140)) return;

  let ok=false;
  if(dragSub==='méthyl') ok = attachMéthyl(n.id);
  if(dragSub==='éthyl') ok = attachÉthyl(n.id);
  if(ok) renderAnimated();
});


document.querySelectorAll('.chip[draggable="true"]').forEach(ch=>{
  ch.addEventListener('dragstart', (e)=>{
    if(ch.getAttribute('aria-disabled')==='true'){ e.preventDefault(); return; }

    dragSub = ch.getAttribute('data-dragSub') || ch.getAttribute('data-dragsub') || ch.dataset.dragsub || ch.dataset.dragSub || null;
    dragBond = ch.dataset.bond ? parseInt(ch.dataset.bond,10) : null;
    if(e.dataTransfer){
      e.dataTransfer.setData('text/plain', dragSub || '');
      e.dataTransfer.effectAllowed = 'copy';
    }
  });
  ch.addEventListener('dragend', ()=>{ dragSub=null; dragBond=null; });
});


/* =========================================================
   Mode "sélection → tap" (mobile-friendly)
   - Tap sur un chip (méthyl / éthyl / ═ / ≡) = sélection
   - Tap sur la molécule = applique sur carbone (substituant) ou liaison (double/triple)
   - Compatible PC (clic) + mobile (tap). Le drag&drop reste actif sur PC.
   ========================================================= */

const tapHint = document.getElementById('tapHint');
const tapHintText = document.getElementById('tapHintText');

let selectedTool = null; // {kind:'sub'|'bond', value:'méthyl'|'éthyl'|2|3}

function isTouchDevice(){
  return (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || window.matchMedia?.('(pointer: coarse)').matches;
}

function setHint(msg, show=true){
  if(!tapHint || !tapHintText) return;
  tapHintText.textContent = msg;
  tapHint.classList.toggle('show', !!show);
}

function clearSelectedTool(){
  selectedTool = null;
  document.querySelectorAll('.chip').forEach(ch=>ch.classList.remove('selected'));
  if(isTouchDevice()) setHint("Mode tactile : sélectionne un outil puis tape sur la molécule.", true);
  else setHint("", false);
}

function setSelectedChip(ch, tool){
  // Toggle selection
  const already = ch.classList.contains('selected');
  document.querySelectorAll('.chip').forEach(x=>x.classList.remove('selected'));
  if(already){
    clearSelectedTool();
    return;
  }
  ch.classList.add('selected');
  selectedTool = tool;

  // Contextual hint
  if(tool.kind==='sub'){
    setHint(`Outil sélectionné : ${tool.value}. Tape sur un carbone pour l'ajouter.`, true);
  }else{
    const sym = tool.value===2 ? '═' : '≡';
    setHint(`Outil sélectionné : ${sym}. Tape sur une liaison pour (dé)poser la liaison.`, true);
  }
}

// Make chips clickable (without breaking drag&drop)
document.querySelectorAll('.chip').forEach(ch=>{
  ch.addEventListener('click', (e)=>{
    // If disabled (by aria), ignore
    if(ch.getAttribute('aria-disabled')==='true' || ch.classList.contains('disabled')) return;

    const sub = ch.getAttribute('data-dragSub') || ch.getAttribute('data-dragsub') || ch.dataset.dragsub || ch.dataset.dragSub || null;
    const bond = ch.dataset.bond ? parseInt(ch.dataset.bond,10) : null;

    if(sub){
      setSelectedChip(ch, {kind:'sub', value:sub});
    }else if(bond){
      setSelectedChip(ch, {kind:'bond', value:bond});
    }
  }, {passive:true});
});

// Apply on tap/click on SVG
svg.addEventListener('click', (e)=>{
  if(!selectedTool) return;

  // same rules as drag: only in semi-développée
  if(phaseVal !== 2){
    // Small shake hint
    setHint("Disponible uniquement en représentation semi‑développée.", true);
    // Visual shake on the warning (optional)
    const warnBtn = document.querySelector('.tickBtn[data-i="2"]');
    if(warnBtn){ warnBtn.classList.remove('shake'); void warnBtn.offsetWidth; warnBtn.classList.add('shake'); }
    return;
  }

  const {x,y} = svgPointFromEvent(e);

  if(selectedTool.kind==='bond'){
    const bb = nearestBond(x,y);
    if(bb.a!=null && bb.d2 < (22*22)){
      const ok = applyBondOrder(bb.a, bb.b, selectedTool.value);
      if(ok){
        renderAnimated();
        clearSelectedTool();
      }else{
        setHint("Impossible ici (règle de valence ou exclusivité double/triple).", true);
      }
    }else{
      setHint("Tape plus près d'une liaison.", true);
    }
    return;
  }

  // substituent
  const n = nearestBaseCarbon(x,y);
  if(n.id==null || n.d2>(140*140)){
    setHint("Tape plus près d'un carbone.", true);
    return;
  }

  let ok=false;
  if(selectedTool.value==='méthyl') ok = attachMéthyl(n.id);
  if(selectedTool.value==='éthyl') ok = attachÉthyl(n.id);

  if(ok){
    renderAnimated();
    clearSelectedTool();
  }else{
    setHint("Impossible sur ce carbone (valence).", true);
  }
});

// Keep hints in sync with device type
if(isTouchDevice()){
  setHint("Mode tactile : sélectionne un outil puis tape sur la molécule.", true);
}else{
  setHint("", false);
}

// When UI disables chips (change of phase), clear selection if needed
const _oldUpdateLimitUI = updateLimitUI;
updateLimitUI = function(){
  try{ _oldUpdateLimitUI(); }catch(e){}
  // if selected tool becomes disabled by phase change, clear it
  if(selectedTool){
    const selectedChip = document.querySelector('.chip.selected');
    if(!selectedChip || selectedChip.getAttribute('aria-disabled')==='true' || selectedChip.classList.contains('disabled')){
      clearSelectedTool();
    }
  }
};


eraseOne.addEventListener('click', ()=>{ resetToStart(); });

resetBtn.addEventListener('click', ()=>{
  resetGraph(clampN(parseInt(nC.value,10)));
  renderAnimated();
});

nC.addEventListener('input', ()=>{
  resetGraph(clampN(parseInt(nC.value,10)));
  renderAnimated();
});


window.addEventListener('keydown', (e)=>{
  if(e.key==='ArrowRight'){
    phaseVal = Math.min(3, phaseVal+1);
    // Empêche d'aller en formule simplifiée si elle est grisée
    if(phaseVal===3 && (document.querySelector('.tickBtn[data-i="3"]')?.getAttribute('aria-disabled')==='true')){
      const b3 = document.querySelector('.tickBtn[data-i="3"]');
      if(b3){ b3.classList.remove('shake'); void b3.offsetWidth; b3.classList.add('shake'); }
      phaseVal = 2;
    }
    document.querySelectorAll('.tickBtn').forEach(b=>{
      b.classList.toggle('active', (parseInt(b.dataset.i,10)===phaseVal));
      b.setAttribute('aria-checked', (parseInt(b.dataset.i,10)===phaseVal) ? 'true':'false');
    });
    renderAnimated();
  }
  if(e.key==='ArrowLeft'){
    phaseVal = Math.max(0, phaseVal-1);
    document.querySelectorAll('.tickBtn').forEach(b=>{
      b.classList.toggle('active', (parseInt(b.dataset.i,10)===phaseVal));
      b.setAttribute('aria-checked', (parseInt(b.dataset.i,10)===phaseVal) ? 'true':'false');
    });
    renderAnimated();
  }
});

// init
resetGraph(clampN(parseInt(nC.value,10)));
setPhaseText();
try{ updateSimplifiedAvailability(); }catch(e){}
// sync radio buttons UI to current phaseVal
document.querySelectorAll('.tickBtn').forEach(b=>{
  const active = (parseInt(b.dataset.i,10)===phaseVal);
  b.classList.toggle('active', active);
  b.setAttribute('aria-checked', active ? 'true':'false');
});
render();


</script>
</body>
</html>


// Init: état des boutons liaisons multiples
try{ updateBondChipAvailability(); }catch(e){}
