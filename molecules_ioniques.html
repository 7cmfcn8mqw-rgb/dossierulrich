<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jeu d'ions ‚Äî cations & anions glissables (v2.10 ‚Äî slot4 bas, slot3 plus haut)</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121a36;
      --panel-2: #0f1630;
      --text: #eef2ff;
      --muted: #97a0c3;
      --ion-pos: rgba(255,120,120,0.95);
      --ion-neg: rgba(120,190,255,0.95);
      --ion-glass: rgba(255,255,255,0.06);
      --ion-glow:  rgba(255,255,255,0.10);
    }
    html, body { height:100%; color:var(--text) !important;}
    body {
      margin:0; font-family:system-ui, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 700px at 70% -10%, #1a2455 0%, var(--bg) 60%);
      color: var(--text);
    }
    .app { max-width:1100px; margin:24px auto; padding:20px; }
    .title { font-size:28px; font-weight:800; color:var(--text); }
    .subtitle { color:var(--muted); margin-top:6px; }
    .panel { background:linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%); border:1px solid rgba(255,255,255,.08); border-radius:18px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25); color:var(--text); }
    .grid { display:grid; grid-template-columns:1.1fr .9fr; gap:16px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; color:var(--text); }
    .btn {
      background:#1d2b66;
      border:1px solid rgba(255,255,255,.1);
      color:white;
      padding:10px 14px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
    }
    select {
      background: #0f1738;
      color: var(--text);
      border-radius: 10px;
      padding: 14px 16px;
      font-size: 18px;
      border: 1px solid rgba(255,255,255, .12);
      min-width: 280px;
    }
    .area { position:relative; height:420px; overflow:hidden; border-radius:14px; }
    .space { position:absolute; inset:0; background: radial-gradient(700px 300px at 40% 0%, rgba(255,255,255,.06), rgba(255,255,255,0) 55%); }
    .center {
      position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
      width:180px; height:180px; border-radius:50%;
      display:grid; place-items:center; color:var(--muted);
      font-weight:800; font-size:13px; text-align:center; padding:12px;
      border:none; background:none;
    }
    .ion{
      position:absolute; display:inline-flex; align-items:center; justify-content:center;
      width:76px; height:76px; border-radius:50%;
      user-select:none; cursor:grab;
      box-shadow:0 4px 18px rgba(0,0,0,0.25), inset 0 0 20px var(--ion-glow);
      background: var(--ion-glass);
      border:2px solid rgba(255,255,255,0.85);
      transition: transform .28s cubic-bezier(.2,.7,.2,1);
      transform-origin: 50% 50%;
      color:#e9f0ff;
      font-weight:700;
    }
    .ion.cation{ border-color: var(--ion-pos); }
    .ion.anion { border-color: var(--ion-neg); }
    .ion.fixed { cursor:default !important; box-shadow:0 4px 12px rgba(0,0,0,.25); }
    .ion-face, .ion-face * { color:#e9f0ff !important; }
    .ion-face { display:grid; grid-template-columns:18px 1fr 18px; align-items:center; gap:4px; }
    .col { display:flex; flex-direction:column; align-items:center; line-height:1; font-weight:900; }
    .col .sign { font-size:16px; transform:translateY(-1px); }
    .core { font-size:20px; font-weight:800; color:#e9f0ff; }
    .tray { display:grid; grid-template-columns:repeat(6, 76px); gap:10px; margin-top:10px; }
    .spawn{
      position:relative;
      width:76px; height:76px; border-radius:50%;
      display:grid; place-items:center; cursor:grab; overflow:hidden;
      box-shadow:0 4px 18px rgba(0,0,0,0.25), inset 0 0 20px var(--ion-glow);
      background: var(--ion-glass);
      border:2px solid rgba(255,255,255,0.85);
      color:#e9f0ff;
    }
    .spawn.cation{ border-color: var(--ion-pos); }
    .spawn.anion { border-color: var(--ion-neg); }
    .spawn.disabled { pointer-events:none; opacity:.5; filter:saturate(0.2); }
    .spawn .spawn-label { display:none; }
    .spawn .ion-face { pointer-events:none; }
    .info { color:var(--muted); font-size:12px; margin-top:6px; }
    .version-box { position: fixed; top: 10px; right: 10px; border: 1px solid #fff; padding: 4px 6px; font-size: 8px; line-height: 1.2; background: rgba(0,0,0,0.4); border-radius: 4px; text-align: center; color:#fff;}
    #zoneJeu { position:absolute; inset:0; }
    #trashBin{
      position:absolute;
      left:8px;
      bottom:8px;
      width:72px;
      height:72px;
      opacity:0.85;
      user-select:none;
      pointer-events:none;
    }
    #trashBin .trashIcon{
      width:100%;
      height:100%;
      display:block;
    }
    #trashBin .trashIcon path{
      fill:#777;
      transition: fill .15s ease;
    }
    #trashBin.highlight{
      opacity:1;
      filter: drop-shadow(0 0 6px rgba(0,0,0,0.4));
      transform: scale(1.05);
    }
    #trashBin.highlight .trashIcon path{
      fill:#444;
    }

    #moleculeHalo{
      position:absolute;
      pointer-events:none;
      z-index:2000;
      border-radius:28px;
      border:10px solid rgba(0, 210, 120, 0.98);
      background: radial-gradient(ellipse at center, rgba(0,210,120,0.18) 0%, rgba(0,210,120,0.00) 100%);
      box-shadow:
        0 0 24px rgba(0,210,120,0.95),
        0 0 60px rgba(0,210,120,0.65),
        0 0 100px rgba(0,210,120,0.45),
        inset 0 0 22px rgba(0,210,120,0.55);
      opacity:0;
      transform: scale(0.97);
    }
    #moleculeHalo.show{
      animation: haloPulse 700ms ease-in-out infinite alternate, haloAppear 180ms ease-out forwards;
    }
    @keyframes haloAppear{ from { opacity: 0; } to { opacity: 1; } }
    @keyframes haloPulse{
      0% { opacity: 0.55; transform: scale(0.97); }
      100% { opacity: 1.0; transform: scale(1.00); }
    }

    /* Overlay Dissociation */
    #overlayDissoc{position:fixed;inset:0;display:none;z-index:9999;}
    #overlayDissoc .ovl-backdrop{position:absolute;inset:0;background:rgba(0,0,0,0.35);backdrop-filter:saturate(140%) blur(6px);}
    #overlayDissoc .ovl-stage{
      position:absolute;inset:6% 5%;
      background:#0b0e14;
      border:2px solid rgba(200,220,255,0.35);
      border-radius:16px;
      box-shadow:0 16px 60px rgba(0,0,0,0.45);
      overflow:hidden;
      color:#e9f0ff;
    }
    #overlayDissoc .ovl-topbar{
      position:absolute;left:0;right:0;top:0;height:56px;
      display:flex;align-items:center;justify-content:space-between;
      padding:0 16px;background:rgba(10,14,22,0.7);
      border-bottom:1px solid rgba(180,200,255,0.2);z-index:5
    }
    #overlayDissoc .ovl-title{font-weight:600;color:#e9f0ff;letter-spacing:.2px}
    #overlayDissoc .btn{
      appearance:none;border:1px solid rgba(200,220,255,0.35);
      background:#121725;padding:8px 12px;border-radius:10px;
      color:#e9f0ff;cursor:pointer
    }
    #overlayDissoc .btn:hover{

.btn[disabled], .btn.disabled {
  background: #660000;
  border: 1px solid #aa3333;
  color: #fff;
  opacity: 1;
  cursor: not-allowed;
  pointer-events: none;
}



background:#192033}
    #ovl-canvas{position:absolute;left:0;right:0;top:56px;bottom:0;overflow:hidden;}
    #becherWrap{
      position:absolute;
      left:50%;top:54%;
      transform:translate(-50%,-50%);
      width:min(900px,80vw);
      height:min(600px,72vh);
      pointer-events:none;
    }
    #becher {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 0;
      width: 68%;
      height: 86%;
      border-left: 3px solid rgba(220,230,255,0.8);
      border-right: 3px solid rgba(220,230,255,0.8);
      border-bottom: 3px solid rgba(220,230,255,0.8);
      border-bottom-left-radius: 15px;
      border-bottom-right-radius: 15px;
      background: linear-gradient(
        180deg,
        rgba(255,255,255,0.04) 0%,
        rgba(180,200,255,0.05) 40%,
        rgba(100,130,255,0.08) 100%
      );
      box-shadow:
        inset 0 0 30px rgba(255,255,255,0.06),
        inset 0 -10px 20px rgba(0,0,60,0.25),
        0 2px 14px rgba(0,0,0,0.3);
      backdrop-filter: blur(2px);
    }
    #becher .water {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 62%;
      background: linear-gradient(
        180deg,
        rgba(120,170,255,0.25),
        rgba(60,130,255,0.45)
      );
      border-bottom-left-radius: 15px;
      border-bottom-right-radius: 15px;
      border-top: 4px solid rgba(100,150,255,0.9);
      box-shadow:
        inset 0 8px 12px rgba(255,255,255,0.15),
        0 -2px 8px rgba(0,0,80,0.25);
    }

    .ovl-ion{
/* Taille r√©duite des ions dans l'eau (centr√©es et √† 25%) */
.ovl-ion, .freeIon {
  transform: translate(-50%, -50%) scale(0.25);
  transform-origin: center center;
}

      position:absolute;
      width:76px;height:76px;border-radius:50%;
      display:flex;align-items:center;justify-content:center;
      font-weight:700;
      box-shadow:0 4px 18px rgba(0,0,0,0.25), inset 0 0 20px rgba(255,255,255,0.08);
      background:rgba(255,255,255,0.06);
      border:2px solid rgba(255,255,255,0.85);
      color:#e9f0ff;
    }
    .ovl-ion.pos{border-color:var(--ion-pos);}
    .ovl-ion.neg{border-color:var(--ion-neg);}

    #chargeGauge {
      position: fixed;
      right: 12px;
      bottom: 60px;
      width: 160px;
      height: 120px;
      z-index: 5000;
      user-select: none;
      pointer-events: none;
      display: grid;
      grid-template-rows: auto 38px;
      gap: 8px;
    }
    #chargeGauge .gaugeCard {
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.35);
      padding: 12px;
    }
    #chargeGauge svg { width: 100%; height: 78px; overflow: visible; }
    #chargeGauge .label {
      background: rgba(16,24,58,0.85);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      padding: 8px 12px;
      font-weight: 800;
      font-size: 15px;
      color: #eef2ff;
      text-align: center;
    }
    #chargeGauge .ok {
      animation: cg-blink 600ms ease-in-out 1;
      box-shadow: 0 0 0 0 rgba(59,209,111,0.6);
    }
    @keyframes cg-blink {
      0% { box-shadow: 0 0 0 0 rgba(59,209,111,0.0); }
      100% { box-shadow: 0 0 12px 7px rgba(59,209,111,0.45); }
    }
  
/* --- l√©ger fr√©missement thermique des ions dans l'eau --- */
.wiggle {
  animation: ionWiggle 1.8s ease-in-out infinite;
}
@keyframes ionWiggle {
  0%   { transform: translate(0px, 0px); }
  25%  { transform: translate(2px, -1px); }
  50%  { transform: translate(-2px, 1px); }
  75%  { transform: translate(1px, 2px); }
  100% { transform: translate(0px, 0px); }
}


/* --- Mode paysage (mobile/tablette) : iOS/Android ---
   On ne peut pas forcer l'orientation, mais on affiche un √©cran demandant le paysage
   (compatible Safari + "Sur l'√©cran d'accueil"). */
.landscapeOnlyMsg{
  display:none;
  position:fixed;
  inset:0;
  z-index:100000;
  background:rgba(255,255,255,0.96);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  padding:24px;
  box-sizing:border-box;
  text-align:center;
}
.landscapeOnlyMsg .box{
  max-width:520px;
  margin:0 auto;
  border:1px solid rgba(0,0,0,0.12);
  border-radius:18px;
  background:#fff;
  box-shadow: 0 10px 30px rgba(0,0,0,.10);
  padding:18px 16px;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
}
.landscapeOnlyMsg .icon{ font-size:44px; line-height:1; margin-bottom:10px; }
.landscapeOnlyMsg .title{ font-size:18px; font-weight:900; margin-bottom:6px; }
.landscapeOnlyMsg .txt{ font-size:14px; color:#333; line-height:1.35; }
html.isPortrait .landscapeOnlyMsg{
  display:flex;
  align-items:center;
  justify-content:center;
}

</style>
</head>
<body>

  <!-- Message mode portrait (t√©l√©phone/tablette) -->
  <div class="landscapeOnlyMsg" aria-live="polite">
    <div class="box">
      <div class="icon">üîÑ</div>
      <div class="title">Passe en mode paysage</div>
      <div class="txt">
        Pour utiliser cette activit√© sur t√©l√©phone ou tablette,<br>
        tourne l‚Äôappareil en <strong>mode paysage</strong>.
      </div>
    </div>
  </div>



<div id="overlayDissoc" style="display:none;">
  <div class="ovl-backdrop"></div>
  <div class="ovl-stage">
    <div class="ovl-topbar">
      <div class="ovl-title">Dissociation dans l‚Äôeau</div>
      <div style="display:flex; gap:8px;">
        <button class="btn" id="btnShake">Agiter</button>
        <button class="btn" id="btnRetourOvl">Nouvelle mol√©cule ionique ?</button>
      </div>
    </div>
    <div id="ovl-canvas">
      <div id="becherWrap">
        <div id="becher">
          <div class="water" id="waterZone"></div>
        </div>
      </div>
      <!-- Ions et mol√©cule clon√©e seront inject√©s ici -->
    </div>
  </div>
</div>

<div class="version-box">
  Version 2.3<br>
  S. Ulrich ‚Äî ECG Henry-Dunant
</div>

<div class="app">
  <div class="title">Formation de mol√©cule √† partir d‚Äôions</div>
  <div class="subtitle"><b>Former des mol√©cules neutres</b> ‚Äî <i>ensemble connect√© uniquement par contacts entre signes oppos√©s</i></div>

  <div class="panel grid" style="margin-top:16px;">
    <div>
      <div class="row" style="margin-bottom:8px; flex-direction:column; align-items:flex-start; gap:6px;">
        <div>
          <label>Choisir le cation :</label>
          <select id="selCation"></select>
        </div>
        <div>
          <label>Choisir l'anion :</label>
          <select id="selAnion"></select>
        </div>
        <div class="row" style="gap:8px;flex-wrap:wrap;">
          <button class="btn" id="btnNouvelle">Reset</button>
          <button class="btn" id="btnDissocier" style="display:none;margin-left:6px;">Dissociation dans l'eau</button>
        </div>
      </div>
      <div class="panel area">
        <div class="space"></div>
        <div class="center" id="centre">D√©pose ici ton <u>premier ion</u><br/>Il deviendra le noyau</div>
        <div id="zoneJeu">
          <div id="moleculeHalo" aria-hidden="true"></div>

          <div id="trashBin" aria-label="Poubelle">
            <svg class="trashIcon" viewBox="0 0 24 24" role="img" aria-hidden="true">
              <path d="M9 3h6a1 1 0 0 1 1 1v1h4a1 1 0 1 1 0 2h-1l-1 14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2L4 7H3a1 1 0 1 1 0-2h4V4a1 1 0 0 1 1-1Zm1 2v0h4V4h-4v1Zm-2 4a1 1 0 1 1 2 0v9a1 1 0 1 1-2 0V9Zm4 0a1 1 0 1 1 2 0v9a1 1 0 1 1-2 0V9Zm4 0a1 1 0 1 1 2 0v9a1 1 0 1 1-2 0V9Z"/>
            </svg>
          </div>

        </div>
      </div>
    </div>
    <div>
      <div class="row">
        <div class="info">Clique un ion ci-dessous pour en cr√©er un, puis fais-le glisser dans la zone √† gauche.</div>
      </div>
      <div class="row" style="gap:8px;margin:8px 0 6px 0;">
        <div id="statusChip" style="display:none;background:rgba(59,209,111,.15);border:1px solid rgba(59,209,111,.3);color:#c8ffd9;padding:8px 10px;border-radius:10px;font-weight:800;">Mol√©cule neutre ‚Äî Bravo !</div>
        <div id="formulaChip" style="display:none;background:#10183a;border:1px solid rgba(255,255,255,.12);color:#eef2ff;padding:8px 10px;border-radius:10px;font-weight:700;"></div>
      </div>
      <div style="margin-top:10px; font-weight:700;">Cation s√©lectionn√©</div>
      <div class="tray" id="plateauCation"></div>
      <div style="margin-top:10px; font-weight:700;">Anion s√©lectionn√©</div>
      <div class="tray" id="plateau"></div>
    </div>
  </div>
</div>

<div id="chargeGauge" aria-label="Charge √©lectrique globale">
  <div class="gaugeCard">
    <svg viewBox="-60 -50 120 70" role="img" aria-hidden="false">
      <path d="M -50 0 A 50 50 0 0 1 0 -50" fill="none" stroke="url(#gradNeg)" stroke-width="12" />
      <path d="M 0 -50 A 50 50 0 0 1 50 0" fill="none" stroke="url(#gradPos)" stroke-width="12" />
      <g id="cgTicks"></g>
      <g id="cgNeedle" transform="rotate(0)">
        <polygon points="0,-14 0,-42 8.5,-42 0,-58 -8.5,-42 0,-42"
                 fill="#ff2b2b"
                 stroke="#0b0f22"
                 stroke-width="3"
                 stroke-linejoin="round" />
        <circle cx="0" cy="0" r="7.6" fill="#ffffff" stroke="#0b0f22" stroke-width="2.6"/>
      </g>
      <defs>
        <linearGradient id="gradNeg" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0%" stop-color="#8fb9ff"/>
          <stop offset="100%" stop-color="#2b5cff"/>
        </linearGradient>
        <linearGradient id="gradPos" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0%" stop-color="#ff7a7a"/>
          <stop offset="100%" stop-color="#ff3b3b"/>
        </linearGradient>
      </defs>
    </svg>
  </div>
  <div class="label" id="cgLabel">Charge : 0</div>
</div>

<script>
// utilitaires texte
const SUBS = {'0':'‚ÇÄ','1':'‚ÇÅ','2':'‚ÇÇ','3':'‚ÇÉ','4':'‚ÇÑ','5':'‚ÇÖ','6':'‚ÇÜ','7':'‚Çá','8':'‚Çà','9':'‚Çâ'};
const SUPS = {'0':'‚Å∞','1':'¬π','2':'¬≤','3':'¬≥','4':'‚Å¥','5':'‚Åµ','6':'‚Å∂','7':'‚Å∑','8':'‚Å∏','9':'‚Åπ','+':'‚Å∫','-':'‚Åª'};
function toSubDigits(s){ return String(s).replace(/[0-9]/g, d => SUBS[d] || d); }
function toSup(s){ return String(s).replace(/[0-9+\-]/g, ch => SUPS[ch] || ch); }
function ionLabelUnicode(sym, charge){
  const base = toSubDigits(sym);
  const mag = Math.abs(charge);
  const signChar = charge>0 ? '+' : (charge<0 ? '-' : '');
  if(!signChar) return base;
  if(mag === 1){
    return base + (SUPS[signChar] || signChar);
  } else {
    return base + toSup(String(mag)) + (SUPS[signChar] || signChar);
  }
}
function signColHTML(count, signChar){ let s=''; for(let i=0;i<count;i++) s += `<span class="sign">${signChar}</span>`; return s; }
function ionFaceHTML(kind, htmlSym, charge){
  const mag = Math.abs(charge);
  const left  = (charge<0) ? signColHTML(mag, '‚Åª') : '';
  const right = (charge>0) ? signColHTML(mag, '+') : '';
  return `<div class="ion-face"><div class="col left">${left}</div><div class="core">${htmlSym}</div><div class="col right">${right}</div></div>`;
}
function lcm(a,b){ const g=(x,y)=>y?g(y,x%y):x; return Math.abs(a*b)/g(a,b); }
function sub(n){ return n>1?`<sub>${n}</sub>`:''; }
function needsParens(labelHtml){
  const txt = String(labelHtml).replace(/<[^>]*>/g, '');
  const matches = txt.match(/[A-Z][a-z]?/g);
  return !!(matches && matches.length > 1);
}

// donn√©es ions
const CATIONS = [
  { name: 'Sodium',    sym: 'Na',  html: 'Na', charge: +1 },
  { name: 'Ammonium',  sym: 'NH4', html: 'NH<sub>4</sub>', charge: +1 },
  { name: 'Magn√©sium', sym: 'Mg',  html: 'Mg', charge: +2 },
  { name: 'Fer(II)',   sym: 'Fe',  html: 'Fe', charge: +2 },
  { name: 'Aluminium', sym: 'Al',  html: 'Al', charge: +3 },
  { name: 'Fer(III)',  sym: 'Fe',  html: 'Fe', charge: +3 },
];
const ANIONS = [
  { name: 'Chlorure',  sym: 'Cl',  html: 'Cl', charge: -1 },
  { name: 'Hydroxyde', sym: 'OH',  html: 'OH', charge: -1 },
  { name: 'Nitrate',   sym: 'NO3', html: 'NO<sub>3</sub>', charge: -1 },
  { name: 'Sulfate',   sym: 'SO4', html: 'SO<sub>4</sub>', charge: -2 },
  { name: 'Phosphate', sym: 'PO4', html: 'PO<sub>4</sub>', charge: -3 },
];

const $ = (q) => document.querySelector(q);
const zone = $('#zoneJeu');
const centre = $('#centre');
const plateau = $('#plateau');
const plateauCation = $('#plateauCation');
const selCation = $('#selCation');
const selAnion = $('#selAnion');

function fillSelects(){
  selCation.innerHTML = "";
  selAnion.innerHTML = "";
  CATIONS.forEach((c,i)=>{
    const o = document.createElement('option');
    o.value = i;
    o.textContent = `${c.name} (${ionLabelUnicode(c.sym, c.charge)})`;
    selCation.appendChild(o);
  });
  ANIONS.forEach((a,i)=>{
    const o = document.createElement('option');
    o.value = i;
    o.textContent = `${a.name} (${ionLabelUnicode(a.sym, a.charge)})`;
    selAnion.appendChild(o);
  });
}
fillSelects();

// g√©om√©trie / centre
function centrePosition(){
  const area=zone.getBoundingClientRect();
  const c=centre.getBoundingClientRect();
  return { x: c.left - area.left + c.width/2 - 38, y: c.top - area.top + c.height/2 - 38 };
}
function coreCenter(){
  if(!current || !current.core){ return {cx:0, cy:0}; }
  const coreLeft=parseFloat(current.core.style.left)||0;
  const coreTop=parseFloat(current.core.style.top)||0;
  return { cx: coreLeft + 38, cy: coreTop + 38 };
}
function center(el){
  return {
    cx: (parseFloat(el.style.left)||0) + 38,
    cy: (parseFloat(el.style.top)||0) + 38
  };
}
function angleBetween(ax, ay, bx, by){
  const dx = bx - ax, dy = by - ay;
  return Math.atan2(dy, dx) * 180 / Math.PI;
}
function setRotation(el, deg){
  el.style.transform = `rotate(${deg}deg)`;
  el.dataset.angle = String(deg);
}
function nearestOpposite(el){
  const myCharge = parseInt(el.dataset.charge)||0;
  const ions = [...zone.querySelectorAll('.ion')].filter(i => i !== el);
  let best = null, bestD = Infinity;
  const me = center(el);
  for(const other of ions){
    const c = parseInt(other.dataset.charge)||0;
    if(myCharge * c >= 0) continue;
    const oc = center(other);
    const d = Math.hypot(oc.cx - me.cx, oc.cy - me.cy);
    if(d < bestD){ bestD = d; best = other; }
  }
  return best;
}
function alignPair(a, b){
  const ac = center(a), bc = center(b);
  const angAB = angleBetween(ac.cx, ac.cy, bc.cx, bc.cy);
  const angBA = angleBetween(bc.cx, bc.cy, ac.cx, ac.cy);
  const ca = parseInt(a.dataset.charge)||0;
  const cb = parseInt(b.dataset.charge)||0;
  setRotation(a, ca < 0 ? (angAB + 180) : angAB);
  setRotation(b, cb < 0 ? (angBA + 180) : angBA);
}
function alignOne(el){
  const target = nearestOpposite(el);
  if(!target) return;
  const me = center(el);
  const t  = center(target);
  const ang = angleBetween(me.cx, me.cy, t.cx, t.cy);
  const charge = parseInt(el.dataset.charge)||0;
  setRotation(el, charge < 0 ? (ang + 180) : ang);
}
function alignAll(){ zone.querySelectorAll('.ion').forEach(el => { alignOne(el); }); }

// contraintes placement
function clampToBounds(pos){
  const r = zone.getBoundingClientRect();
  const maxX = r.width - 76;
  const maxY = r.height - 76;
  return {
    x: Math.max(0, Math.min(pos.x, maxX)),
    y: Math.max(0, Math.min(pos.y, maxY)),
  };
}

function distance(a,b){
  const ca = center(a), cb = center(b);
  return Math.hypot(ca.cx - cb.cx, ca.cy - cb.cy);
}
function sameSign(a,b){
  const ca = parseInt(a.dataset.charge)||0;
  const cb = parseInt(b.dataset.charge)||0;
  return ca*cb > 0;
}
function oppositeSign(a,b){
  const ca = parseInt(a.dataset.charge)||0;
  const cb = parseInt(b.dataset.charge)||0;
  return ca*cb < 0;
}

const TOUCH_DIST = 76;
theEPS = 6.0;
const OVERLAP_ALLOW = 8;
const NUDGE_MS = 100;
const REPULSE_PAD = 12;

function allowedTouch(a,b){
  return oppositeSign(a,b) && distance(a,b) <= (TOUCH_DIST + theEPS);
}

// petite animation pour le jeu principal
function anime(el, to, dur=220, done){
  const from={ x: parseFloat(el.style.left)||0, y: parseFloat(el.style.top)||0 };
  const t0=performance.now();
  function step(t){
    const k=Math.min(1,(t-t0)/dur);
    const e=1-Math.pow(1-k,3);
    const cand = { x: (from.x+(to.x-from.x)*e), y: (from.y+(to.y-from.y)*e) };
    const c = clampToBounds(cand);
    el.style.left = c.x + 'px';
    el.style.top = c.y + 'px';
    if(k<1) requestAnimationFrame(step); else done && done();
  }
  requestAnimationFrame(step);
}

function nearestSameSignWithin(el, radius){
  const ions = [...zone.querySelectorAll('.ion')].filter(i => i !== el);
  let best=null, bestD=Infinity;
  for(const other of ions){
    if(!sameSign(el, other)) continue;
    const d = distance(el, other);
    if(d < radius && d < bestD){ best=other; bestD=d; }
  }
  return best;
}
function repel(el, near){
  const ce = center(el), cn = center(near);
  let dx = ce.cx - cn.cx, dy = ce.cy - cn.cy;
  if(dx === 0 && dy === 0){ dx = 1; dy = 0; }
  const d = Math.hypot(dx,dy) || 1;
  const ux = dx/d, uy = dy/d;
  const targetD = TOUCH_DIST + REPULSE_PAD;
  const newCx = cn.cx + ux * targetD;
  const newCy = cn.cy + uy * targetD;
  const to = clampToBounds({ x: newCx - 38, y: newCy - 38 });
  anime(el, to, 180, ()=>{ alignAll(); updateStatus(); });
}
function mostOverlapped(el){
  const ions = [...zone.querySelectorAll('.ion')].filter(i => i !== el);
  let best=null, bestD=Infinity;
  for(const other of ions){
    const d = distance(el, other);
    if(d < bestD){ best=other; bestD=d; }
  }
  return {other: best, d: bestD};
}
function gentleResolve(el){
  const info = mostOverlapped(el);
  if(!info.other) return;
  const minD = TOUCH_DIST - OVERLAP_ALLOW;
  if(info.d >= minD) return;
  const ce = center(el), co = center(info.other);
  let dx = ce.cx - co.cx, dy = ce.cy - co.cy;
  if(dx === 0 && dy === 0){ dx = 1; dy = 0; }
  const d = Math.hypot(dx,dy) || 1;
  const ux = dx/d, uy = dy/d;
  const targetD = minD;
  const newCx = co.cx + ux * targetD;
  const newCy = co.cy + uy * targetD;
  const to = clampToBounds({ x: newCx - 38, y: newCy - 38 });
  anime(el, to, NUDGE_MS, ()=>{ alignAll(); updateStatus(); });
}

// cluster connectivity
function isSingleConnectedCluster(ions){
  if(ions.length <= 1) return false;
  const n = ions.length;
  const adj = Array.from({length:n}, ()=>[]);
  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      if(allowedTouch(ions[i], ions[j])){
        adj[i].push(j);
        adj[j].push(i);
      }
    }
  }
  const seen = new Array(n).fill(false);
  const q=[0]; seen[0]=true;
  while(q.length){
    const u=q.shift();
    for(const v of adj[u]) if(!seen[v]){ seen[v]=true; q.push(v); }
  }
  const edgeCount = adj.reduce((s,arr)=>s+arr.length,0)/2;
  const allSeen = seen.every(Boolean);
  return allSeen && edgeCount >= 1;
}

// nettoyage ions isol√©s
function removeIsolatedIons(){
  if(!current || !current.core) return false;
  const ions = [...zone.querySelectorAll('.ion')];
  let removedAny = false;
  for(const el of ions){
    if(el === current.core) continue;
    const hasContact = ions.some(other => other !== el && allowedTouch(el, other));
    if(!hasContact){
      el.remove();
      removedAny = true;
    }
  }
  return removedAny;
}

// √©tat global
let current = null; // { cation, anion, core, spawnAnion, spawnCation }
let locked = false;

function showMoleculeHalo(){
  const halo = document.getElementById('moleculeHalo');
  const ions = [...zone.querySelectorAll('.ion')];
  if(!halo || ions.length===0) return;
  const zr = zone.getBoundingClientRect();
  let minL=Infinity, minT=Infinity, maxR=-Infinity, maxB=-Infinity;
  for(const el of ions){
    const r = el.getBoundingClientRect();
    minL = Math.min(minL, r.left);
    minT = Math.min(minT, r.top);
    maxR = Math.max(maxR, r.right);
    maxB = Math.max(maxB, r.bottom);
  }
  const pad = 34;
  const left = Math.max(0, minL - zr.left - pad);
  const top  = Math.max(0, minT - zr.top  - pad);
  const width  = Math.min(zr.width,  (maxR - minL) + pad*2);
  const height = Math.min(zr.height, (maxB - minT) + pad*2);
  halo.style.left = left + 'px';
  halo.style.top  = top  + 'px';
  halo.style.width  = Math.max(40, width)  + 'px';
  halo.style.height = Math.max(40, height) + 'px';
  halo.classList.add('show');
  clearTimeout(halo._t);
  halo._t = setTimeout(()=>{ halo.classList.remove('show'); }, 4000);
}

function isOverTrash(el){
  const bin = document.getElementById('trashBin');
  if(!bin) return false;
  const br = bin.getBoundingClientRect();
  const r  = el.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top  + r.height/2;
  return (cx>=br.left && cx<=br.right && cy>=br.top && cy<=br.bottom);
}
function setTrashHighlight(on){
  const bin = document.getElementById('trashBin');
  if(!bin) return;
  if(on) bin.classList.add('highlight'); else bin.classList.remove('highlight');
}

function moleculeIsComplete(){
  const ions = [...zone.querySelectorAll('.ion')];
  if(ions.length <= 1) return false;
  let total = 0; ions.forEach(el => total += (parseInt(el.dataset.charge)||0));
  if(total !== 0) return false;
  try {
    if(!isSingleConnectedCluster(ions)) return false;
  } catch(e){}
  return true;
}
function coreIsCentered(tol=6){
  if(!current || !current.core) return false;
  const cc = coreCenter();
  const cp = centrePosition();
  const dx = Math.abs(cc.cx - (cp.x+38));
  const dy = Math.abs(cc.cy - (cp.y+38));
  return dx <= tol && dy <= tol;
}
function eraseMolecule(){
  nouvellePartie();
}
function enforceCenteredMolecule(){
  if(moleculeIsComplete() && !coreIsCentered(6)){
    eraseMolecule();
  }
}

// gauge
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function mapChargeToAngle(total, maxMag){
  var span = 90;
  var ang = (total / maxMag) * span;
  return clamp(ang, -span, +span);
}
function updateChargeGauge(total){
  const needle = document.getElementById('cgNeedle');
  const label  = document.getElementById('cgLabel');
  if(!needle || !label) return;
  const maxMag = 6;
  const ang = mapChargeToAngle(total, maxMag);
  needle.setAttribute('transform', 'rotate(' + ang.toFixed(1) + ')');
  const sign = total>0 ? '+' : '';
  label.textContent = 'Charge : ' + sign + total;
  const wrap = document.getElementById('chargeGauge');
  if(total === 0){
    wrap.classList.add('ok');
    setTimeout(function(){ wrap.classList.remove('ok'); }, 400);
  }
}

// drag / spawn
function creerIon(innerHTML, kind, charge, sym){
  const d=document.createElement('div');
  d.className=`ion ${kind}`;
  d.innerHTML=innerHTML;
  d.dataset.charge=charge;
  d.dataset.sym=sym;
  enableDrag(d);
  return d;
}

function attachIfTouching(el){
  if(locked) { updateStatus(); return; }
  if(!current || !current.core) return;

  // r√©pulsion homosigne
  const tooCloseSame = nearestSameSignWithin(el, TOUCH_DIST + theEPS);
  if(tooCloseSame){
    repel(el, tooCloseSame);
    return;
  }

  // attache seulement au noyau oppos√©
  const core = current.core;
  if(!oppositeSign(el, core)){ updateStatus(); return; }

  const cc = coreCenter();
  const ex = (parseFloat(el.style.left)||0) + 38;
  const ey = (parseFloat(el.style.top)||0) + 38;
  let dx = ex - cc.cx, dy = ey - cc.cy;
  const dist = Math.hypot(dx, dy);
  const target = TOUCH_DIST;
  const snapRange = 110;

  if(dist <= snapRange){
    if(dist === 0){ dx = 1; dy = 0; }
    const ux = dx / (dist || 1), uy = dy / (dist || 1);
    const tx = cc.cx + ux * target - 38;
    const ty = cc.cy + uy * target - 38;
    el.classList.add('fixed'); el.dataset.fixed = "1";
    const __attachClamped = clampToBounds({x: tx, y: ty});
    anime(el, __attachClamped, 200, ()=>{
      if(current.core){ alignPair(el, current.core); } else { alignOne(el); }
      alignAll(); updateStatus();
    });
  } else {
    locked = false;
    if(current && current.spawnAnion){ current.spawnAnion.classList.remove('disabled'); current.spawnAnion.title = 'Cr√©er un anion √† glisser'; }
    if(current && current.spawnCation){ current.spawnCation.classList.remove('disabled'); current.spawnCation.title = 'Cr√©er un cation √† glisser'; }
    updateStatus();
  }
}

function dragStart(el, e){
  if(el.dataset.fixed==="1" || el.classList.contains('fixed')) return;
  e.preventDefault();
  const rect=el.getBoundingClientRect();
  const area=zone.getBoundingClientRect();
  const offX=e.clientX-rect.left;
  const offY=e.clientY-rect.top;
  function move(ev){
    const p=(ev.touches?ev.touches[0]:ev);
    let x=p.clientX-area.left-offX;
    let y=p.clientY-area.top-offY;
    const __c = clampToBounds({x:x, y:y});
    el.style.left = __c.x + 'px'; el.style.top = __c.y + 'px';
    const nearSame = nearestSameSignWithin(el, TOUCH_DIST + theEPS);
    if(nearSame){ repel(el, nearSame); }
    else {
      const _opp = nearestOpposite(el);
      if(_opp){ alignPair(el, _opp); } else { alignOne(el); }
    }
  }
  function up(){
    document.removeEventListener('mousemove', move);
    document.removeEventListener('mouseup', up);
    document.removeEventListener('touchmove', move);
    document.removeEventListener('touchend', up);

    if(isOverTrash(el)){
      setTrashHighlight(false);
      if(current && current.core===el) current.core=null;
      el.remove();
      updateStatus();
      return;
    }

    if(!current.core){
      current.core = el;
      const pos = centrePosition();
      el.style.left = pos.x + 'px';
      el.style.top  = pos.y + 'px';
      updateStatus();
      centre.textContent = "";
      alignAll();
      return;
    }

    if(el !== current.core){
      attachIfTouching(el);
      gentleResolve(el);
      alignAll();
      return;
    }
    updateStatus();
  }
  document.addEventListener('mousemove', move);
  document.addEventListener('mouseup', up);
  document.addEventListener('touchmove', move, {passive:false});
  document.addEventListener('touchend', up);
}
function enableDrag(el){
  el.addEventListener('mousedown', (e)=> dragStart(el, e));
  el.addEventListener('touchstart', (e)=> dragStart(el, e.touches[0]));
}

// statut / mol√©cule neutre
function updateStatus(){
  try{ enforceCenteredMolecule(); }catch(e){}
  const status=document.getElementById('statusChip');
  const formula=document.getElementById('formulaChip');
  if(!current){ status.style.display='none'; formula.style.display='none'; return; }

  const _removed = removeIsolatedIons();
  if(_removed){ /* pas de boucle infinie */ }

  const ions=[...zone.querySelectorAll('.ion')];
  let total=0; ions.forEach(el=>{ total += (parseInt(el.dataset.charge)||0); });
  const connected = isSingleConnectedCluster(ions);

  updateChargeGauge(total);

  if(total===0 && ions.length>1 && connected){
    locked = true;
    if(current.spawnAnion){ current.spawnAnion.classList.add('disabled'); current.spawnAnion.title = 'Mol√©cule neutre : ajout interdit'; }
    if(current.spawnCation){ current.spawnCation.classList.add('disabled'); current.spawnCation.title = 'Mol√©cule neutre : ajout interdit'; }
    status.classList.remove('warn');
    status.style.display='inline-block';
    status.textContent='Mol√©cule neutre ‚Äî Bravo !';
    showMoleculeHalo();
    alignAll();

    const L=lcm(Math.abs(current.cation.charge), Math.abs(current.anion.charge));
    const nC=L/Math.abs(current.cation.charge);
    const nA=L/Math.abs(current.anion.charge);
    const cLabel = current.cation.html||current.cation.sym;
    const aLabel = current.anion.html||current.anion.sym;
    const cLbl = toSubDigits(cLabel);
    const aLbl = toSubDigits(aLabel);
    formula.style.display='inline-block';
    const cPart = (nC > 1 && needsParens(cLbl)) ? `(${cLbl})${sub(nC)}` : `${cLbl}${sub(nC)}`;
    const aPart = (nA > 1 && needsParens(aLbl)) ? `(${aLbl})${sub(nA)}` : `${aLbl}${sub(nA)}`;
    formula.innerHTML = `Formule brute : ${cPart}${aPart}`;

    const btn = document.getElementById('btnDissocier');
    if(btn){
      btn.style.display = 'inline-block';
      if( isInsolublePair(current.cation, current.anion) ){
        btn.disabled = false;
        btn.classList.remove('disabled');
        btn.textContent = "Insoluble";
        btn.title = "Pr√©cipit√© insoluble : ne se dissout pas dans l'eau";
      } else {
        btn.disabled = false;
        btn.classList.remove('disabled');
        btn.textContent = "Dissociation dans l'eau";
        btn.title = "";
      }
    }

  } else {
    locked = false;
    if(current.spawnAnion){ current.spawnAnion.classList.remove('disabled'); current.spawnAnion.title = 'Cr√©er un anion √† glisser'; }
    if(current.spawnCation){ current.spawnCation.classList.remove('disabled'); current.spawnCation.title = 'Cr√©er un cation √† glisser'; }
    formula.style.display='none';
    const btn = document.getElementById('btnDissocier');
    if(total===0 && ions.length>1){
      if(btn){
        btn.style.display='inline-block';
        if( isInsolublePair(current.cation, current.anion) ){
          btn.disabled = true;
          btn.classList.add('disabled');
          btn.textContent = "Insoluble";
          btn.title = "Pr√©cipit√© insoluble : ne se dissout pas dans l'eau";
        } else {
          btn.disabled = false;
          btn.classList.remove('disabled');
          btn.textContent = "Dissociation dans l'eau";
          btn.title = "";
        }
      }
    }
    else { if(btn) btn.style.display='none'; }
  }
}

// reset partie
function nouvellePartie(){
  locked = false;
  document.getElementById('statusChip').style.display='none';
  document.getElementById('statusChip').classList.remove('warn');
  document.getElementById('formulaChip').style.display='none';
  zone.innerHTML='';
  zone.innerHTML=`
    <div id="moleculeHalo" aria-hidden="true"></div>
    <div id="trashBin" aria-label="Poubelle">
      <svg class="trashIcon" viewBox="0 0 24 24" role="img" aria-hidden="true">
        <path d="M9 3h6a1 1 0 0 1 1 1v1h4a1 1 0 1 1 0 2h-1l-1 14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2L4 7H3a1 1 0 1 1 0-2h4V4a1 1 0 0 1 1-1Zm1 2v0h4V4h-4v1Zm-2 4a1 1 0 1 1 2 0v9a1 1 0 1 1-2 0V9Zm4 0a1 1 0 1 1 2 0v9a1 1 0 1 1-2 0V9Zm4 0a1 1 0 1 1 2 0v9a1 1 0 1 1-2 0V9Z"/>
      </svg>
    </div>`;
  plateau.innerHTML='';
  plateauCation.innerHTML='';
  centre.textContent = "D√©pose ici ton premier ion\nIl deviendra le noyau";

  const c = CATIONS[ +selCation.value || 0 ];
  const a = ANIONS[ +selAnion.value || 0 ];
  current = { cation:c, anion:a, core:null };

  const spawnCation = document.createElement('div');
  spawnCation.className = 'spawn cation';
  spawnCation.title = 'Cr√©er un cation √† glisser';
  spawnCation.innerHTML = ionFaceHTML('cation', c.html||c.sym, c.charge);
  plateauCation.appendChild(spawnCation);
  current.spawnCation = spawnCation;

  const spawn = document.createElement('div');
  spawn.className='spawn anion';
  spawn.title='Cr√©er un anion √† glisser';
  spawn.innerHTML = ionFaceHTML('anion', a.html||a.sym, a.charge);
  plateau.appendChild(spawn);
  current.spawnAnion = spawn;

  function spawnOne(kind, evt){
    if(locked) return;
    const ionDef = (kind==='cation') ? c : a;
    const spawnRect = (kind==='cation' ? spawnCation : spawn).getBoundingClientRect();
    const zoneRect = zone.getBoundingClientRect();
    const x = spawnRect.left - zoneRect.left + spawnRect.width/2 - 38;
    const y = spawnRect.top - zoneRect.top + spawnRect.height/2 - 38;
    const floating = creerIon( ionFaceHTML(kind, ionDef.html||ionDef.sym, ionDef.charge), kind, ionDef.charge, ionDef.sym );
    floating.style.left = x + 'px';
    floating.style.top = y + 'px';
    zone.appendChild(floating);
    const e=evt.touches?evt.touches[0]:evt;
    dragStart(floating, e);
  }
  spawn.addEventListener('mousedown', (e)=>spawnOne('anion', e));
  spawn.addEventListener('touchstart', (e)=>{ spawnOne('anion', e); e.preventDefault(); }, {passive:false});
  spawnCation.addEventListener('mousedown', (e)=>spawnOne('cation', e));
  spawnCation.addEventListener('touchstart', (e)=>{ spawnOne('cation', e); e.preventDefault(); }, {passive:false});

  updateChargeGauge(0);
}

// --- DISSOCIATION ---

// slots fixes dans l'eau
function getSlotsInWater(){
  const ovlCanvas = document.getElementById('ovl-canvas');
  const waterEl   = document.getElementById('waterZone');
  if(!ovlCanvas || !waterEl) return [];

  const wRect = waterEl.getBoundingClientRect();

  const radius = 38;
  const safeLeft   = wRect.left   + radius;
  const safeRight  = wRect.right  - radius;
  const safeTop    = wRect.top    + radius;
  const safeBottom = wRect.bottom - radius;

  function slot(relXPct, relYPct){
    const xTarget = safeLeft + (safeRight  - safeLeft ) * (relXPct/100);
    const yTarget = safeTop  + (safeBottom - safeTop  ) * (relYPct/100);
    const cRect = ovlCanvas.getBoundingClientRect();
    return {
      x: xTarget - cRect.left - radius,
      y: yTarget - cRect.top  - radius
    };
  }

  return [
    slot(20,20), // 1 haut gauche
    slot(50,80), // 2 bas centre
    slot(80,35), // 3 milieu droite (plus haut)
    slot(75,85), // 4 bas droite (plus bas)
    slot(25,70), // 5 bas gauche
    slot(50,30), // 6 centre, √† 30 %
  ];
}

// redistribue les ions d√©j√† libres dans l'eau
function shakeIonsInWater(){
  const ovlCanvas = document.getElementById('ovl-canvas');
  if(!ovlCanvas) return;

  const ions = [...ovlCanvas.querySelectorAll('.freeIon')];
  if(ions.length === 0) return;

  const slots = getSlotsInWater();
  if(slots.length === 0) return;

  const shuffled = [...slots];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }

  const cRect = ovlCanvas.getBoundingClientRect();

  ions.forEach((ion, idx) => {
    const slotPos = shuffled[idx % shuffled.length];
    const startRect = ion.getBoundingClientRect();
    const startX = startRect.left - cRect.left;
    const startY = startRect.top - cRect.top;
    const endX = slotPos.x;
    const endY = slotPos.y;

    const t0 = performance.now();
    const dur = 1000;
    function step(t){
      const k = Math.min(1, (t - t0)/dur);
      const ease = 1 - Math.pow(1-k, 3);
      const curX = startX + (endX - startX)*ease;
      const curY = startY + (endY - startY)*ease;
      ion.style.left = curX + 'px';
      ion.style.top  = curY + 'px';
      if(k < 1){
        requestAnimationFrame(step);
      }
    }
    requestAnimationFrame(step);
  });
}

// petite animation ions -> slots
function animateIonToSlot(freeIon, startX, startY, endX, endY){
  const t0 = performance.now();
  const dur = 1200;
  function step(t){
    const k=Math.min(1,(t-t0)/dur);
    const ease = 1-Math.pow(1-k,3);
    const curX = startX + (endX - startX)*ease;
    const curY = startY + (endY - startY)*ease;
    freeIon.style.left = curX+'px';
    freeIon.style.top  = curY+'px';
    if(k<1) requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}

// explosion dans l'eau
function explodeIntoSlots(fallGroup){
  const clones = [...fallGroup.querySelectorAll('.ovl-ion')];
  const ovlCanvas = document.getElementById('ovl-canvas');
  const slots = getSlotsInWater();
  if(slots.length===0) return;

  // indices disponibles : [0,1,2,3,4] au d√©but
  const remainingIdx = slots.map((_,i)=>i);

  const cRect = ovlCanvas.getBoundingClientRect();

  clones.forEach((ionClone)=>{
    // tirer une position libre au hasard
    const pickPos = Math.floor(Math.random()*remainingIdx.length);
    const slotIndex = remainingIdx.splice(pickPos,1)[0];
    const slotPos = slots[slotIndex];

    // position de d√©part de ce clone
    const iRect = ionClone.getBoundingClientRect();
    const absStartX = iRect.left;
    const absStartY = iRect.top;

    const free = ionClone.cloneNode(true);
    free.classList.add('freeIon');
    free.style.position='absolute';
    free.style.left = (absStartX - cRect.left) + 'px';
    free.style.top  = (absStartY - cRect.top ) + 'px';
    free.style.width='76px';
    free.style.height='76px';
    ovlCanvas.appendChild(free);

    // animation jusqu'au slot choisi
    const startX = (absStartX - cRect.left);
    const startY = (absStartY - cRect.top );
    const endX = slotPos.x;
    const endY = slotPos.y;

    const t0 = performance.now();
    const dur = 1200;
    function step(t){
      const k=Math.min(1,(t-t0)/dur);
      const ease = 1-Math.pow(1-k,3);
      const curX = startX + (endX - startX)*ease;
      const curY = startY + (endY - startY)*ease;
      free.style.left = curX+'px';
      free.style.top  = curY+'px';
      if(k<1){
        requestAnimationFrame(step);
      }
    }
    requestAnimationFrame(step);
  });

  fallGroup.style.display='none';

  // maintenant, tr√®s l√©ger fr√©missement local
  addWiggleToPlacedIons();
}
// animation chute rapide

// ajoute le l√©ger mouvement aux ions d√©j√† plac√©s dans l'eau
function addWiggleToPlacedIons() {
  const ovlCanvas = document.getElementById('ovl-canvas');
  if(!ovlCanvas) return;
  const placed = ovlCanvas.querySelectorAll('.freeIon');
  placed.forEach(ion => {
    // petite attente pour ne PAS g√™ner l'arriv√©e
    setTimeout(() => {
      ion.classList.add('wiggle');
    }, 300);
  });
}

function startInWindowDissociation(){
  const ovl = document.getElementById('overlayDissoc');
  const ovlCanvas = document.getElementById('ovl-canvas');
  if(!ovl || !ovlCanvas) return;
  ovl.style.display = 'block';

  [...ovlCanvas.querySelectorAll('.fallGroup, .freeIon')].forEach(n=>n.remove());

  const ions = [...zone.querySelectorAll('.ion')];
  if(ions.length===0) return;

  const ref = current.core || ions[0];
  const refRect = ref.getBoundingClientRect();

  const fallGroup = document.createElement('div');
  fallGroup.className = 'fallGroup';
  fallGroup.style.position='absolute';
  fallGroup.style.left='50%';
  fallGroup.style.top='10%';
  fallGroup.style.transform='translate(-50%,0)';
  fallGroup.style.pointerEvents='none';
  ovlCanvas.appendChild(fallGroup);

  ions.forEach(src=>{
    const sRect = src.getBoundingClientRect();
    const dx = (sRect.left - refRect.left);
    const dy = (sRect.top  - refRect.top );
    const clone = document.createElement('div');
    clone.className = 'ovl-ion ' + ( (parseInt(src.dataset.charge)||0)>0 ? 'pos':'neg' );
    clone.innerHTML = src.innerHTML;
    clone.dataset.charge = src.dataset.charge||"0";
    clone.style.left = dx + 'px';
    clone.style.top  = dy + 'px';
    clone.style.width='76px';
    clone.style.height='76px';
    clone.style.position='absolute';
    fallGroup.appendChild(clone);
  });

  const startTime = performance.now();
  const durationFall = 1000;
  const startTopPct = 10;
  const endTopPct = 45;
  function fallStep(t){
    const k = Math.min(1,(t-startTime)/durationFall);
    const ease = 1-Math.pow(1-k,3);
    const cur = startTopPct + (endTopPct-startTopPct)*ease;
    fallGroup.style.top = cur + '%';
    if(k<1){ requestAnimationFrame(fallStep); }
    else {
      explodeIntoSlots(fallGroup);
    }
  }
  requestAnimationFrame(fallStep);

  const btnBack = document.getElementById('btnRetourOvl');
  if(btnBack && !btnBack.__wired){
    btnBack.__wired = true;
    btnBack.addEventListener('click', ()=>{
      ovl.style.display='none';
      nouvellePartie();
    });
  }

  const btnShake = document.getElementById('btnShake');
  if(btnShake && !btnShake.__wired){
    btnShake.__wired = true;
    btnShake.addEventListener('click', ()=>{
      shakeIonsInWater();
    });
  }
}

// --- INSOLUBLE : la mol√©cule tombe intacte au fond du b√©cher ---
function startInsolubleDropIntoWater(){
  const ovl = document.getElementById('overlayDissoc');
  const ovlCanvas = document.getElementById('ovl-canvas');
  const waterEl   = document.getElementById('waterZone');
  const becherEl  = document.getElementById('becher');
  if(!ovl || !ovlCanvas || !waterEl || !becherEl) return;

  ovl.style.display = 'block';

  // Nettoyer d'√©ventuels restes
  [...ovlCanvas.querySelectorAll('.fallGroup, .freeIon')].forEach(n=>n.remove());

  // Cloner la mol√©cule intacte depuis la zone de jeu
  const ions = [...zone.querySelectorAll('.ion')];
  if(ions.length===0 || !current) return;

  const ref = current.core || ions[0];
  const refRect = ref.getBoundingClientRect();

  const fallGroup = document.createElement('div');
  fallGroup.className = 'fallGroup';
  fallGroup.style.position='absolute';
  fallGroup.style.left='50%';
  fallGroup.style.top='10%';
  fallGroup.style.transform='translate(-50%,0)';
  fallGroup.style.pointerEvents='none';
  ovlCanvas.appendChild(fallGroup);

  ions.forEach(src=>{
    const sRect = src.getBoundingClientRect();
    const dx = (sRect.left - refRect.left);
    const dy = (sRect.top  - refRect.top );
    const clone = document.createElement('div');
    clone.className = 'ovl-ion ' + ( (parseInt(src.dataset.charge)||0)>0 ? 'pos':'neg' );
    clone.innerHTML = src.innerHTML;
    clone.dataset.charge = src.dataset.charge||"0";
    clone.style.left = dx + 'px';
    clone.style.top  = dy + 'px';
    clone.style.width='76px';
    clone.style.height='76px';
    clone.style.position='absolute';
    fallGroup.appendChild(clone);
  });

  // Animation : chute lente, centr√©e, enti√®rement √† l'int√©rieur du b√©cher
  requestAnimationFrame(()=>{
    const canvasRect = ovlCanvas.getBoundingClientRect();
    const becherRect = becherEl.getBoundingClientRect();

    // Position actuelle du groupe
    let fgRect = fallGroup.getBoundingClientRect();
    const canvasTop = canvasRect.top;
    const canvasLeft = canvasRect.left;

    // Bas de tous les ions par rapport au groupe
    let bottomWithinGroup = 0;
    Array.from(fallGroup.children).forEach(ch=>{
      const r = ch.getBoundingClientRect();
      const relBottom = r.bottom - fgRect.top;
      if(relBottom > bottomWithinGroup) bottomWithinGroup = relBottom;
    });

    // Centrage horizontal dans le b√©cher
    const groupWidth = fgRect.width;
    const targetCenterX = (becherRect.left + becherRect.right)/2;
    const endLeftPx = targetCenterX - canvasLeft - groupWidth/2;

    // Passer en coordonn√©es px sans transform
    fallGroup.style.transform = 'none';
    fallGroup.style.left = endLeftPx + 'px';

    // Recalculer apr√®s recentrage
    fgRect = fallGroup.getBoundingClientRect();

    // Recalculer le bas relatif une fois pour toutes
    bottomWithinGroup = 0;
    Array.from(fallGroup.children).forEach(ch=>{
      const r = ch.getBoundingClientRect();
      const relBottom = r.bottom - fgRect.top;
      if(relBottom > bottomWithinGroup) bottomWithinGroup = relBottom;
    });

    // Le bas de l'ion le plus bas doit toucher l'int√©rieur du fond du b√©cher
    const epsilon = 2; // petite marge pour rester √† l'int√©rieur du trait
    const targetBottom = becherRect.bottom - epsilon;
    const startTopPx = fgRect.top - canvasTop;
    const endTopPx = targetBottom - canvasTop - bottomWithinGroup;

    const startTime = performance.now();
    const durationFall = 1800; // 50 % de la vitesse initiale
    function fallStep(t){
      const k = Math.min(1,(t-startTime)/durationFall);
      const ease = 1 - Math.pow(1-k,3);
      const topPx = startTopPx + (endTopPx - startTopPx)*ease;
      fallGroup.style.top = topPx + 'px';
      if(k < 1){
        requestAnimationFrame(fallStep);
      } else {
        // Snap exact √† la fin pour garantir qu'aucun ion ne d√©passe
        fallGroup.style.top = endTopPx + 'px';
      }
    }
    requestAnimationFrame(fallStep);
  });

  const btnBack = document.getElementById('btnRetourOvl');
  if(btnBack && !btnBack.__wiredInsol){
    btnBack.__wiredInsol = true;
    btnBack.addEventListener('click', ()=>{
      ovl.style.display='none';
      nouvellePartie();
    });
  }

  const btnShake = document.getElementById('btnShake');
  if(btnShake && !btnShake.__wiredInsol){
    btnShake.__wiredInsol = true;
    btnShake.addEventListener('click', ()=>{
      // Insoluble : on n'√©clate pas la mol√©cule, on laisse juste une petite secousse visuelle √©ventuelle
      // (rien ici pour l'instant)
    });
  }
}


// listeners init
document.getElementById('btnNouvelle').addEventListener('click', nouvellePartie);
selCation.addEventListener('change', nouvellePartie);
selAnion.addEventListener('change', nouvellePartie);
document.getElementById('btnDissocier').addEventListener('click', ()=>{
  if (current && isInsolublePair(current.cation, current.anion)) {
    startInsolubleDropIntoWater();
  } else {
    startInWindowDissociation();
  }
});

// jauge ticks
(function(){
  var ticks = [-3,-2,-1,0,1,2,3];
  var g = document.getElementById('cgTicks');
  ticks.forEach(function(t){
    var angle = (-90) + (t/3)*90;
    var rad = angle * Math.PI/180;
    var x1 = Math.cos(rad) * 42;
    var y1 = Math.sin(rad) * 42;
    var x2 = Math.cos(rad) * 50;
    var y2 = Math.sin(rad) * 50;
    var tick = document.createElementNS('http://www.w3.org/2000/svg','line');
    tick.setAttribute('x1', x1.toFixed(2)); tick.setAttribute('y1', y1.toFixed(2));
    tick.setAttribute('x2', x2.toFixed(2)); tick.setAttribute('y2', y2.toFixed(2));
    tick.setAttribute('stroke', '#e9edf7'); tick.setAttribute('stroke-width', '1');
    g.appendChild(tick);
  });
})();

// d√©marrer
selCation.value=0; selAnion.value=0; nouvellePartie();

// Ajout√© pour la version 2.4 : gestion des hydroxydes et phosphates insolubles
function isInsolublePair(cation, anion){
  if(!cation || !anion) return false;
  const cat = cation.name;
  const an = anion.name;

  // Hydroxydes insolubles : Mg(OH)2, Fe(OH)2, Fe(OH)3, Al(OH)3
  if(an === 'Hydroxyde' &&
     (cat === 'Magn√©sium' || cat === 'Fer(II)' || cat === 'Fer(III)' || cat === 'Aluminium'))
    return true;

  // Phosphates insolubles : phosphates de Mg, Fe(II), Fe(III), Al
  if(an === 'Phosphate' &&
     (cat === 'Magn√©sium' || cat === 'Fer(II)' || cat === 'Fer(III)' || cat === 'Aluminium'))
    return true;

  return false;
}

</script>


<script>
(function(){
  function checkOrientation(){
    var isPortrait = false;
    try{
      isPortrait = window.matchMedia && window.matchMedia("(orientation: portrait)").matches;
    }catch(e){
      // fallback: compare viewport
      isPortrait = (window.innerHeight > window.innerWidth);
    }
    document.documentElement.classList.toggle("isPortrait", !!isPortrait);
  }
  window.addEventListener("load", checkOrientation, {passive:true});
  window.addEventListener("resize", checkOrientation, {passive:true});
  window.addEventListener("orientationchange", checkOrientation, {passive:true});
  // initial (important for iOS standalone)
  try{ checkOrientation(); }catch(e){}
})();
</script>

</body>
</html>
