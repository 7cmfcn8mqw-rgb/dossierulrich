<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Simulation pH-mètre & titrages</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      user-select: none;
    }

    body {
      margin: 0;
      padding: 16px;
      background: #f3f4f6;
      color: #111827;
      transition: background-color 0.2s;
    }

    @keyframes flashRed {
      0%   { background-color: #f3f4f6; }
      20%  { background-color: #fee2e2; }
      50%  { background-color: #fecaca; }
      100% { background-color: #f3f4f6; }
    }

    body.flash-red {
      animation: flashRed 0.6s ease-out;
    }

    .version-box {
      position: fixed;
      top: 10px;
      right: 10px;
      border: 1px solid rgba(0,0,0,0.6);
      padding: 4px 6px;
      font-size: 10px;
      line-height: 1.2;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 4px;
      text-align: center;
      color: #111827;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
      z-index: 20;
    }

    h1 {
      text-align: center;
      margin-bottom: 12px;
    }

    .app {
      max-width: 1100px;
      margin: 0 auto;
    }

    .tabs {
      display: flex;
      gap: 0;
      margin-bottom: 16px;
      border-radius: 999px;
      overflow: hidden;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.06);
    }

    .tab-btn {
      flex: 1 1 33%;
      padding: 8px 12px;
      border: none;
      cursor: pointer;
      background: #e5e7eb;
      color: #111827;
      font-weight: 500;
      font-size: 0.95rem;
    }

    .tab-btn.active {
      background: #ffffff;
    }

    .row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-bottom: 16px;
    }

    .card {
      background: #ffffff;
      border-radius: 12px;
      padding: 12px 16px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.06);
    }

    .meter-card {
      flex: 1 1 100%;
      background: linear-gradient(135deg, #0e8f9a, #18a1ab);
      color: #f9fafb;
    }

    .beaker-card {
      flex: 1 1 100%;
    }

    .log-card {
      flex: 1 1 100%;
    }

    .titration-plot-card {
      flex: 1 1 100%;
      margin-top: 8px;
    }

    .meter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .meter-header h2 {
      font-size: 1.1rem;
      margin: 0;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 0.9rem;
      background: #e5e7eb;
      transition:
        transform 0.05s ease,
        box-shadow 0.05s ease,
        background 0.15s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
    }

    .btn-primary {
      background: #2563eb;
      color: white;
    }

    .btn-primary.off {
      background: #9ca3af;
    }

    .btn-small {
      font-size: 0.78rem;
      padding: 4px 10px;
    }

    .status-indicators {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 0.8rem;
      align-items: center;
    }

    .led {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #9ca3af;
      box-shadow: 0 0 0 1px #6b7280 inset;
    }

    .led.on {
      background: #22c55e;
      box-shadow: 0 0 4px 1px rgba(34, 197, 94, 0.7);
    }

    .led.warn {
      background: #f97316;
      box-shadow: 0 0 4px 1px rgba(249, 115, 22, 0.7);
    }

    .digital-panel {
      background: #ffffff;
      color: #111827;
      border-radius: 10px;
      padding: 12px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      border: 1px solid #0b7280;
      min-width: 0;
    }

    .digital-reading {
      font-family: "Roboto Mono", ui-monospace, SFMono-Regular, Menlo, Monaco,
        Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 2.2rem;
      letter-spacing: 0.08em;
    }

    .digital-unit {
      font-size: 0.9rem;
      opacity: 0.9;
    }

    .digital-status {
      font-size: 0.75rem;
      opacity: 0.9;
      text-align: right;
    }

    .meter-main {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .meter-main-left {
      flex: 1 1 260px;
      min-width: 0;
    }

    .meter-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-end;
    }

    @media (max-width: 780px) {
      .meter-controls {
        align-items: flex-start;
      }
    }

    .knob-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      justify-content: flex-end;
      margin-bottom: 0;
      margin-top: 4px;
    }

    .knob-block {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 110px;
    }

    .knob-label {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .knob-arrows {
      font-size: 1.1rem;
      margin-bottom: 4px;
      opacity: 0.9;
    }

    .knob {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #f9fafb, #d1d5db);
      border: 1px solid #9ca3af;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      position: relative;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: box-shadow 0.1s ease;
    }

    .knob:active {
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.45);
    }

    .knob-indicator {
      position: absolute;
      width: 4px;
      height: 20px;
      border-radius: 999px;
      background: #4b5563;
      top: 6px;
      transform-origin: 50% 22px;
    }

    .stir-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 0;
      margin-top: 4px;
      font-size: 0.8rem;
      align-items: center;
    }

    .stir-buttons-label {
      font-size: 0.8rem;
      opacity: 0.9;
    }

    .power-wrapper {
      margin-top: 4px;
      margin-bottom: 4px;
    }

    .meter-status {
      font-size: 0.8rem;
      margin-top: 4px;
    }

    .meter-status p {
      margin: 2px 0;
    }

    .beaker-grid {
      position: relative;
      display: grid;
      grid-template-columns: repeat(4, minmax(150px, 1fr));
      gap: 12px;
    }

    .beaker {
      position: relative;
      padding: 10px;
      text-align: center;
      border-radius: 12px;
      background: linear-gradient(145deg, #e5e7eb, #ffffff);
      cursor: pointer;
      transition:
        transform 0.08s ease,
        box-shadow 0.08s ease,
        border 0.08s,
        background 0.1s;
      border: 2px solid transparent;
      min-height: 260px;
      overflow: hidden;
    }

    .beaker:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.08);
    }

    .beaker.active {
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.25);
    }

    .beaker-title {
      font-weight: 600;
      margin-bottom: 4px;
      min-height: 2.4em;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .beaker-subtitle {
      font-size: 0.8rem;
      margin-bottom: 6px;
      min-height: 1.8em;
    }

    .beaker-graphic {
      position: relative;
      height: 220px;
      margin-bottom: 4px;
    }

    .solution {
      position: absolute;
      left: 12%;
      width: 76%;
      bottom: 0;
      height: 120px;
      border-radius: 0 0 12px 12px;
      background: linear-gradient(to top, #bfdbfe, #eff6ff);
      border: 1px solid #93c5fd;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      transition: background 0.25s ease, border-color 0.25s ease;
    }

    .solution-line {
      position: absolute;
      left: 12%;
      width: 76%;
      bottom: 120px;
      height: 2px;
      background: rgba(37, 99, 235, 0.7);
    }

    .stirrer {
      width: 26px;
      height: 6px;
      border-radius: 999px;
      background: #ffffff;
      opacity: 0.8;
      margin-bottom: 10px;
      transform-origin: center;
      transition: opacity 0.2s ease;
    }

    .stirrer.on {
      opacity: 1;
      animation: stir-length 0.5s linear infinite;
    }

    @keyframes stir-length {
      0%   { transform: scaleX(1); }
      20%  { transform: scaleX(0.7); }
      40%  { transform: scaleX(0.4); }
      60%  { transform: scaleX(0.9); }
      80%  { transform: scaleX(1.3); }
      100% { transform: scaleX(1); }
    }

    .electrode-graphic {
      position: absolute;
      left: 50%;
      width: 12px;
      height: 160px;
      transform: translate(-50%, -40px);
      transition: transform 0.25s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
    }

    .electrode-rod {
      flex: 1;
      width: 4px;
      background: #9ca3af;
      border-radius: 999px;
    }

    .electrode-bulb {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      background: #e5e7eb;
      border: 1px solid #9ca3af;
      box-shadow: 0 0 4px rgba(148, 163, 184, 0.9);
      margin-top: 2px;
    }

    .beaker.active .electrode-graphic {
      transform: translate(-50%, 40px);
    }

    .log-card h3 {
      font-size: 0.9rem;
      margin-top: 0;
      margin-bottom: 4px;
    }

    .log {
      font-size: 0.8rem;
      max-height: 180px;
      overflow-y: auto;
      padding-right: 4px;
      border-top: 1px solid #e5e7eb;
      margin-top: 6px;
      padding-top: 6px;
    }

    .log-entry {
      margin-bottom: 2px;
    }

    .log-entry span.time {
      color: #6b7280;
      margin-right: 4px;
    }

    .beaker-color-green .solution {
      background: linear-gradient(
        to top,
        rgba(57, 255, 20, 0.95),
        rgba(232, 255, 220, 0.98)
      );
      border-color: rgba(16, 185, 129, 1);
    }

    .beaker-color-pink .solution {
      background: linear-gradient(
        to top,
        rgba(255, 20, 147, 0.95),
        rgba(255, 225, 244, 0.98)
      );
      border-color: rgba(236, 72, 153, 1);
    }

    #titrationTable {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.8rem;
      margin-top: 4px;
    }

    #titrationTable th,
    #titrationTable td {
      border: 1px solid #e5e7eb;
      padding: 4px 6px;
      text-align: right;
    }

    #titrationTable th {
      background: #f3f4f6;
      font-weight: 600;
      text-align: center;
    }

    #titrationTableStatus {
      font-size: 0.78rem;
      opacity: 0.8;
      margin-top: 4px;
    }

    #titrationPlot {
      width: 100%;
      height: 220px;
      background: #f9fafb;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }

    .fullscreen-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 80;
    }

    .fullscreen-panel {
      background: #ffffff;
      width: min(1000px, 95vw);
      height: min(650px, 90vh);
      border-radius: 14px;
      padding: 10px 14px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.35);
      display: flex;
      flex-direction: column;
    }

    #fullscreenPlot {
      width: 100%;
      height: 100%;
      background: #f9fafb;
      border-radius: 8px;
      border: 1px solid #e5e7eb;
    }
  </style>
<style>
/* Added by script: small top-left home button */
.home-btn{
  position:fixed;
  top:8px;
  left:8px;
  width:22px;
  height:22px;
  display:flex;
  align-items:center;
  justify-content:center;
  text-decoration:none;
  font-size:14px;
  line-height:1;
  border-radius:6px;
  background:rgba(255,255,255,0.8);
  color:#111;
  border:1px solid rgba(0,0,0,0.25);
  box-shadow:0 1px 3px rgba(0,0,0,0.15);
  z-index:2147483647;
}
.home-btn:hover{ background:rgba(255,255,255,0.95); }
.home-btn:active{ transform:translateY(1px); }
@media (prefers-color-scheme: dark){
  .home-btn{
    background:rgba(30,30,30,0.75);
    color:#f5f5f5;
    border:1px solid rgba(255,255,255,0.25);
  }
}

</style>
</head>
<body>
<a href="https://7cmfcn8mqw-rgb.github.io/dossierulrich/" class="home-btn" aria-label="Retour au menu principal" title="Menu">⟵</a>

  <div class="version-box">
    Version 0.8 – pH-mètre + titrages<br>
    d’après S. Ulrich
  </div>

  <div class="app">
    <h1>Simulation d’un pH-mètre & titrages</h1>

    <div class="tabs">
      <button id="tab1" class="tab-btn active">1. pH-mètre (calibration)</button>
      <button id="tab2" class="tab-btn">2. Titrage acide fort / base forte</button>
      <button id="tab3" class="tab-btn">3. Titrage base forte / acide fort</button>
    </div>

    <div class="row">
      <div class="card meter-card">
        <div class="meter-header">
          <h2>pH-mètre</h2>
        </div>

        <div class="status-indicators">
          <span>Alimentation :</span>
          <div id="ledPower" class="led"></div>
          <span>Calibration :</span>
          <div id="ledCal" class="led"></div>
        </div>

        <div class="meter-main">
          <div class="meter-main-left">
            <div class="digital-panel">
              <div>
                <div id="digitalValue" class="digital-reading">--.-</div>
              </div>
              <div style="text-align:right;">
                <div class="digital-unit">pH</div>
                <div id="digitalStatus" class="digital-status">Éteint</div>
              </div>
            </div>
          </div>

          <div class="meter-controls">
            <div class="knob-panel">
              <div class="knob-block">
                <div class="knob-label">Réglage pH 7</div>
                <div class="knob-arrows">⟲ ⟳</div>
                <div class="knob" id="knob7">
                  <div class="knob-indicator"></div>
                </div>
              </div>
              <div class="knob-block">
                <div class="knob-label">Réglage pH 4</div>
                <div class="knob-arrows">⟲ ⟳</div>
                <div class="knob" id="knob4">
                  <div class="knob-indicator"></div>
                </div>
              </div>
            </div>

            <div class="stir-buttons">
              <span class="stir-buttons-label">Agitateurs (décoratifs ici) :</span>
              <button id="stir1Btn" class="btn btn-small">Agitateur 1 : OFF</button>
              <button id="stir2Btn" class="btn btn-small">Agitateur 2 : OFF</button>
            </div>

            <div class="power-wrapper">
              <button id="powerBtn" class="btn btn-primary off">Marche / Arrêt</button>
            </div>
          </div>
        </div>

        <div class="meter-status">
          <p id="partDescription"></p>
          <p id="electrodeStatus"></p>
          <p id="extraStatus"></p>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="card beaker-card">
        <h2 style="font-size: 1rem; margin-top: 0; margin-bottom: 8px;">Béchers</h2>
        <div class="beaker-grid">
          <div class="beaker" data-becher="1">
            <div class="beaker-graphic">
              <div class="solution">
                <div class="stirrer" data-stirrer="1"></div>
              </div>
              <div class="solution-line"></div>
            </div>
            <div class="beaker-title" id="b1Title"></div>
            <div class="beaker-subtitle" id="b1Subtitle"></div>
          </div>

          <div class="beaker" data-becher="2">
            <div class="beaker-graphic">
              <div class="solution">
                <div class="stirrer" data-stirrer="2"></div>
              </div>
              <div class="solution-line"></div>
            </div>
            <div class="beaker-title" id="b2Title"></div>
            <div class="beaker-subtitle" id="b2Subtitle"></div>
          </div>

          <div class="beaker" data-becher="3">
            <div class="beaker-graphic">
              <div class="solution"></div>
              <div class="solution-line"></div>
            </div>
            <div class="beaker-title" id="b3Title"></div>
            <div class="beaker-subtitle" id="b3Subtitle"></div>
          </div>

          <div class="beaker" data-becher="4">
            <div class="beaker-graphic">
              <div class="solution"></div>
              <div class="solution-line"></div>
            </div>
            <div class="beaker-title" id="b4Title"></div>
            <div class="beaker-subtitle" id="b4Subtitle"></div>
          </div>
        </div>

        <div id="electrode" class="electrode-graphic">
          <div class="electrode-rod"></div>
          <div class="electrode-bulb"></div>
        </div>

        <!-- Contrôles de titrage -->
        <div id="titrationControls">
          <h3 style="font-size:0.9rem; margin:4px 0 6px;">Paramètres du titrage</h3>
          <div class="titration-grid">
            <div>
              <div><strong id="titrationAnalyteLabel">Solution à titrer</strong></div>
              <label>
                Formule brute
                <input id="analyteFormula" type="text" />
              </label>
              <label>
                Volume initial (mL)
                <input id="analyteVolume" type="number" step="0.1" min="0" />
              </label>
              <p style="margin:4px 0 0;font-size:0.78rem;opacity:0.8;">
                Concentration inconnue (entre 0,08 et 0,12 mol·L⁻¹).
              </p>
            </div>
            <div>
              <div><strong id="titrantLabel">Solution titrante</strong></div>
              <label>
                Formule brute
                <input id="titrantFormula" type="text" />
              </label>
              <p style="margin:4px 0 0;font-size:0.78rem;">
                Concentration : <strong>0,10 mol·L⁻¹</strong> (fixe).
              </p>
            </div>
          </div>
          <div style="margin-top:8px; display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
            <button class="btn btn-small" id="add05Btn">+0,50 mL</button>
            <button class="btn btn-small" id="add1Btn">+1,0 mL</button>
            <button class="btn btn-small" id="add2Btn">+2,0 mL</button>
            <button class="btn btn-small" id="resetTitrationBtn">Remise à zéro</button>
            <span id="titrationStatus"></span>
          </div>
        </div>
      </div>
    </div>

    <!-- Courbe + bouton plein écran -->
    <div class="row">
      <div class="card titration-plot-card" id="titrationPlotCard" style="display:none;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
          <h3 style="font-size:0.9rem; margin:0;">Courbe de titrage (pH en fonction du volume ajouté)</h3>
          <button class="btn btn-small" id="fullscreenBtn">Graphique plein écran</button>
        </div>
        <svg id="titrationPlot" viewBox="0 0 320 220" preserveAspectRatio="xMidYMid meet"></svg>
      </div>
    </div>

    <!-- Tableau des points -->
    <div class="row">
      <div class="card" id="titrationTableCard" style="display:none;">
        <h3 style="font-size:0.9rem; margin-top:0;">Tableau des mesures</h3>
        <table id="titrationTable">
          <thead>
            <tr>
              <th>V ajouté (mL)</th>
              <th>pH de la solution titrée</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div id="titrationTableStatus"></div>
      </div>
    </div>

    <!-- Journal tout en bas -->
    <div class="row">
      <div class="card log-card">
        <h3>Journal des actions</h3>
        <div id="log" class="log"></div>
      </div>
    </div>
  </div>

  <!-- Overlay plein écran -->
  <div id="fullscreenOverlay" class="fullscreen-overlay">
    <div class="fullscreen-panel">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
        <div>
          <strong>Courbe de titrage – plein écran</strong>
          <span id="eqInfo" style="font-size:0.8rem; margin-left:8px;"></span>
        </div>
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <!-- Sigmoïde OFF par défaut -->
          <button class="btn btn-small" id="sigmoidToggleBtn">Courbe : OFF</button>
          <button class="btn btn-small" id="tangentBtn">Tangentes</button>
          <button class="btn btn-small" id="midTangentBtn">3e tangente</button>
          <button class="btn btn-small" id="charPointsBtn">Points caractéristiques : OFF</button>
          <button class="btn btn-small" id="fullscreenCloseBtn">Fermer</button>
        </div>
      </div>
      <svg id="fullscreenPlot" viewBox="0 0 800 500" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
  </div>

  <script>
    const state = {
      poweredOn: false,
      part: "A",
      currentBecher: 4,
      calibrated7: false,
      calibrated4: false,
      rinsedSinceLastSolution: false,
      calibrationStep: 0,
      currentReading: null,
      titration: {
        mode: "AFBF",
        analyteFormula: "",
        titrantFormula: "",
        analyteConcHidden: 0.1,
        titrantConc: 0.10,
        analyteVolume: 25.0,
        addedVolume: 0.0,
        Veq: null,
        points: []
      },
      knob7Angle: 0,
      knob4Angle: 0,
      eqConstruction: {
        showSigmoid: false,
        showTangents: false,
        showMidTangent: false,
        showCharacteristicPoints: false
      }
    };

    const KNOB_MIN = -135;
    const KNOB_MAX = 135;

    const tab1 = document.getElementById("tab1");
    const tab2 = document.getElementById("tab2");
    const tab3 = document.getElementById("tab3");

    const powerBtn = document.getElementById("powerBtn");
    const ledPower = document.getElementById("ledPower");
    const ledCal   = document.getElementById("ledCal");

    const digitalValue  = document.getElementById("digitalValue");
    const digitalStatus = document.getElementById("digitalStatus");

    const partDescription  = document.getElementById("partDescription");
    const electrodeStatus  = document.getElementById("electrodeStatus");
    const extraStatus      = document.getElementById("extraStatus");
    const logContainer     = document.getElementById("log");

    const bechers    = document.querySelectorAll(".beaker");
    const electrode  = document.getElementById("electrode");

    const b1Title = document.getElementById("b1Title");
    const b1Subtitle = document.getElementById("b1Subtitle");
    const b2Title = document.getElementById("b2Title");
    const b2Subtitle = document.getElementById("b2Subtitle");
    const b3Title = document.getElementById("b3Title");
    const b3Subtitle = document.getElementById("b3Subtitle");
    const b4Title = document.getElementById("b4Title");
    const b4Subtitle = document.getElementById("b4Subtitle");

    const stir1Btn = document.getElementById("stir1Btn");
    const stir2Btn = document.getElementById("stir2Btn");
    const stirrers = document.querySelectorAll(".stirrer");

    const knob7 = document.getElementById("knob7");
    const knob4 = document.getElementById("knob4");

    const titrationControls   = document.getElementById("titrationControls");
    const titrationPlotCard   = document.getElementById("titrationPlotCard");
    const titrationPlot       = document.getElementById("titrationPlot");

    const titrationTableCard  = document.getElementById("titrationTableCard");
    const titrationTableBody  = document.querySelector("#titrationTable tbody");
    const titrationTableStatus = document.getElementById("titrationTableStatus");

    const titrationAnalyteLabel = document.getElementById("titrationAnalyteLabel");
    const titrantLabel          = document.getElementById("titrantLabel");

    const analyteFormulaInput = document.getElementById("analyteFormula");
    const analyteVolumeInput  = document.getElementById("analyteVolume");
    const titrantFormulaInput = document.getElementById("titrantFormula");

    const add05Btn          = document.getElementById("add05Btn");
    const add1Btn           = document.getElementById("add1Btn");
    const add2Btn           = document.getElementById("add2Btn");
    const resetTitrationBtn = document.getElementById("resetTitrationBtn");
    const titrationStatus   = document.getElementById("titrationStatus");

    const becher1Div = document.querySelector('.beaker[data-becher="1"]');
    const becher2Div = document.querySelector('.beaker[data-becher="2"]');

    const fullscreenBtn       = document.getElementById("fullscreenBtn");
    const fullscreenOverlay   = document.getElementById("fullscreenOverlay");
    const fullscreenPlot      = document.getElementById("fullscreenPlot");
    const fullscreenCloseBtn  = document.getElementById("fullscreenCloseBtn");
    const eqInfo              = document.getElementById("eqInfo");
    const sigmoidToggleBtn    = document.getElementById("sigmoidToggleBtn");
    const tangentBtn          = document.getElementById("tangentBtn");
    const midTangentBtn       = document.getElementById("midTangentBtn");
    const charPointsBtn       = document.getElementById("charPointsBtn");

    function log(msg) {
      const entry = document.createElement("div");
      entry.className = "log-entry";
      const timeSpan = document.createElement("span");
      timeSpan.className = "time";
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, "0");
      const mm = String(now.getMinutes()).padStart(2, "0");
      timeSpan.textContent = `[${hh}:${mm}]`;
      const msgSpan = document.createElement("span");
      msgSpan.textContent = " " + msg;
      entry.appendChild(timeSpan);
      entry.appendChild(msgSpan);
      logContainer.prepend(entry);
    }

    function formatPh(v) {
      if (v == null || isNaN(v)) return "--.-";
      return v.toFixed(1);
    }

    function log10(x) {
      return Math.log(x) / Math.LN10;
    }

    function isFullyCalibrated() {
      return state.calibrated7 && state.calibrated4;
    }

    function resetAfterContamination() {
      document.body.classList.add("flash-red");
      setTimeout(() => document.body.classList.remove("flash-red"), 600);

      log("❌ Rinçage oublié : contamination de l’électrode. Remise à zéro (retour au bécher de repos, calibration perdue).");

      state.currentBecher = 4;
      state.rinsedSinceLastSolution = false;
      state.calibrated7 = false;
      state.calibrated4 = false;
      state.calibrationStep = 0;
      state.currentReading = null;

      attachElectrodeToBecher(4);
      updateElectrodeStatus();
      updateDisplay();
    }

    function canMoveToBecher(target) {
      if (state.currentBecher == null) return true;
      if (target === 3) return true;
      if (target === state.currentBecher) return true;

      if (!state.rinsedSinceLastSolution && state.currentBecher !== 3) {
        resetAfterContamination();
        return false;
      }
      return true;
    }

    function computeTruePh() {
      const b = state.currentBecher;
      if (b == null) return null;

      // Partie A : étalonnage, valeurs fixes des tampons
      if (state.part === "A") {
        if (b === 1) return 7.0;
        if (b === 2) return 4.0;
        return null;
      }

      // Parties T1 / T2 : pH donné par le modèle de titrage,
      // uniquement si l'électrode est dans le bécher 1 (solution à titrer)
      if ((state.part === "T1" || state.part === "T2") && b === 1) {
        return computeTitrationPh();
      }

      // Sinon : rien de pertinent à mesurer
      return null;
    }

    function computeReading(truePh) {
      if (!state.poweredOn || truePh == null || !isFinite(truePh)) return null;

      if (state.part === "A") {
        // En mode étalonnage, la lecture dépend du réglage des potars
        let offset = 0;

        if (state.currentBecher === 1) {
          // Réglage pH 7 : variation d'environ ±1 unité sur toute la course
          offset = (state.knob7Angle / KNOB_MAX) * 1.0;
        } else if (state.currentBecher === 2) {
          // Réglage pH 4 : même principe
          offset = (state.knob4Angle / KNOB_MAX) * 1.0;
        }

        return truePh + offset;
      }

      // En titrage : petite fluctuation pour faire "vrai"
      const noise = (Math.random() - 0.5) * 0.05;
      return truePh + noise;
    }

    function updateDisplay() {
      const truePh = computeTruePh();
      const reading = computeReading(truePh);
      state.currentReading = reading;

      digitalValue.textContent = formatPh(reading);

      if (!state.poweredOn) {
        digitalStatus.textContent = "Éteint";
      } else if (state.part === "A") {
        if (!state.calibrated7 && !state.calibrated4) {
          digitalStatus.textContent = "Non calibré";
        } else if (state.calibrated7 && !state.calibrated4) {
          digitalStatus.textContent = "Calibré sur pH 7";
        } else {
          digitalStatus.textContent = "Calibré (pH 7 & 4)";
        }
      } else if (state.part === "T1") {
        digitalStatus.textContent = "Titrage AF / BF";
      } else if (state.part === "T2") {
        digitalStatus.textContent = "Titrage BF / AF";
      }

      ledCal.classList.remove("on", "warn");
      if (state.calibrated7 && state.calibrated4) {
        ledCal.classList.add("on");
      } else if (state.calibrated7) {
        ledCal.classList.add("warn");
      }
    }

    function randomAnalyteConc() {
      const c = 0.08 + Math.random() * 0.04;
      return parseFloat(c.toFixed(4));
    }

    function computePhAtVolume(Vb_mL) {
      const t = state.titration;
      const Ca = Math.max(t.analyteConcHidden, 0);
      const Cb = Math.max(t.titrantConc, 0);
      const V0 = Math.max(t.analyteVolume, 0) / 1000;
      const Vb = Math.max(Vb_mL, 0) / 1000;

      if (Ca === 0 || Cb === 0 || V0 === 0) return null;

      if (t.mode === "AFBF") {
        const nA0 = Ca * V0;
        const nB  = Cb * Vb;
        const Vtot = V0 + Vb || 1e-9;

        if (Vb === 0) {
          const H = nA0 / V0;
          return -log10(H);
        }

        if (nB < nA0) {
          const H = (nA0 - nB) / Vtot;
          return -log10(H);
        } else if (Math.abs(nB - nA0) < 1e-12) {
          return 7.0;
        } else {
          const OH = (nB - nA0) / Vtot;
          const pOH = -log10(OH);
          return 14 - pOH;
        }
      } else {
        const nB0 = Ca * V0;
        const nA  = Cb * Vb;
        const Vtot = V0 + Vb || 1e-9;

        if (Vb === 0) {
          const OH = nB0 / V0;
          const pOH = -log10(OH);
          return 14 - pOH;
        }

        if (nA < nB0) {
          const OH = (nB0 - nA) / Vtot;
          const pOH = -log10(OH);
          return 14 - pOH;
        } else if (Math.abs(nA - nB0) < 1e-12) {
          return 7.0;
        } else {
          const H = (nA - nB0) / Vtot;
          return -log10(H);
        }
      }
    }

    function computeTitrationPh() {
      return computePhAtVolume(state.titration.addedVolume);
    }

    function resetTitrationState() {
      const t = state.titration;
      t.addedVolume = 0.0;
      t.points = [];
      state.eqConstruction.showSigmoid = false;
      state.eqConstruction.showTangents = false;
      state.eqConstruction.showMidTangent = false;
      state.eqConstruction.showCharacteristicPoints = false;
      eqInfo.textContent = "";
      sigmoidToggleBtn.textContent = "Courbe : OFF";
      if (tangentBtn) tangentBtn.classList.remove("btn-primary");
      if (midTangentBtn) midTangentBtn.classList.remove("btn-primary");
      if (charPointsBtn) {
        charPointsBtn.textContent = "Points caractéristiques : OFF";
        charPointsBtn.classList.remove("btn-primary");
      }

      t.analyteConcHidden = randomAnalyteConc();

      if (t.analyteVolume <= 0) {
        t.analyteVolume = 25.0;
      }

      if (state.part === "T1") {
        t.mode = "AFBF";
        if (!t.analyteFormula) t.analyteFormula = "HCl";
        if (!t.titrantFormula) t.titrantFormula = "NaOH";
      } else if (state.part === "T2") {
        t.mode = "BFSA";
        if (!t.analyteFormula) t.analyteFormula = "NaOH";
        if (!t.titrantFormula) t.titrantFormula = "HCl";
      }

      analyteFormulaInput.value = t.analyteFormula;
      titrantFormulaInput.value = t.titrantFormula;
      analyteVolumeInput.value  = t.analyteVolume;

      const Ca = t.analyteConcHidden;
      const Cb = t.titrantConc;
      const V0_L = t.analyteVolume / 1000;
      const Veq_L = (Ca * V0_L) / Cb;
      t.Veq = Veq_L * 1000;

      // Ajout automatique du point caractéristique V = 0 mL dans le tableau
      const pH0 = computePhAtVolume(0);
      if (pH0 != null && isFinite(pH0)) {
        t.points.push({ V: 0, pH: pH0, characteristic: true });
      }

      titrationStatus.textContent =
        "Volume ajouté : 0,00 mL – Point équivalent (volumétrique) : Vₑq ≈ " +
        t.Veq.toFixed(2).replace(".", ",") +
        " mL";

      updateTitrationTable();
      drawTitrationPlot();
      updateDisplay();
    }

    function addTitrantVolume(delta_mL) {
      const t = state.titration;
      t.addedVolume += delta_mL;

      const truePh = computeTitrationPh();
      const reading = computeReading(truePh);
      state.currentReading = reading;

      if (truePh != null && isFinite(truePh)) {
        t.points.push({ V: t.addedVolume, pH: truePh });
      }

      titrationStatus.textContent =
        "Volume ajouté : " +
        t.addedVolume.toFixed(2).replace(".", ",") +
        " mL – Point équivalent (volumétrique) : Vₑq ≈ " +
        (t.Veq != null ? t.Veq.toFixed(2).replace(".", ",") : "–") +
        " mL";

      updateTitrationTable();
      drawTitrationPlot();
      drawFullscreenPlot();
      updateDisplay();

      log(
        "Ajout de " +
          delta_mL.toFixed(2).replace(".", ",") +
          " mL de solution titrante (V total = " +
          t.addedVolume.toFixed(2).replace(".", ",") +
          " mL)."
      );
    }

    function updateTitrationTable() {
      const pts = state.titration.points;
      titrationTableBody.innerHTML = "";
      pts.forEach(p => {
        const tr = document.createElement("tr");
        const tdV = document.createElement("td");
        const tdpH = document.createElement("td");
        tdV.textContent = p.V.toFixed(2).replace(".", ",");
        tdpH.textContent = p.pH.toFixed(2) + (p.characteristic ? " (*)" : "");
        tr.appendChild(tdV);
        tr.appendChild(tdpH);
        titrationTableBody.appendChild(tr);
      });
      titrationTableStatus.textContent =
        pts.length === 0
          ? "Aucun point mesuré pour l’instant."
          : pts.length + " point(s) de mesure affiché(s). " +
            (pts.some(p => p.characteristic)
              ? "(*) pH pour V = 0,00 mL (point caractéristique)."
              : "");
    }

    /* --- Sigmoïde théorique (échantillonnage) --- */
    function getSigmoidSamples(maxV) {
      const N = 200;
      const samples = [];
      for (let i = 0; i <= N; i++) {
        const V = (maxV * i) / N;
        const ph = computePhAtVolume(V);
        if (ph != null && isFinite(ph)) {
          samples.push({ V, pH: ph });
        }
      }
      return samples;
    }

    /* --- Rendu des graphes --- */
    function renderTitrationPlot(svg, width, height, fullscreen) {
      const t = state.titration;
      svg.innerHTML = "";

      const marginLeft = 40;
      const marginRight = 10;
      const marginTop = 10;
      const marginBottom = 25;

      const innerWidth = width - marginLeft - marginRight;
      const innerHeight = height - marginTop - marginBottom;

      const maxV = Math.max(
        10,
        ...t.points.map(p => p.V),
        t.addedVolume,
        (t.Veq || 0) * 1.2
      );
      const maxPh = 14;
      const minPh = 0;

      const ns = "http://www.w3.org/2000/svg";

      function xScale(V) {
        return marginLeft + (V / maxV) * innerWidth;
      }

      function yScale(pH) {
        const clamped = Math.max(minPh, Math.min(maxPh, pH));
        return marginTop + (maxPh - clamped) / (maxPh - minPh) * innerHeight;
      }

      const xAxis = document.createElementNS(ns, "line");
      xAxis.setAttribute("x1", marginLeft);
      xAxis.setAttribute("y1", height - marginBottom);
      xAxis.setAttribute("x2", width - marginRight);
      xAxis.setAttribute("y2", height - marginBottom);
      xAxis.setAttribute("stroke", "#9ca3af");
      xAxis.setAttribute("stroke-width", "1");
      svg.appendChild(xAxis);

      const yAxis = document.createElementNS(ns, "line");
      yAxis.setAttribute("x1", marginLeft);
      yAxis.setAttribute("y1", marginTop);
      yAxis.setAttribute("x2", marginLeft);
      yAxis.setAttribute("y2", height - marginBottom);
      yAxis.setAttribute("stroke", "#9ca3af");
      yAxis.setAttribute("stroke-width", "1");
      svg.appendChild(yAxis);

      const xLabel = document.createElementNS(ns, "text");
      xLabel.setAttribute("x", (marginLeft + width - marginRight) / 2);
      xLabel.setAttribute("y", height - 5);
      xLabel.setAttribute("text-anchor", "middle");
      xLabel.setAttribute("font-size", fullscreen ? "13" : "10");
      xLabel.textContent = "V ajouté (mL)";
      svg.appendChild(xLabel);

      const yLabel = document.createElementNS(ns, "text");
      yLabel.setAttribute("x", 10);
      yLabel.setAttribute("y", marginTop + innerHeight / 2);
      yLabel.setAttribute("text-anchor", "middle");
      yLabel.setAttribute("font-size", fullscreen ? "13" : "10");
      yLabel.setAttribute("transform", "rotate(-90 10 " + (marginTop + innerHeight / 2) + ")");
      yLabel.textContent = "pH";
      svg.appendChild(yLabel);

      [0, 7, 14].forEach(v => {
        const y = yScale(v);
        const tick = document.createElementNS(ns, "line");
        tick.setAttribute("x1", marginLeft - 4);
        tick.setAttribute("y1", y);
        tick.setAttribute("x2", marginLeft);
        tick.setAttribute("y2", y);
        tick.setAttribute("stroke", "#9ca3af");
        tick.setAttribute("stroke-width", "1");
        svg.appendChild(tick);

        const txt = document.createElementNS(ns, "text");
        txt.setAttribute("x", marginLeft - 6);
        txt.setAttribute("y", y + 3);
        txt.setAttribute("text-anchor", "end");
        txt.setAttribute("font-size", fullscreen ? "11" : "9");
        txt.textContent = v.toString();
        svg.appendChild(txt);
      });

      if (state.titration.points.length === 0) return;

      const eqC = state.eqConstruction;

      // En plein écran : sigmoïde théorique visible seulement si showSigmoid = true
      if (fullscreen && eqC.showSigmoid) {
        const curvePts = getSigmoidSamples(maxV);
        if (curvePts.length > 1) {
          // Courbe sigmoïde théorique
          const path = document.createElementNS(ns, "polyline");
          const d = curvePts
            .map(p => xScale(p.V) + "," + yScale(p.pH))
            .join(" ");
          path.setAttribute("points", d);
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", "#111827");
          path.setAttribute("stroke-width", "2.2");
          svg.appendChild(path);

          // Construction des tangentes parallèles comme sur le schéma d'exemple
          if (eqC.showTangents && t.Veq != null) {
            // Calcul des pentes par dérivation numérique sur la sigmoïde
            const left = [];
            const right = [];
            for (let i = 1; i < curvePts.length - 1; i++) {
              const pPrev = curvePts[i - 1];
              const p = curvePts[i];
              const pNext = curvePts[i + 1];
              const dV = pNext.V - pPrev.V;
              if (dV <= 0) continue;
              const m = (pNext.pH - pPrev.pH) / dV; // dpH/dV
              if (!isFinite(m)) continue;
              if (p.V < t.Veq) left.push({ V: p.V, pH: p.pH, slope: m });
              else if (p.V > t.Veq) right.push({ V: p.V, pH: p.pH, slope: m });
            }

            if (left.length && right.length) {
              // On cherche une paire de points (un avant Veq, un après Veq) où les pentes sont presque égales
              let bestL = null;
              let bestR = null;
              let bestScore = Infinity;
              let bestSlopeMag = -Infinity;

              for (const L of left) {
                for (const R of right) {
                  const diff = Math.abs(L.slope - R.slope);
                  const avgMag = (Math.abs(L.slope) + Math.abs(R.slope)) / 2;
                  if (
                    diff < bestScore - 1e-6 ||
                    (Math.abs(diff - bestScore) < 1e-6 && avgMag > bestSlopeMag)
                  ) {
                    bestScore = diff;
                    bestSlopeMag = avgMag;
                    bestL = L;
                    bestR = R;
                  }
                }
              }

              if (bestL && bestR) {
                // Pente commune pour garantir le parallélisme
                const m = (bestL.slope + bestR.slope) / 2;

                const Vstart = 0;
                const Vend = maxV;
                let b1 = null;
                let b2 = null;

                function addTangentAtPoint(pt, isFirst) {
                  const b = pt.pH - m * pt.V; // ordonnée à l'origine (pH à V=0)
                  if (isFirst) b1 = b;
                  else b2 = b;

                  const pHstart = m * Vstart + b;
                  const pHend = m * Vend + b;

                  const line = document.createElementNS(ns, "line");
                  line.setAttribute("x1", xScale(Vstart));
                  line.setAttribute("y1", yScale(pHstart));
                  line.setAttribute("x2", xScale(Vend));
                  line.setAttribute("y2", yScale(pHend));
                  line.setAttribute("stroke", "#ef4444");
                  line.setAttribute("stroke-width", "1.6");
                  line.setAttribute("stroke-dasharray", "4 3");
                  svg.appendChild(line);
                }

                // Tangente A (avant Veq) et tangente B (après Veq), parallèles entre elles
                addTangentAtPoint(bestL, true);
                addTangentAtPoint(bestR, false);

                // 3e tangente équidistante des deux premières
                if (eqC.showMidTangent && b1 != null && b2 != null) {
                  const bMid = (b1 + b2) / 2;
                  const pHstartMid = m * Vstart + bMid;
                  const pHendMid = m * Vend + bMid;

                  const midLine = document.createElementNS(ns, "line");
                  midLine.setAttribute("x1", xScale(Vstart));
                  midLine.setAttribute("y1", yScale(pHstartMid));
                  midLine.setAttribute("x2", xScale(Vend));
                  midLine.setAttribute("y2", yScale(pHendMid));
                  midLine.setAttribute("stroke", "#10b981");
                  midLine.setAttribute("stroke-width", "1.6");
                  midLine.setAttribute("stroke-dasharray", "4 3");
                  svg.appendChild(midLine);
                }
              }
            }
          }
        }
      } else if (!fullscreen) {
        // Petit graphe : seulement la courbe expérimentale
        const poly = document.createElementNS(ns, "polyline");
        const pointsStr = state.titration.points
          .map(p => xScale(p.V) + "," + yScale(p.pH))
          .join(" ");
        poly.setAttribute("points", pointsStr);
        poly.setAttribute("fill", "none");
        poly.setAttribute("stroke", "#1f2937");
        poly.setAttribute("stroke-width", "1.5");
        svg.appendChild(poly);
      }

      // Points expérimentaux
      state.titration.points.forEach(p => {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("cx", xScale(p.V));
        c.setAttribute("cy", yScale(p.pH));
        c.setAttribute("r", fullscreen ? 3.5 : 2.8);
        c.setAttribute("fill", "#111827");
        svg.appendChild(c);
      });

      // Points caractéristiques rouge / vert / bleu uniquement si demandé
      if (fullscreen && state.eqConstruction.showCharacteristicPoints) {
        const fontSize = 12;

        // Rouge : solution à titrer pour V = 0 mL
        const pH0 = computePhAtVolume(0);
        if (pH0 != null && isFinite(pH0)) {
          const x0 = xScale(0);
          const y0 = yScale(pH0);

          const c0 = document.createElementNS(ns, "circle");
          c0.setAttribute("cx", x0);
          c0.setAttribute("cy", y0);
          c0.setAttribute("r", 5);
          c0.setAttribute("fill", "#ef4444");
          svg.appendChild(c0);


          // Indication du pH initial sur l'axe du pH
          const label0axis = document.createElementNS(ns, "text");
          label0axis.setAttribute("x", marginLeft - 10);
          label0axis.setAttribute("y", y0 + 4);
          label0axis.setAttribute("text-anchor", "end");
          label0axis.setAttribute("font-size", fontSize.toString());
          label0axis.setAttribute("fill", "#ef4444");
          label0axis.textContent = "pH = " + pH0.toFixed(2);
          svg.appendChild(label0axis);
        }

        // Vert : point équivalent théorique (V = Veq)
        if (t.Veq != null) {
          // Pour un titrage acide fort / base forte (ou l'inverse),
          // le pH théorique au point équivalent est 7,00.
          let pHeq;
          if (t.mode === "AFBF" || t.mode === "BFSA") {
            pHeq = 7.0;
          } else {
            pHeq = computePhAtVolume(t.Veq);
          }
          if (pHeq != null && isFinite(pHeq)) {
            const xEq = xScale(t.Veq);
            const yEq = yScale(pHeq);

            const cEq = document.createElementNS(ns, "circle");
            cEq.setAttribute("cx", xEq);
            cEq.setAttribute("cy", yEq);
            cEq.setAttribute("r", 5);
            cEq.setAttribute("fill", "#10b981");
            svg.appendChild(cEq);


// Lignes vertes : horizontale vers axe pH et verticale vers axe volume
// Verticale
const vLineEq = document.createElementNS(ns, "line");
vLineEq.setAttribute("x1", xEq);
vLineEq.setAttribute("y1", yEq);
vLineEq.setAttribute("x2", xEq);
vLineEq.setAttribute("y2", height - marginBottom);
vLineEq.setAttribute("stroke", "#10b981");
vLineEq.setAttribute("stroke-width", "1");
svg.appendChild(vLineEq);

// Horizontale
const hLineEq = document.createElementNS(ns, "line");
hLineEq.setAttribute("x1", marginLeft);
hLineEq.setAttribute("y1", yEq);
hLineEq.setAttribute("x2", xEq);
hLineEq.setAttribute("y2", yEq);
hLineEq.setAttribute("stroke", "#10b981");
hLineEq.setAttribute("stroke-width", "1");
svg.appendChild(hLineEq);

// Label pH_eq
const labelEqPh = document.createElementNS(ns, "text");
labelEqPh.setAttribute("x", marginLeft - 10);
labelEqPh.setAttribute("y", yEq + 4);
labelEqPh.setAttribute("text-anchor", "end");
labelEqPh.setAttribute("font-size", fontSize.toString());
labelEqPh.setAttribute("fill", "#10b981");
labelEqPh.textContent = "pH = " + pHeq.toFixed(2);
svg.appendChild(labelEqPh);

// Label V_eq
const labelEqV = document.createElementNS(ns, "text");
labelEqV.setAttribute("x", xEq);
labelEqV.setAttribute("y", height - marginBottom + 16);
labelEqV.setAttribute("text-anchor", "middle");
labelEqV.setAttribute("font-size", fontSize.toString());
labelEqV.setAttribute("fill", "#10b981");
labelEqV.textContent = "Vₑq = " + t.Veq.toFixed(2).replace(".", ",") + " mL";
svg.appendChild(labelEqV);

          }
        }

        // Bleu : plateau (pH du titrant) pris comme dernier point de la courbe
        if (state.titration.points.length > 0) {
          const last = state.titration.points[state.titration.points.length - 1];
          if (last && last.pH != null && isFinite(last.pH)) {
            const xb = xScale(last.V);
            const yb = yScale(last.pH);

            const cB = document.createElementNS(ns, "circle");
            cB.setAttribute("cx", xb);
            cB.setAttribute("cy", yb);
            cB.setAttribute("r", 5);
            cB.setAttribute("fill", "#3b82f6");
            svg.appendChild(cB);


// Ligne bleue horizontale vers l'axe du pH
const hLineB = document.createElementNS(ns, "line");
hLineB.setAttribute("x1", marginLeft);
hLineB.setAttribute("y1", yb);
hLineB.setAttribute("x2", xb);
hLineB.setAttribute("y2", yb);
hLineB.setAttribute("stroke", "#3b82f6");
hLineB.setAttribute("stroke-width", "1");
svg.appendChild(hLineB);

// Label pH sur l'axe du pH
const labelBaxis = document.createElementNS(ns, "text");
labelBaxis.setAttribute("x", marginLeft - 10);
labelBaxis.setAttribute("y", yb + 4);
labelBaxis.setAttribute("text-anchor", "end");
labelBaxis.setAttribute("font-size", fontSize.toString());
labelBaxis.setAttribute("fill", "#3b82f6");
labelBaxis.textContent = "pH = " + last.pH.toFixed(2);
svg.appendChild(labelBaxis);

          }
        }
      }
    }

    function drawTitrationPlot() {
      renderTitrationPlot(titrationPlot, 320, 220, false);
    }

    function drawFullscreenPlot() {
      if (fullscreenOverlay.style.display !== "flex") return;
      renderTitrationPlot(fullscreenPlot, 800, 500, true);

      const t = state.titration;
      if (t.points.length === 0) {
        eqInfo.textContent =
          "Ajoute d’abord quelques points de titrage pour afficher quelque chose.";
        return;
      }

      const pH0 = computePhAtVolume(0);
      let pHeq = null;
      if (t.Veq != null) {
        if (t.mode === "AFBF" || t.mode === "BFSA") {
          pHeq = 7.0;
        } else {
          pHeq = computePhAtVolume(t.Veq);
        }
      }
      const last = t.points.length > 0 ? t.points[t.points.length - 1] : null;

      let html = "";
      if (t.Veq != null && pHeq != null && isFinite(pHeq)) {
        html +=
          'Coordonnées du point équivalent : ' +
          '<span style="color:green;">(Vₑq ≈ ' +
          t.Veq.toFixed(2).replace(".", ",") +
          " mL ; pH ≈ " +
          pHeq.toFixed(2) +
          ")</span>. ";
      }
      if (pH0 != null && isFinite(pH0)) {
        html +=
          'Solution à titrer (V = 0,00 mL) : ' +
          '<span style="color:red;">(pH ≈ ' +
          pH0.toFixed(2) +
          ")</span>. ";
      }
      if (last && last.pH != null && isFinite(last.pH)) {
        html +=
          'Plateau (titrant) : ' +
          '<span style="color:blue;">pH ≈ ' +
          last.pH.toFixed(2) +
          " (plateau)</span>.";
      }
      eqInfo.innerHTML = html;
    }

    function attachElectrodeToBecher(n) {
      const targetGraphic = document.querySelector(
        '.beaker[data-becher="' + n + '"] .beaker-graphic'
      );
      if (targetGraphic) {
        targetGraphic.appendChild(electrode);
      }
    }

    function moveElectrodeToBecher(n) {
      if (!canMoveToBecher(n)) return;

      const previous = state.currentBecher;
      state.currentBecher = n;
      attachElectrodeToBecher(n);

      if (n === 3) {
        state.rinsedSinceLastSolution = true;
        log("Électrode rincée dans le Bécher 3 (eau distillée).");
      } else {
        if (previous === 3 && previous != null) {
          log("Électrode passée du Bécher 3 (rinçage) au Bécher " + n + ".");
        } else if (previous == null) {
          log("Électrode plongée dans le Bécher " + n + ".");
        } else {
          log("Électrode déplacée vers le Bécher " + n + ".");
        }
        state.rinsedSinceLastSolution = false;
      }

      bechers.forEach(b => {
        const id = parseInt(b.dataset.becher, 10);
        b.classList.toggle("active", id === n);
      });

      updateElectrodeStatus();
      updateDisplay();
    }

    function updateElectrodeStatus() {
      let text = "";
      if (state.currentBecher === 1) {
        if (state.part === "A") {
          text = "Électrode dans le Bécher 1 (tampon pH 7)";
        } else {
          text = "Électrode dans le Bécher 1 (solution à titrer)";
        }
      } else if (state.currentBecher === 2) {
        if (state.part === "A") {
          text = "Électrode dans le Bécher 2 (tampon pH 4)";
        } else {
          text = "Électrode dans le Bécher 2 (non utilisé dans cet onglet)";
        }
      } else if (state.currentBecher === 3) {
        text = "Électrode dans le Bécher 3 (rinçage)";
      } else if (state.currentBecher === 4) {
        text = "Électrode dans le Bécher 4 (repos)";
      }
      electrodeStatus.innerHTML = "Électrode : <strong>" + text + "</strong>";
    }

    function updatePartUI() {
      [tab1, tab2, tab3].forEach(btn => btn.classList.remove("active"));
      if (state.part === "A") tab1.classList.add("active");
      if (state.part === "T1") tab2.classList.add("active");
      if (state.part === "T2") tab3.classList.add("active");

      if (state.part === "A") {
        becher2Div.style.display = "";
        becher1Div.classList.add("beaker-color-green");
        becher2Div.classList.add("beaker-color-pink");

        partDescription.innerHTML =
          "<strong>Onglet 1 :</strong> calibration du pH-mètre avec les tampons pH 7 et pH 4.";
        b1Title.textContent = "Bécher 1 – Tampon pH 7";
        b1Subtitle.textContent = "Solution tampon pH 7,0";
        b2Title.textContent = "Bécher 2 – Tampon pH 4";
        b2Subtitle.textContent = "Solution tampon pH 4,0";
        b3Title.textContent = "Bécher 3 – Rinçage";
        b3Subtitle.textContent = "Eau distillée";
        b4Title.textContent = "Bécher 4 – Repos";
        b4Subtitle.textContent = "";

        titrationControls.style.display = "none";
        titrationPlotCard.style.display = "none";
        titrationTableCard.style.display = "none";
        extraStatus.textContent =
          "Utilise les boutons/knobs pH 7 puis pH 4 pour calibrer.";
      } else {
        becher1Div.classList.remove("beaker-color-green");
        becher2Div.classList.remove("beaker-color-pink");
        becher2Div.style.display = "none";

        if (state.currentBecher === 2) {
          state.currentBecher = 4;
          attachElectrodeToBecher(4);
        }

        titrationControls.style.display = "block";
        titrationPlotCard.style.display = "block";
        titrationTableCard.style.display = "block";

        if (state.part === "T1") {
          partDescription.innerHTML =
            "<strong>Onglet 2 :</strong> titrage d’un acide fort par une base forte.";
          b1Title.textContent = "Bécher 1 – Solution à titrer";
          b1Subtitle.textContent = "Acide fort (par ex. HCl)";
          b2Title.textContent = "";
          b2Subtitle.textContent = "";
          b3Title.textContent = "Bécher 3 – Rinçage";
          b3Subtitle.textContent = "Eau distillée";
          b4Title.textContent = "Bécher 4 – Repos";
          b4Subtitle.textContent = "";

          titrationAnalyteLabel.textContent = "Solution à titrer : acide fort";
          titrantLabel.textContent = "Solution titrante : base forte";

          resetTitrationState();

          extraStatus.textContent =
            "Place l’électrode dans le Bécher 1, puis ajoute des volumes de base forte (0,10 mol·L⁻¹).";
        } else if (state.part === "T2") {
          partDescription.innerHTML =
            "<strong>Onglet 3 :</strong> titrage d’une base forte par un acide fort.";
          b1Title.textContent = "Bécher 1 – Solution à titrer";
          b1Subtitle.textContent = "Base forte (par ex. NaOH)";
          b2Title.textContent = "";
          b2Subtitle.textContent = "";
          b3Title.textContent = "Bécher 3 – Rinçage";
          b3Subtitle.textContent = "Eau distillée";
          b4Title.textContent = "Bécher 4 – Repos";
          b4Subtitle.textContent = "";

          titrationAnalyteLabel.textContent = "Solution à titrer : base forte";
          titrantLabel.textContent = "Solution titrante : acide fort";

          resetTitrationState();

          extraStatus.textContent =
            "Place l’électrode dans le Bécher 1, puis ajoute des volumes d’acide fort (0,10 mol·L⁻¹).";
        }
      }

      updateElectrodeStatus();
      updateDisplay();
    }

    function togglePower() {
      state.poweredOn = !state.poweredOn;
      powerBtn.classList.toggle("off", !state.poweredOn);
      ledPower.classList.toggle("on", state.poweredOn);
      log(state.poweredOn ? "pH-mètre allumé." : "pH-mètre éteint.");
      updateDisplay();
    }

    function updateStirrers(on1, on2) {
      stirrers.forEach(s => {
        const id = s.dataset.stirrer;
        const on = id === "1" ? on1 : on2;
        s.classList.toggle("on", on && state.poweredOn);
      });
    }

    function setKnobAngle(el, angle) {
      el.style.transform = "rotate(" + angle + "deg)";
    }

    function makeKnobInteractive(el, type) {
      let isDragging = false;
      let pointerId = null;
      let center = { x: 0, y: 0 };

      el.addEventListener("pointerdown", e => {
        isDragging = true;
        pointerId = e.pointerId;
        el.setPointerCapture(pointerId);
        const rect = el.getBoundingClientRect();
        center = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
        e.preventDefault();
      });

      el.addEventListener("pointermove", e => {
        if (!isDragging || e.pointerId !== pointerId) return;
        const dx = e.clientX - center.x;
        const dy = e.clientY - center.y;
        let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
        if (angle < -180) angle += 360;
        if (angle > 180) angle -= 360;
        angle = Math.max(KNOB_MIN, Math.min(KNOB_MAX, angle));

        if (type === "7") state.knob7Angle = angle;
        else state.knob4Angle = angle;

        setKnobAngle(el, angle);

        // Mise à jour immédiate de l’affichage pendant le réglage
        updateDisplay();
      });

      el.addEventListener("pointerup", e => {
        if (!isDragging || e.pointerId !== pointerId) return;
        isDragging = false;
        el.releasePointerCapture(pointerId);

        if (!state.poweredOn) {
          log("Impossible de calibrer : pH-mètre éteint.");
          return;
        }

        if (state.part !== "A") {
          log("Calibration uniquement en onglet 1 (pH-mètre).");
          return;
        }

        if (type === "7") {
          if (state.currentBecher !== 1) {
            log("Pour régler pH 7, mets l’électrode dans le Bécher 1 (tampon pH 7).");
            return;
          }
          state.calibrated7 = true;
          state.calibrated4 = false;
          state.calibrationStep = 1;
          log("Calibration : réglage sur pH 7,0.");
        } else {
          if (!state.calibrated7) {
            log("Il faut d’abord régler sur pH 7, puis pH 4.");
            return;
          }
          if (state.currentBecher !== 2) {
            log("Pour régler pH 4, mets l’électrode dans le Bécher 2 (tampon pH 4).");
            return;
          }
          state.calibrated4 = true;
          state.calibrationStep = 3;
          log("Calibration : réglage sur pH 4,0. Calibration complète.");
        }

        updateDisplay();
      });
    }

    function openFullscreen() {
      if (state.part === "A") return;
      fullscreenOverlay.style.display = "flex";
      const hasPoints = state.titration.points.length >= 1;

      eqInfo.textContent = hasPoints
        ? "Utilise la sigmoïde pour comparer la courbe théorique aux points expérimentaux."
        : "Ajoute d’abord quelques points de titrage pour afficher quelque chose.";

      sigmoidToggleBtn.textContent = state.eqConstruction.showSigmoid
        ? "Sigmoïde : ON"
        : "Sigmoïde : OFF";

      if (charPointsBtn) {
        charPointsBtn.textContent =
          "Points caractéristiques : " +
          (state.eqConstruction.showCharacteristicPoints ? "ON" : "OFF");
        charPointsBtn.classList.toggle(
          "btn-primary",
          state.eqConstruction.showCharacteristicPoints
        );
      }

      drawFullscreenPlot();
    }

    function closeFullscreen() {
      fullscreenOverlay.style.display = "none";
    }

    function toggleSigmoid() {
      const eqC = state.eqConstruction;
      eqC.showSigmoid = !eqC.showSigmoid;

      if (!eqC.showSigmoid) {
        // Si on masque la sigmoïde, on coupe aussi les tangentes
        eqC.showTangents = false;
        eqC.showMidTangent = false;
        if (tangentBtn) tangentBtn.classList.remove("btn-primary");
        if (midTangentBtn) midTangentBtn.classList.remove("btn-primary");
      }

      sigmoidToggleBtn.textContent = eqC.showSigmoid
        ? "Sigmoïde : ON"
        : "Sigmoïde : OFF";

      drawFullscreenPlot();
    }

    function toggleTangents() {
      const eqC = state.eqConstruction;

      // Si on veut les tangentes alors que la sigmoïde est masquée, on l'allume
      if (!eqC.showSigmoid) {
        eqC.showSigmoid = true;
        sigmoidToggleBtn.textContent = "Sigmoïde : ON";
      }

      eqC.showTangents = !eqC.showTangents;

      // Si on coupe les tangentes, on coupe aussi la 3e tangente
      if (!eqC.showTangents) {
        eqC.showMidTangent = false;
        if (midTangentBtn) midTangentBtn.classList.remove("btn-primary");
      }

      if (tangentBtn) {
        tangentBtn.classList.toggle("btn-primary", eqC.showTangents);
      }

      drawFullscreenPlot();
    }

    function toggleMidTangent() {
      const eqC = state.eqConstruction;

      // Pour voir la 3e tangente, il faut la sigmoïde et les tangentes
      if (!eqC.showSigmoid) {
        eqC.showSigmoid = true;
        sigmoidToggleBtn.textContent = "Sigmoïde : ON";
      }
      if (!eqC.showTangents) {
        eqC.showTangents = true;
        if (tangentBtn) tangentBtn.classList.add("btn-primary");
      }

      eqC.showMidTangent = !eqC.showMidTangent;
      if (midTangentBtn) {
        midTangentBtn.classList.toggle("btn-primary", eqC.showMidTangent);
      }

      drawFullscreenPlot();
    }

    function toggleCharacteristicPoints() {
      const eqC = state.eqConstruction;
      eqC.showCharacteristicPoints = !eqC.showCharacteristicPoints;

      if (charPointsBtn) {
        charPointsBtn.textContent =
          "Points caractéristiques : " + (eqC.showCharacteristicPoints ? "ON" : "OFF");
        charPointsBtn.classList.toggle("btn-primary", eqC.showCharacteristicPoints);
      }

      drawFullscreenPlot();
    }

    function randomKnobAngle() {
      let angle;
      do {
        angle = KNOB_MIN + Math.random() * (KNOB_MAX - KNOB_MIN);
      } while (Math.abs(angle) < 15);
      return angle;
    }

    function init() {
      state.currentBecher = 4;
      attachElectrodeToBecher(4);

      // Positions de départ aléatoires pour forcer le réglage (jamais à midi)
      state.knob7Angle = randomKnobAngle();
      state.knob4Angle = randomKnobAngle();
      setKnobAngle(knob7, state.knob7Angle);
      setKnobAngle(knob4, state.knob4Angle);
      makeKnobInteractive(knob7, "7");
      makeKnobInteractive(knob4, "4");

      let stir1On = false;
      let stir2On = false;
      stir1Btn.addEventListener("click", () => {
        stir1On = !stir1On;
        stir1Btn.textContent = "Agitateur 1 : " + (stir1On ? "ON" : "OFF");
        stir1Btn.classList.toggle("btn-primary", stir1On);
        updateStirrers(stir1On, stir2On);
      });
      stir2Btn.addEventListener("click", () => {
        stir2On = !stir2On;
        stir2Btn.textContent = "Agitateur 2 : " + (stir2On ? "ON" : "OFF");
        stir2Btn.classList.toggle("btn-primary", stir2On);
        updateStirrers(stir1On, stir2On);
      });

      powerBtn.addEventListener("click", togglePower);

      bechers.forEach(b => {
        b.addEventListener("click", () => {
          const n = parseInt(b.dataset.becher, 10);
          if (state.part !== "A" && n === 2) {
            return;
          }
          moveElectrodeToBecher(n);
        });
      });

      tab1.addEventListener("click", () => {
        state.part = "A";
        updatePartUI();
        log("Passage à l’onglet 1 (pH-mètre).");
      });
      tab2.addEventListener("click", () => {
        if (!isFullyCalibrated()) {
          log("Onglet 2 verrouillé : commence par calibrer correctement le pH-mètre (pH 7 puis pH 4).");
          return;
        }
        if (state.currentBecher !== 4) {
          log("Pour passer au titrage, mets d’abord l’électrode au repos dans le Bécher 4.");
          return;
        }
        state.part = "T1";
        updatePartUI();
        log("Passage à l’onglet 2 (titrage AF / BF).");
      });
      tab3.addEventListener("click", () => {
        if (!isFullyCalibrated()) {
          log("Onglet 3 verrouillé : commence par calibrer correctement le pH-mètre (pH 7 puis pH 4).");
          return;
        }
        if (state.currentBecher !== 4) {
          log("Pour passer au titrage, mets d’abord l’électrode au repos dans le Bécher 4.");
          return;
        }
        state.part = "T2";
        updatePartUI();
        log("Passage à l’onglet 3 (titrage BF / AF).");
      });

      analyteFormulaInput.addEventListener("change", () => {
        state.titration.analyteFormula = analyteFormulaInput.value.trim();
      });
      titrantFormulaInput.addEventListener("change", () => {
        state.titration.titrantFormula = titrantFormulaInput.value.trim();
      });
      analyteVolumeInput.addEventListener("change", () => {
        state.titration.analyteVolume =
          parseFloat(analyteVolumeInput.value.replace(",", ".")) || 0;
        resetTitrationState();
      });

      add05Btn.addEventListener("click", () => addTitrantVolume(0.5));
      add1Btn.addEventListener("click", () => addTitrantVolume(1.0));
      add2Btn.addEventListener("click", () => addTitrantVolume(2.0));
      resetTitrationBtn.addEventListener("click", () => {
        resetTitrationState();
        log("Titrage remis à zéro (nouvelle concentration cachée pour la solution à titrer).");
      });

      fullscreenBtn.addEventListener("click", openFullscreen);
      fullscreenCloseBtn.addEventListener("click", closeFullscreen);
      fullscreenOverlay.addEventListener("click", e => {
        if (e.target === fullscreenOverlay) closeFullscreen();
      });

      sigmoidToggleBtn.addEventListener("click", toggleSigmoid);
      tangentBtn.addEventListener("click", toggleTangents);
      midTangentBtn.addEventListener("click", toggleMidTangent);
      charPointsBtn.addEventListener("click", toggleCharacteristicPoints);

      updatePartUI();
      log(
        "Simulation initialisée. Onglet 1 : calibrer le pH-mètre (tampons verts/roses). " +
        "Onglet 2 : titrage acide fort/base forte. " +
        "Onglet 3 : titrage base forte/acide fort."
      );
    }

    init();
  </script>
</body>
</html>
